<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Aether Map | Pre-Placement Cartographer</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Exo+2:wght@300;600&display=swap" rel="stylesheet">
<style>
:root {
    --bg-deep: #020205;
    --glass: rgba(16, 20, 30, 0.65);
    --glass-border: rgba(100, 220, 255, 0.15);
    --accent: #00f3ff;
    --accent-glow: rgba(0, 243, 255, 0.4);
    --text-main: #e0faff;
    --text-dim: #5c7a8a;
}

body {
    margin: 0;
    overflow: hidden;
    background-color: var(--bg-deep);
    font-family: 'Exo 2', sans-serif;
    color: var(--text-main);
    user-select: none;
    -webkit-user-select: none;
}

canvas {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
    touch-action: none; /* Prevents scrolling on mobile while drawing */
}

/* --- HUD UI --- */
.hud {
    position: absolute;
    z-index: 10;
    padding: 16px;
    pointer-events: none;
    width: 100%;
    height: 100%;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

.hud-panel {
    pointer-events: auto;
    background: var(--glass);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid var(--glass-border);
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
}

/* Top Left Info */
.info-panel {
    align-self: flex-start;
    padding: 20px 24px;
    max-width: 320px;
}

h1 {
    margin: 0;
    font-family: 'Cinzel', serif;
    font-size: 22px;
    color: var(--accent);
    text-shadow: 0 0 15px var(--accent-glow);
    letter-spacing: 2px;
}

p.subtitle {
    margin: 8px 0 0;
    font-size: 13px;
    color: var(--text-dim);
    line-height: 1.5;
}

/* Top Right Color Controls (Active Star Color) */
#colorControls {
    position: absolute;
    top: 20px;
    right: 20px;
    align-self: flex-start;
    padding: 15px;
    max-width: 280px;
    display: flex;
    flex-direction: column;
}

#colorControls h2 {
    font-size: 16px;
    margin: 0 0 10px 0;
    color: var(--accent);
    text-shadow: none;
    text-transform: uppercase;
}

.btn-group {
    display: flex;
    gap: 8px;
    margin-top: 8px;
    align-items: center;
}

.color-input-container {
    position: relative;
    flex-shrink: 0;
}

#colorInput {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    width: 40px;
    height: 40px;
    border: 1px solid var(--glass-border);
    padding: 0;
    background: rgba(255, 255, 255, 0.05);
    cursor: pointer;
    border-radius: 8px;
    overflow: hidden;
    flex-shrink: 0;
}

/* Customize the color swatch appearance within the native input */
#colorInput::-webkit-color-swatch { border: 2px solid white; border-radius: 6px; }
#colorInput::-moz-color-swatch { border: 2px solid white; border-radius: 6px; }

/* General Small Button Styling */
.btn-small {
    flex-grow: 1;
    padding: 10px 12px;
    font-size: 13px;
    font-weight: 600;
    text-transform: uppercase;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid var(--glass-border);
    color: var(--text-main);
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
}

.btn-small:hover {
    border-color: var(--accent);
    color: var(--accent);
}

/* Active Color Mode Indicator */
.color-mode-indicator {
    position: absolute;
    top: -5px; right: -5px;
    width: 14px; height: 14px;
    border-radius: 50%;
    background: var(--accent);
    border: 2px solid var(--bg-deep);
    box-shadow: 0 0 10px var(--accent);
    opacity: 0;
    transition: opacity 0.2s, background 0.2s;
}

.color-mode-indicator.active {
    opacity: 1;
}

#rainbowBtn.active {
    background: #ff0077;
    border-color: #ff0077;
    color: #fff;
    box-shadow: 0 0 15px #ff0077;
}

/* Bottom Center Tools */
.toolbar {
    align-self: center;
    margin-bottom: 20px;
    display: flex;
    gap: 12px;
    padding: 10px;
    border-radius: 16px;
}

.btn {
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid transparent;
    color: var(--text-main);
    width: 48px;
    height: 48px;
    border-radius: 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    position: relative;
}

.btn svg {
    width: 20px;
    height: 20px;
    fill: currentColor;
    filter: drop-shadow(0 0 5px rgba(0,0,0,0.5));
}

.btn:hover {
    background: rgba(0, 243, 255, 0.1);
    border-color: var(--accent-glow);
    transform: translateY(-2px);
    color: var(--accent);
    box-shadow: 0 0 15px var(--accent-glow);
}

.btn:active {
    transform: translateY(1px);
}

/* Active button style for selection mode */
.btn.active {
    background: var(--accent);
    color: var(--bg-deep);
    border-color: var(--accent);
    box-shadow: 0 0 20px var(--accent);
    transform: none;
}
.btn.active:hover {
    background: var(--accent);
    color: var(--bg-deep);
}


/* Tooltip */
.btn::after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: 115%;
    left: 50%;
    transform: translateX(-50%);
    background: #000;
    color: #fff;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 10px;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s;
    border: 1px solid #333;
}
.btn:hover::after { opacity: 1; }

/* Zoom Controls (Right) */
.zoom-controls {
    position: absolute;
    right: 20px;
    bottom: 100px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    pointer-events: auto;
}

.zoom-btn {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    background: var(--glass);
    border: 1px solid var(--glass-border);
    color: var(--text-main);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    transition: 0.2s;
}
.zoom-btn:hover {
    background: var(--accent);
    color: #000;
}

/* Stats */
.stats {
    position: absolute;
    bottom: 20px;
    left: 20px;
    font-size: 11px;
    font-family: monospace;
    color: var(--text-dim);
    pointer-events: none;
}

/* Modal & Toast (unchanged) */
.modal-overlay {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.7);
    z-index: 100;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
}
.modal-overlay.active { opacity: 1; pointer-events: auto; }

.modal {
    background: #0f1219;
    border: 1px solid var(--accent);
    padding: 30px;
    border-radius: 12px;
    text-align: center;
    box-shadow: 0 0 50px rgba(0, 243, 255, 0.15);
    max-width: 300px;
}
.modal h2 { margin-top: 0; color: #fff; font-family: 'Cinzel', serif; }
.modal-actions { margin-top: 20px; display: flex; gap: 10px; justify-content: center; }
.btn-primary { background: var(--accent); color: #000; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold; }
.btn-secondary { background: transparent; color: #aaa; border: 1px solid #333; padding: 8px 16px; border-radius: 4px; cursor: pointer; }
.btn-secondary:hover { border-color: #666; color: #fff; }

.toast {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%) translateY(-20px);
    background: rgba(0, 243, 255, 0.15);
    border: 1px solid var(--accent);
    color: var(--accent);
    padding: 8px 24px;
    border-radius: 30px;
    font-size: 12px;
    font-weight: 600;
    opacity: 0;
    transition: all 0.3s;
    pointer-events: none;
    text-shadow: 0 0 10px rgba(0,0,0,0.5);
}
.toast.visible { opacity: 1; transform: translateX(-50%) translateY(0); }

</style>
</head>
<body>

<div id="toast" class="toast">Action Successful</div>

<div class="hud">
    <div class="hud-panel info-panel">
        <h1>Aether Map</h1>
        <p class="subtitle">
            Click empty space to create stars (Draw Mode).<br>
            Stars use the active color/mode selected below.<br>
            Select tool allows for cluster drag and panning.
        </p>
    </div>

    <div id="colorControls" class="hud-panel">
        <h2>Active Star Color</h2>

        <div class="btn-group">
            <!-- Color input sets the fixed color mode -->
            <div class="color-input-container">
                <input type="color" id="colorInput" value="#00f3ff" onchange="app.setFixedColor(this.value)">
                <div id="fixedModeIndicator" class="color-mode-indicator active"></div>
            </div>

            <button class="btn-small" id="rainbowBtn" onclick="app.setRainbowMode()">
                <span style="font-size: 16px;">ðŸŒˆ</span> Rainbow Mode
            </button>
        </div>
        <p style="font-size: 10px; margin-top: 15px; color: var(--text-dim);">
            <span id="currentColorModeText">Color Mode: Fixed (#00f3ff)</span>
        </p>
    </div>

    <div class="hud-panel toolbar">
        <button class="btn" id="drawModeBtn" onclick="app.setMode('draw')" data-tooltip="Draw Mode (Create Stars)">
            <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"/></svg>
        </button>
        <button class="btn" id="selectModeBtn" onclick="app.setMode('select')" data-tooltip="Drag Star/Cluster Mode">
            <svg viewBox="0 0 24 24"><path d="M7 19h10V4H7v15zm-2-2V6c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2v11c0 1.1-.9 2-2 2H7c-1.1 0-2-.9-2-2zM4 21c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-2H4v2z"/></svg>
        </button>
        <div style="width: 12px; border-left: 1px solid rgba(255,255,255,0.1);"></div>
        <button class="btn" onclick="app.undo()" data-tooltip="Undo (Ctrl+Z)">
            <svg viewBox="0 0 24 24"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/></svg>
        </button>
        <button class="btn" onclick="app.requestClear()" data-tooltip="Clear Universe">
            <svg viewBox="0 0 24 24"><path d="M15 16h4v2h-4zm0-8h7v2h-7zm0 4h6v2h-6zM3 18c0 1.1.9 2 2 2h6c1.1 0 2-.9 2-2V8H3v10zM14 5h-3l-1-1H6L5 5H2v2h12z"/></svg>
        </button>
        <button class="btn" onclick="app.downloadSVG()" data-tooltip="Export SVG">
            <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
        </button>
    </div>
</div>

<div class="zoom-controls">
    <button class="zoom-btn" onclick="app.adjustZoom(0.1)">+</button>
    <button class="zoom-btn" onclick="app.resetView()" data-tooltip="Reset View">âŸ²</button>
    <button class="zoom-btn" onclick="app.adjustZoom(-0.1)">-</button>
</div>

<div class="stats" id="stats">
    Mode: Draw | Stars: 0 | Constellations: 0 | Zoom: 1.00x
</div>

<!-- Confirmation Modal -->
<div id="clearModal" class="modal-overlay">
    <div class="modal">
        <h2>Implode Universe?</h2>
        <p style="color: #888; margin-bottom: 20px;">This will remove all stars. This action cannot be undone easily.</p>
        <div class="modal-actions">
            <button class="btn-secondary" onclick="app.closeModal()">Cancel</button>
            <button class="btn-primary" onclick="app.confirmClear()">Implode</button>
        </div>
    </div>
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * Aether Map Engine v5.0 - Pre-Placement Color Model
 */
class AetherEngine {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d', { alpha: false });

        // Configuration
        this.config = {
            maxConnectDist: 180,
            starBaseRad: 3.5,
            minGroupSize: 3,
            bgColor: '#020205',
        };

        // State
        this.stars = [];
        this.camera = { x: 0, y: 0, zoom: 1, targetZoom: 1 };
        this.history = [];
        this.mode = 'draw'; // 'draw' or 'select'

        // NEW COLOR STATE
        this.activeColor = '#00f3ff';
        this.colorMode = 'fixed'; // 'fixed' or 'rainbow'

        // Interaction State
        this.pointer = { x: 0, y: 0, startX: 0, startY: 0, isDown: false, dragging: false, lastWorldX: 0, lastWorldY: 0 };
        this.hoveredStar = null;
        this.draggedStar = null;
        this.draggedClusterId = null; // Used only for dragging entire clusters

        // Generators
        this.initNameGenerators();
        
        // Performance
        this.backgroundStars = [];

        this.init();
    }

    initNameGenerators() {
        this.prefixes = ["Alpha", "Beta", "Gamma", "Delta", "Neo", "Proto", "Hyper", "Cyber", "Dark", "Lost", "Royal", "Azure", "Crimson", "Void", "Solar", "Lunar", "Emerald", "Obsidian"];
        this.roots = ["Orion", "Cygnus", "Draco", "Lyra", "Vela", "Hydra", "Cetus", "Lupus", "Pavo", "Volans", "Aries", "Leo", "Gemini", "Ursa", "Vortex", "Helix", "Prism", "Shard", "Echo", "Serpens", "Phoenix"];
        this.suffixes = ["Major", "Minor", "Prime", "Zero", "Cluster", "Nebula", "Expanse", "Quadrant", "Sector", "Knot", "Web", "Crown", "Trident", "Gate", "Symphony", "Paradox"];
    }

    init() {
        window.addEventListener('resize', () => this.resize());
        this.resize();

        // Pointer Events
        this.canvas.addEventListener('pointerdown', e => this.onPointerDown(e));
        window.addEventListener('pointermove', e => this.onPointerMove(e));
        window.addEventListener('pointerup', e => this.onPointerUp(e));
        this.canvas.addEventListener('wheel', e => this.onWheel(e), { passive: false });

        // Keyboard
        window.addEventListener('keydown', e => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') this.undo();
        });

        // Initial mode setup
        this.setMode('draw');
        // Initial color state setup
        this.updateColorModeUI();

        this.animate = this.animate.bind(this);
        requestAnimationFrame(this.animate);
    }

    /**
     * Resizes the canvas to fill its container and redraws the background.
     * The call to generateStaticBackground is here, so we must ensure the definition comes first.
     */
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        // This line now calls the function defined immediately below for guaranteed availability
        this.backgroundStars = this.generateStaticBackground();
        this.draw();
    }

    /**
     * FIX: Added the missing function to generate static background stars.
     * This method is now positioned explicitly before other methods that rely on it
     * (like resize) to ensure availability in sensitive execution environments.
     */
    generateStaticBackground() {
        const bgStars = [];
        const count = 300; // number of background stars
        for (let i = 0; i < count; i++) {
            bgStars.push({
                x: Math.random() * this.canvas.width,
                y: Math.random() * this.canvas.height,
                size: Math.random() * 0.5 + 0.1,
                alpha: Math.random() * 0.5 + 0.2
            });
        }
        return bgStars;
    }

    setMode(newMode) {
        this.mode = newMode;
        document.getElementById('drawModeBtn').classList.remove('active');
        document.getElementById('selectModeBtn').classList.remove('active');

        if (newMode === 'draw') {
            document.getElementById('drawModeBtn').classList.add('active');
            this.canvas.style.cursor = 'crosshair';
        } else if (newMode === 'select') {
            document.getElementById('selectModeBtn').classList.add('active');
            this.canvas.style.cursor = 'pointer';
        }
    }

    /* --- NEW COLOR CONTROLS --- */

    getRainbowHex() {
        return '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
    }

    setFixedColor(hexColor) {
        this.activeColor = hexColor;
        this.colorMode = 'fixed';
        this.updateColorModeUI();
        this.showToast(`Active color set to ${hexColor}`);
    }

    setRainbowMode() {
        this.colorMode = 'rainbow';
        this.updateColorModeUI();
        this.showToast("Active color set to Rainbow Mode ðŸŒˆ");
    }

    updateColorModeUI() {
        const fixedIndicator = document.getElementById('fixedModeIndicator');
        const rainbowBtn = document.getElementById('rainbowBtn');
        const colorText = document.getElementById('currentColorModeText');
        const colorInput = document.getElementById('colorInput');

        colorInput.value = this.activeColor; // Keep input updated

        if (this.colorMode === 'fixed') {
            fixedIndicator.classList.add('active');
            rainbowBtn.classList.remove('active');
            fixedIndicator.style.background = this.activeColor;
            colorText.innerText = `Color Mode: Fixed (${this.activeColor})`;
        } else {
            fixedIndicator.classList.remove('active');
            rainbowBtn.classList.add('active');
            colorText.innerText = "Color Mode: Rainbow (Random per star)";
        }
    }

    /* --- Input Handling --- */

    getWorldPos(e) {
        return {
            x: (e.clientX - this.canvas.width/2 - this.camera.x) / this.camera.zoom,
            y: (e.clientY - this.canvas.height/2 - this.camera.y) / this.camera.zoom
        };
    }

    onPointerDown(e) {
        this.pointer.isDown = true;
        this.pointer.startX = e.clientX;
        this.pointer.startY = e.clientY;
        this.pointer.camStartX = this.camera.x;
        this.pointer.camStartY = this.camera.y;

        const world = this.getWorldPos(e);
        const hitDist = (this.config.starBaseRad * 4) / this.camera.zoom;
        const starHit = this.stars.find(s => Math.hypot(s.x - world.x, s.y - world.y) < hitDist);

        // Refresh cluster assignments if we hit a star, in case we drag a group
        if (starHit) {
            this.refreshClusterAssignments();

            // In select mode, clicking a star initiates a cluster drag
            if (this.mode === 'select' && starHit.clusterId) {
                // Determine the cluster ID to drag (it's either the cluster name string or the star's ID string)
                this.draggedClusterId = String(starHit.clusterId);
                this.pointer.lastWorldX = world.x;
                this.pointer.lastWorldY = world.y;
                this.saveState();
                return;
            }

            // If not in select mode, allow single star drag
            if (this.mode === 'draw') {
                this.draggedStar = starHit;
                this.saveState();
            }
        }
    }

    onPointerMove(e) {
        const world = this.getWorldPos(e);

        // Hover Logic
        const hitDist = (this.config.starBaseRad * 4) / this.camera.zoom;
        this.hoveredStar = this.stars.find(s => Math.hypot(s.x - world.x, s.y - world.y) < hitDist);

        // Cursor Feedback
        let newCursor = 'default';
        if (this.draggedStar || this.draggedClusterId || this.pointer.dragging) {
            newCursor = 'grabbing';
        } else if (this.hoveredStar) {
            newCursor = 'move';
        } else if (this.mode === 'draw') {
            newCursor = 'crosshair';
        }
        this.canvas.style.cursor = newCursor;


        if (!this.pointer.isDown) return;

        const dx = e.clientX - this.pointer.startX;
        const dy = e.clientY - this.pointer.startY;
        const distMoved = Math.hypot(dx, dy);

        if (distMoved > 5) {
            this.pointer.dragging = true;
        }

        if (this.draggedClusterId) {
            // Calculate world delta since last move
            const deltaWorldX = world.x - this.pointer.lastWorldX;
            const deltaWorldY = world.y - this.pointer.lastWorldY;

            const draggedIdString = this.draggedClusterId;
            // Move all stars in the cluster
            this.stars.forEach(s => {
                // Use strict comparison on the clusterId string
                if (String(s.clusterId) === draggedIdString) {
                    s.x += deltaWorldX;
                    s.y += deltaWorldY;
                }
            });

            // Update last position
            this.pointer.lastWorldX = world.x;
            this.pointer.lastWorldY = world.y;

        } else if (this.draggedStar) {
            this.draggedStar.x = world.x;
            this.draggedStar.y = world.y;
        } else if (this.pointer.dragging) {
            // Pan View
            this.camera.x = this.pointer.camStartX + dx;
            this.camera.y = this.pointer.camStartY + dy;
        }
    }

    onPointerUp(e) {
        const world = this.getWorldPos(e);
        const hitDist = (this.config.starBaseRad * 4) / this.camera.zoom;
        const clickedStar = this.stars.find(s => Math.hypot(s.x - world.x, s.y - world.y) < hitDist);

        if (!this.pointer.dragging && !clickedStar) {
            // Empty Space Clicked - Create Star (ONLY in draw mode)
            if (this.mode === 'draw') {
                this.saveState();
                this.createStar(world.x, world.y);
            }
        }

        // Reset interaction state
        this.pointer.isDown = false;
        this.pointer.dragging = false;
        this.draggedStar = null;
        this.draggedClusterId = null;
    }

    onWheel(e) {
        e.preventDefault();
        const zoomSpeed = 0.0015;
        const newZoom = Math.max(0.1, Math.min(6, this.camera.zoom - e.deltaY * zoomSpeed));

        const worldPos = this.getWorldPos(e);
        this.camera.zoom = newZoom;

        this.camera.x = e.clientX - this.canvas.width/2 - worldPos.x * this.camera.zoom;
        this.camera.y = e.clientY - this.canvas.height/2 - worldPos.y * this.camera.zoom;
    }

    /* --- Star Creation --- */

    createStar(x, y) {
        let starColor = this.activeColor;
        if (this.colorMode === 'rainbow') {
            starColor = this.getRainbowHex();
        }

        this.stars.push({
            x, y,
            id: Math.floor(Date.now() + Math.random() * 1000).toString(),
            phase: Math.random() * Math.PI * 2,
            color: starColor,
            clusterId: null, // Will be calculated in refreshClusterAssignments()
        });
        this.draw();
    }

    /**
     * Re-calculates connections and assigns cluster names/IDs to all star objects.
     * Guarantees that s.clusterId is always a string (either the constellation name or the star's unique string ID).
     */
    refreshClusterAssignments() {
        const { lines, clusters } = this.calculateGeometry();

        // Map to hold assignments: { starId: clusterName/starId }
        const assignmentMap = new Map();

        // 1. Assign deterministic name (string) to all members of large clusters (>= minGroupSize)
        clusters.forEach(c => {
            if (c.length >= this.config.minGroupSize) {
                const name = this.getConstellationName(c);
                c.forEach(star => {
                    assignmentMap.set(star.id, name);
                });
            }
        });

        // 2. Apply assignments back to the main stars array
        this.stars.forEach(s => {
            // If a star is part of a large cluster, use the mapped string name. Otherwise, use its unique string ID (s.id).
            s.clusterId = assignmentMap.get(s.id) || s.id;
        });

        return { lines, clusters };
    }

    /* --- Utility Methods --- */

    getStarColor(s) {
        return s.color || '#e0faff'; // Fallback to default if somehow color is missing
    }

    hexToRgb(hex) {
        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
            parseInt(result[1], 16),
            parseInt(result[2], 16),
            parseInt(result[3], 16)
        ] : [224, 240, 255]; // Default blue/white
    }


    /* --- Core Logic (State Management) --- */

    saveState() {
        // Save a deep copy of the stars array before an action that changes it
        const newState = JSON.stringify(this.stars.map(s => ({
            x: s.x,
            y: s.y,
            id: String(s.id),
            phase: s.phase,
            color: s.color,
        })));
        if (this.history.length > 25) this.history.shift();
        this.history.push(newState);
    }

    undo() {
        if (this.history.length === 0) {
            this.showToast("Nothing to undo");
            return;
        }
        // Load the previous state
        this.history.pop();
        const prevState = this.history.pop();
        if (prevState) {
            this.stars = JSON.parse(prevState);
            this.history.push(prevState); // Put it back so the next undo works from this state
        } else {
            this.stars = []; // If history is now empty
        }

        this.draw();
        this.showToast("Undone");
    }

    requestClear() {
        document.getElementById('clearModal').classList.add('active');
    }

    closeModal() {
        document.getElementById('clearModal').classList.remove('active');
    }

    confirmClear() {
        this.saveState();
        this.stars = [];
        this.camera = { x: 0, y: 0, zoom: 1 };
        this.closeModal();
        this.draw();
        this.showToast("Universe Imploded");
    }

    resetView() {
        this.camera = { x: 0, y: 0, zoom: 1 };
    }

    adjustZoom(delta) {
        this.camera.zoom = Math.max(0.1, Math.min(6, this.camera.zoom + delta));
    }

    getConstellationName(group) {
        const sortedIds = group.map(s => String(s.id)).sort((a, b) => a.localeCompare(b));
        let seed = 0;
        sortedIds.forEach((id, i) => {
            for (let j = 0; j < id.length; j++) {
                seed += id.charCodeAt(j) * (j + 1) * (i + 1);
            }
        });
        seed = Math.floor(seed);

        const pre = this.prefixes[seed % this.prefixes.length];
        const root = this.roots[(seed * 13) % this.roots.length];
        const suf = this.suffixes[(seed * 7) % this.suffixes.length];

        const type = seed % 3;
        if (type === 0) return `${pre} ${root}`;
        if (type === 1) return `${root} ${suf}`;
        return `The ${pre} ${root} ${suf}`;
    }

    /* --- Rendering --- */

    animate(time) {
        this.draw(time);
        requestAnimationFrame(this.animate);
    }

    draw(time) {
        const { ctx, canvas } = this;

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillStyle = this.config.bgColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Static Background Stars
        const paraX = this.camera.x * 0.1;
        const paraY = this.camera.y * 0.1;
        
        ctx.fillStyle = "#ffffff";
        this.backgroundStars.forEach(s => {
            let sx = (s.x + paraX) % canvas.width;
            let sy = (s.y + paraY) % canvas.height;
            if (sx < 0) sx += canvas.width;
            if (sy < 0) sy += canvas.height;

            ctx.globalAlpha = s.alpha;
            ctx.beginPath();
            ctx.arc(sx, sy, s.size, 0, Math.PI*2);
            ctx.fill();
        });
        ctx.globalAlpha = 1.0;

        // World Transform
        ctx.translate(canvas.width/2 + this.camera.x, canvas.height/2 + this.camera.y);
        ctx.scale(this.camera.zoom, this.camera.zoom);

        // Calculations & Cluster ID Assignment
        const { lines, clusters } = this.refreshClusterAssignments();

        // 5. Draw Lines (Glow Pass + Core Pass)
        if (lines.length > 0) {
            ctx.lineCap = 'round';
            ctx.shadowBlur = 10;

            lines.forEach(l => {
                const alpha = Math.max(0, 1 - (l.dist / this.config.maxConnectDist));
                // Line color based on s1's star color
                const starColor = this.getStarColor(l.s1);
                const [r, g, b] = this.hexToRgb(starColor);

                ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.8)`;
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha * 0.3})`;
                ctx.lineWidth = 3 / this.camera.zoom;
                ctx.beginPath();
                ctx.moveTo(l.s1.x, l.s1.y);
                ctx.lineTo(l.s2.x, l.s2.y);
                ctx.stroke();
            });
            ctx.shadowBlur = 0;

            lines.forEach(l => {
                const alpha = Math.max(0, 1 - (l.dist / this.config.maxConnectDist));
                const starColor = this.getStarColor(l.s1);

                ctx.strokeStyle = starColor;
                ctx.globalAlpha = alpha * 0.8;
                ctx.lineWidth = 1 / this.camera.zoom;
                ctx.beginPath();
                ctx.moveTo(l.s1.x, l.s1.y);
                ctx.lineTo(l.s2.x, l.s2.y);
                ctx.stroke();
            });
            ctx.globalAlpha = 1.0;
        }

        // 6. Draw Text Labels
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = `600 ${14 / this.camera.zoom}px 'Exo 2'`;

        clusters.forEach(c => {
            // Only draw names for clusters that meet the minimum size threshold AND have a generated name
            const name = String(c[0].clusterId);
            if (c.length < this.config.minGroupSize || name === String(c[0].id)) return;

            // Centroid Calculation
            let cx = 0, cy = 0;
            c.forEach(s => { cx += s.x; cy += s.y; });
            cx /= c.length; cy /= c.length;
            
            const avgColor = this.getStarColor(c[0]);

            // Draw Text Label
            ctx.fillStyle = avgColor;
            ctx.shadowColor = "black";
            ctx.shadowBlur = 4;
            ctx.fillText(name, cx, cy + (30 / this.camera.zoom));
            ctx.shadowBlur = 0;
        });

        // 7. Draw Stars
        const timeNow = performance.now();
        this.stars.forEach(s => {
            const isHover = (s === this.hoveredStar);
            
            const twinkle = Math.sin(timeNow * 0.003 + s.phase) * 0.2 + 0.8;
            const scale = isHover ? 1.5 : 1.0;
            const radius = this.config.starBaseRad * twinkle * scale / this.camera.zoom;
            const starColor = this.getStarColor(s);
            const [r, g, b] = this.hexToRgb(starColor);

            // Draw Glow
            const glowRad = radius * 6;
            const grad = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, glowRad);
            grad.addColorStop(0, `rgba(255, 255, 255, ${isHover ? 0.9 : 0.6})`);
            grad.addColorStop(0.2, `rgba(${r}, ${g}, ${b}, 0.3)`);
            grad.addColorStop(1, "rgba(0,0,0,0)");

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(s.x, s.y, glowRad, 0, Math.PI * 2);
            ctx.fill();

            // Draw Core (Star Shape)
            ctx.fillStyle = starColor;
            this.drawStarShape(ctx, s.x, s.y, radius);
        });

        // Update HUD
        const statEl = document.getElementById('stats');
        const constellationCount = clusters.filter(c => c.length >= this.config.minGroupSize).length;
        if(statEl) statEl.innerText = `Mode: ${this.mode.charAt(0).toUpperCase() + this.mode.slice(1)} | Stars: ${this.stars.length} | Constellations: ${constellationCount} | Zoom: ${this.camera.zoom.toFixed(2)}x`;
    }

    drawStarShape(ctx, x, y, r) {
        ctx.beginPath();
        const pr = r * 0.5;
        ctx.moveTo(x, y - r);
        ctx.lineTo(x + pr, y - pr);
        ctx.lineTo(x + r, y);
        ctx.lineTo(x + pr, y + pr);
        ctx.lineTo(x, y + r);
        ctx.lineTo(x - pr, y + pr);
        ctx.lineTo(x - r, y);
        ctx.lineTo(x - pr, y - pr);
        ctx.closePath();
        ctx.fill();
    }

    calculateGeometry() {
        const lines = [];
        const adj = {};
        this.stars.forEach(s => adj[s.id] = []);

        for (let i = 0; i < this.stars.length; i++) {
            for (let j = i + 1; j < this.stars.length; j++) {
                const s1 = this.stars[i];
                const s2 = this.stars[j];
                const dist = Math.hypot(s1.x - s2.x, s1.y - s2.y);

                if (dist < this.config.maxConnectDist) {
                    lines.push({ s1, s2, dist });
                    adj[s1.id].push(s2.id);
                    adj[s2.id].push(s1.id);
                }
            }
        }

        // BFS for clusters
        const clusters = [];
        const visited = new Set();
        this.stars.forEach(star => {
            if (!visited.has(star.id)) {
                const cluster = [];
                const queue = [star.id];
                visited.add(star.id);
                while (queue.length) {
                    const id = queue.shift();
                    const s = this.stars.find(x => x.id === id);
                    if(s) cluster.push(s);
                    adj[id].forEach(nid => {
                        if (!visited.has(nid)) {
                            visited.add(nid);
                            queue.push(nid);
                        }
                    });
                }
                if (cluster.length > 0) clusters.push(cluster);
            }
        });

        return { lines, clusters };
    }

    showToast(msg) {
        const t = document.getElementById('toast');
        t.innerText = msg;
        t.classList.add('visible');
        setTimeout(() => t.classList.remove('visible'), 2000);
    }

    downloadSVG() {
        if (this.stars.length === 0) {
            this.showToast("Universe is empty!");
            return;
        }

        // Ensure cluster IDs are assigned for naming in SVG
        this.refreshClusterAssignments();

        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        this.stars.forEach(s => {
            minX = Math.min(minX, s.x); minY = Math.min(minY, s.y);
            maxX = Math.max(maxX, s.x); maxY = Math.max(maxY, s.y);
        });

        const pad = 100;
        const w = (maxX - minX) + pad*2;
        const h = (maxY - minY) + pad*2;
        const vbX = minX - pad;
        const vbY = minY - pad;

        const { lines, clusters } = this.calculateGeometry();

        let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vbX} ${vbY} ${w} ${h}" style="background:#020205">
            <rect x="${vbX}" y="${vbY}" width="${w}" height="${h}" fill="#020205"/>`;

        // Lines
        lines.forEach(l => {
            const op = (1 - (l.dist / this.config.maxConnectDist)).toFixed(2);
            const [r, g, b] = this.hexToRgb(this.getStarColor(l.s1));
            svg += `<line x1="${l.s1.x}" y1="${l.s1.y}" x2="${l.s2.x}" y2="${l.s2.y}" stroke="rgb(${r}, ${g}, ${b})" stroke-width="1.5" stroke-linecap="round" opacity="${op * 0.8}"/>`;
        });

        // Labels
        clusters.forEach(c => {
            const name = String(c[0].clusterId);
            if (c.length < this.config.minGroupSize || name === String(c[0].id)) return;
            
            let cx=0, cy=0; c.forEach(s=>{cx+=s.x; cy+=s.y}); cx/=c.length; cy/=c.length;
            const color = this.getStarColor(c[0]);
            svg += `<text x="${cx}" y="${cy+30}" font-family="sans-serif" font-size="14" fill="${color}" text-anchor="middle" font-weight="600">${name}</text>`;
        });

        // Stars
        this.stars.forEach(s => {
            const color = this.getStarColor(s);
            const r = this.config.starBaseRad * 1.5;

            // Star Shape
            const pr = r * 0.5;
            const pathData = `M${s.x} ${s.y-r} L${s.x+pr} ${s.y-pr} L${s.x+r} ${s.y} L${s.x+pr} ${s.y+pr} L${s.x} ${s.y+r} L${s.x-pr} ${s.y+pr} L${s.x-r} ${s.y} L${s.x-pr} ${s.y-pr} Z`;
            svg += `<path d="${pathData}" fill="${color}" opacity="0.8"/>`;
            
            // Core dot
            svg += `<circle cx="${s.x}" cy="${s.y}" r="1.5" fill="white" />`;
        });

        svg += `</svg>`;

        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `AetherMap-${Date.now()}.svg`;
        link.click();
        this.showToast("Map Exported");
    }
}

const app = new AetherEngine();
</script>
</body>
</html>
