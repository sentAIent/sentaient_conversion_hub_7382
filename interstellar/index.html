<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>INTERSTELLAR | Pre-Placement Cartographer</title>
    <meta property="og:title" content="INTERSTELLAR | Pre-Placement Cartographer">
    <meta property="og:description" content="Interactive star mapping and constellation design tool.">
    <meta property="og:image" content="/interstellar-thumb.png">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/interstellar-thumb.png">
    <link
        href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Exo+2:wght@300;600&family=Montserrat:wght@600;800&family=Orbitron:wght@500;700;900&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-deep: #020205;
            --glass: rgba(16, 20, 30, 0.65);
            --glass-border: rgba(100, 220, 255, 0.15);
            --accent: #00f3ff;
            --accent-glow: rgba(0, 243, 255, 0.4);
            --text-main: #e0faff;
            --text-dim: #94b0c0;
            /* Brightened from #5c7a8a */
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-deep);
            font-family: 'Exo 2', sans-serif;
            color: var(--text-main);
            user-select: none;
            -webkit-user-select: none;
        }

        /* --- Background Layer --- */
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            touch-action: none;
            /* Prevents scrolling on mobile while drawing */
        }

        /* --- Intro Overlay Removed (Moved to Canvas) --- */

        /* --- HUD UI --- */
        .hud {
            position: absolute;
            z-index: 10;
            padding: 16px;
            pointer-events: none;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: row;
            /* Horizontal layout */
            justify-content: space-between;
            align-items: flex-start;
            /* Align items to top */
        }

        .hud-panel {
            pointer-events: auto;
            background: var(--glass);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        /* Top Left Info */
        .info-panel {
            align-self: flex-start;
            padding: 20px 24px;
            max-width: 320px;
        }

        h1 {
            margin: 0;
            font-family: 'Orbitron', sans-serif;
            /* Tesla-like square font */
            font-weight: 900;
            font-size: 24px;
            text-transform: uppercase;
            color: var(--text-main);
            /* White/Bright instead of accent for Tesla look? Or keep accent? Keeping accent for now but font change is key */
            color: var(--accent);
            text-shadow: 0 0 15px var(--accent-glow);
            letter-spacing: 4px;
            /* Wide spacing characteristic of Tesla */
        }

        p.subtitle {
            margin: 8px 0 0;
            font-size: 13px;
            color: var(--text-dim);
            line-height: 1.5;
        }

        /* Top Right Color Controls (Active Star Color) */
        #colorControls {
            /* Positioned by flexbox now */
            align-self: flex-start;
            margin: 20px 20px 0 0;
            /* Add margin to match others */
            padding: 15px;
            max-width: 280px;
            display: flex;
            flex-direction: column;
        }

        #colorControls h2 {
            font-size: 16px;
            margin: 0 0 10px 0;
            color: var(--accent);
            text-shadow: none;
            text-transform: uppercase;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            align-items: center;
        }

        .color-input-container {
            position: relative;
            flex-shrink: 0;
        }

        #colorInput {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            border: 1px solid var(--glass-border);
            padding: 0;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            border-radius: 8px;
            overflow: hidden;
            flex-shrink: 0;
        }

        /* Customize the color swatch appearance within the native input */
        #colorInput::-webkit-color-swatch {
            border: 2px solid white;
            border-radius: 6px;
        }

        #colorInput::-moz-color-swatch {
            border: 2px solid white;
            border-radius: 6px;
        }

        /* General Small Button Styling */
        .btn-small {
            flex-grow: 1;
            padding: 10px 12px;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            color: var(--text-main);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn-small:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Active Color Mode Indicator */
        .color-mode-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent);
            border: 2px solid var(--bg-deep);
            box-shadow: 0 0 10px var(--accent);
            opacity: 0;
            transition: opacity 0.2s, background 0.2s;
        }

        .color-mode-indicator.active {
            opacity: 1;
        }

        #rainbowBtn.active {
            background: #ff0077;
            border-color: #ff0077;
            color: #fff;
            box-shadow: 0 0 15px #ff0077;
        }

        /* Toggle Switch */
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            color: var(--text-dim);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 34px;
            height: 20px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.1);
            transition: .4s;
            border-radius: 34px;
            border: 1px solid var(--glass-border);
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: var(--text-dim);
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: rgba(0, 243, 255, 0.2);
            border-color: var(--accent);
        }

        input:checked+.slider:before {
            transform: translateX(14px);
            background-color: var(--accent);
        }

        /* Top Center Tools */
        .toolbar {
            align-self: flex-start;
            margin-top: 20px;
            /* Align with other panels */
            display: flex;
            gap: 12px;
            padding: 10px;
            border-radius: 16px;
        }

        .btn {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid transparent;
            color: var(--text-main);
            width: 48px;
            height: 48px;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            position: relative;
        }

        .btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
            filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.5));
        }

        .btn:hover {
            background: rgba(0, 243, 255, 0.1);
            border-color: var(--accent-glow);
            transform: translateY(-2px);
            color: var(--accent);
            box-shadow: 0 0 15px var(--accent-glow);
        }

        .btn:active {
            transform: translateY(1px);
        }

        /* Active button style for selection mode */
        .btn.active {
            background: var(--accent);
            color: var(--bg-deep);
            border-color: var(--accent);
            box-shadow: 0 0 20px var(--accent);
            transform: none;
        }

        .btn.active:hover {
            background: var(--accent);
            color: var(--bg-deep);
        }

        .btn.active:hover {
            background: var(--accent);
            color: var(--bg-deep);
        }

        /* Danger Button (Implode) */
        .btn-danger {
            width: auto;
            /* Allow text */
            padding: 0 15px;
            gap: 8px;
            border-color: rgba(255, 0, 85, 0.5);
            color: #ff0055;
        }

        .btn-danger:hover {
            background: rgba(255, 0, 85, 0.1);
            border-color: #ff0055;
            color: #ff0055;
            box-shadow: 0 0 15px rgba(255, 0, 85, 0.4);
        }

        .btn-danger svg {
            fill: currentColor;
        }

        /* Tooltip */
        .btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 115%;
            left: 50%;
            transform: translateX(-50%);
            background: #000;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            border: 1px solid #333;
        }

        .btn:hover::after {
            opacity: 1;
        }

        /* Zoom Controls (Right) */
        .zoom-controls {
            position: absolute;
            right: 20px;
            bottom: 100px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: auto;
        }

        .zoom-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: var(--text-main);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: 0.2s;
        }

        .zoom-btn:hover {
            background: var(--accent);
            color: #000;
        }

        /* Stats */
        .stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 11px;
            font-family: monospace;
            color: var(--text-dim);
            pointer-events: none;
        }

        /* Modal & Toast (unchanged) */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal {
            background: #0f1219;
            border: 1px solid var(--accent);
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.15);
            max-width: 300px;
        }

        .modal h2 {
            margin-top: 0;
            color: #fff;
            font-family: 'Cinzel', serif;
        }

        .modal-actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .btn-primary {
            background: var(--accent);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        .btn-secondary {
            background: transparent;
            color: #aaa;
            border: 1px solid #333;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn-secondary:hover {
            border-color: #666;
            color: #fff;
        }

        .toast {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            background: rgba(0, 243, 255, 0.15);
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 8px 24px;
            border-radius: 30px;
            font-size: 12px;
            font-weight: 600;
            opacity: 0;
            transition: all 0.3s;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    </style>
</head>

<body>

    <canvas id="canvas"></canvas>

    <div id="toast" class="toast">Action Successful</div>

    <div class="hud">
        <div class="hud-panel info-panel">
            <h1>INTERSTELLAR</h1>
            <p class="subtitle">
                Click empty space to create stars (Draw Mode).<br>
                Stars use the active color/mode selected below.<br>
                Select tool allows for cluster drag and panning.
            </p>
        </div>

        <div class="hud-panel toolbar">
            <button class="btn" id="drawModeBtn" onclick="app.setMode('draw')" data-tooltip="Draw Mode (Create Stars)">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z" />
                </svg>
            </button>
            <button class="btn" id="selectModeBtn" onclick="app.setMode('select')"
                data-tooltip="Drag Star/Cluster Mode">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M7 19h10V4H7v15zm-2-2V6c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2v11c0 1.1-.9 2-2 2H7c-1.1 0-2-.9-2-2zM4 21c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-2H4v2z" />
                </svg>
            </button>
            <div style="width: 12px; border-left: 1px solid rgba(255,255,255,0.1);"></div>
            <button class="btn" onclick="app.undo()" data-tooltip="Undo (Ctrl+Z)">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z" />
                </svg>
            </button>
            <button class="btn btn-danger" onclick="app.requestClear()" data-tooltip="Implode Universe">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M15 16h4v2h-4zm0-8h7v2h-7zm0 4h6v2h-6zM3 18c0 1.1.9 2 2 2h6c1.1 0 2-.9 2-2V8H3v10zM14 5h-3l-1-1H6L5 5H2v2h12z" />
                </svg>
                <span style="font-weight: 700; font-size: 12px; letter-spacing: 1px;">IMPLODE</span>
            </button>
            <button class="btn" onclick="app.downloadSVG()" data-tooltip="Export SVG">
                <svg viewBox="0 0 24 24">
                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z" />
                </svg>
            </button>
            <div style="width: 12px; border-left: 1px solid rgba(255,255,255,0.1);"></div>
            <button class="btn" onclick="app.saveUniverse()" data-tooltip="Save Project">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z" />
                </svg>
            </button>
            <button class="btn" onclick="document.getElementById('loadInput').click()" data-tooltip="Load Project">
                <svg viewBox="0 0 24 24">
                    <path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z" />
                </svg>
            </button>
            <input type="file" id="loadInput" style="display:none" onchange="app.loadUniverse(this)">
        </div>

        <div id="colorControls" class="hud-panel">
            <h2>New Star Color</h2>

            <div class="btn-group">
                <div class="color-input-container">
                    <input type="color" id="colorInput" value="#00f3ff" oninput="app.setFixedColor(this.value)">
                </div>
                <button id="fixedModeBtn" class="btn-small"
                    onclick="app.setFixedColor(document.getElementById('colorInput').value)">
                    Fixed
                    <div id="fixedModeIndicator" class="color-mode-indicator active"></div>
                </button>
                <button id="rainbowBtn" class="btn-small" onclick="app.setRainbowMode()">
                    Rainbow
                </button>
            </div>

            <div class="toggle-container">
                <span>Deep Space BG</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="bgToggle" checked onchange="app.toggleBackground(this.checked)">
                    <span class="slider"></span>
                </label>
            </div>
            <p style="font-size: 10px; margin-top: 15px; color: var(--text-dim);">
                <span id="currentColorModeText">Color Mode: Fixed (#00f3ff)</span>
            </p>
        </div>
    </div>

    <div class="zoom-controls">
        <button class="zoom-btn" onclick="app.adjustZoom(0.1)">+</button>
        <button class="zoom-btn" onclick="app.resetView()" data-tooltip="Reset View">‚ü≤</button>
        <button class="zoom-btn" onclick="app.adjustZoom(-0.1)">-</button>
    </div>

    <div class="stats" id="stats">
        Mode: Draw | Stars: 0 | Constellations: 0 | Zoom: 1.00x
    </div>

    <!-- Confirmation Modal -->
    <div id="clearModal" class="modal-overlay">
        <div class="modal">
            <h2>Implode Universe?</h2>
            <p style="color: #888; margin-bottom: 20px;">This will remove all stars. This action cannot be undone
                easily.</p>
            <div class="modal-actions">
                <button class="btn-secondary" onclick="app.closeModal()">Cancel</button>
                <button class="btn-primary" onclick="app.confirmClear()">Implode</button>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        /**
         * Spatial Partitioning for O(N) queries
         */
        class SpatialGrid {
            constructor(cellSize) {
                this.cellSize = cellSize;
                this.cells = new Map();
            }

            clear() {
                this.cells.clear();
            }

            getKey(x, y) {
                const cx = Math.floor(x / this.cellSize);
                const cy = Math.floor(y / this.cellSize);
                return `${cx},${cy}`;
            }

            add(item) {
                const key = this.getKey(item.x, item.y);
                if (!this.cells.has(key)) this.cells.set(key, []);
                this.cells.get(key).push(item);
            }

            // Get items in the same cell and 8 neighbors
            getNearby(x, y) {
                const cx = Math.floor(x / this.cellSize);
                const cy = Math.floor(y / this.cellSize);
                const results = [];

                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const key = `${cx + dx},${cy + dy}`;
                        if (this.cells.has(key)) {
                            const cellItems = this.cells.get(key);
                            for (let i = 0; i < cellItems.length; i++) {
                                results.push(cellItems[i]);
                            }
                        }
                    }
                }
                return results;
            }
        }

        /**
         * Command Pattern for Granular Undo
         */
        class CommandManager {
            constructor(engine) {
                this.engine = engine;
                this.stack = [];
            }

            execute(command) {
                command.execute(this.engine);
                this.stack.push(command);
                this.engine.showToast(command.successMessage || "Action Executed");
            }

            undo() {
                if (this.stack.length === 0) {
                    this.engine.showToast("Nothing to undo");
                    return;
                }
                const command = this.stack.pop();
                command.undo(this.engine);
                this.engine.showToast("Undone: " + (command.name || "Action"));
                this.engine.draw();
            }
        }

        class AddStarCommand {
            constructor(star) {
                this.star = star;
                this.name = "Create Star";
                this.successMessage = "Star Created";
            }
            execute(engine) {
                engine.stars.push(this.star);
            }
            undo(engine) {
                const idx = engine.stars.findIndex(s => s.id === this.star.id);
                if (idx !== -1) engine.stars.splice(idx, 1);
            }
        }

        class MoveStarsCommand {
            constructor(stars, dx, dy) {
                this.ids = stars.map(s => s.id);
                this.dx = dx;
                this.dy = dy;
                this.name = "Move Stars";
                this.successMessage = "";
            }
            execute(engine) {
                // Already moved by pointer, this is just for recording the delta
                // If we were strictly following pattern, we'd move them here, but for drag we record after
            }
            undo(engine) {
                engine.stars.forEach(s => {
                    if (this.ids.includes(s.id)) {
                        s.x -= this.dx;
                        s.y -= this.dy;
                    }
                });
            }
        }

        class ClearUniverseCommand {
            constructor(stars) {
                this.savedStars = [...stars]; // Shallow copy of array, refs are fine if we don't mutate props
                this.name = "Implode Universe";
                this.successMessage = "Universe Imploded";
            }
            execute(engine) {
                engine.stars = [];
            }
            undo(engine) {
                engine.stars = [...this.savedStars];
            }
        }

        /**
         * Aether Map Engine v6.0 - Optimized & Granular Undo
         */
        class AetherEngine {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });

                // Configuration
                this.config = {
                    maxConnectDist: 180,
                    starBaseRad: 3.5,
                    minGroupSize: 3,
                    bgColor: '#020205',
                    showBackground: true,
                };

                // State
                this.stars = [];
                this.camera = { x: 0, y: 0, zoom: 1, targetZoom: 1 };

                this.mode = 'draw'; // 'draw' or 'select'

                // Background Entities
                this.galaxies = [];
                this.blackHoles = [];
                this.shootingStars = [];
                this.backgroundStars = [];
                this.nebulae = [];

                // Interaction State
                this.pointer = { x: 0, y: 0, startX: 0, startY: 0, isDown: false, dragging: false, lastWorldX: 0, lastWorldY: 0 };
                this.hoveredStar = null;
                this.draggedStar = null;
                this.draggedClusterId = null; // Used only for dragging entire clusters
                this.dragStartStars = []; // Store initial positions for undo
                this.selection = new Set();
                this.lastPoint = null;

                // Color State
                this.activeColor = '#00f3ff'; // Default cyan
                this.colorMode = 'fixed'; // 'fixed', 'rainbow'

                // Intro State
                this.introActive = true;
                this.introStartTime = Date.now();
                this.introDuration = 6000; // 6 seconds

                // Spatial Grid
                this.grid = new SpatialGrid(this.config.maxConnectDist);

                // Command Manager (Undo System)
                this.commands = new CommandManager(this); // Pass 'this' to CommandManager

                // Setup
                this.canvas = document.getElementById('canvas'); // Changed from 'starCanvas' to 'canvas'
                this.ctx = this.canvas.getContext('2d', { alpha: false }); // Added alpha: false for performance
                this.resize();

                // Generators
                this.initNameGenerators();

                // Listeners
                this.init();
            }

            initNameGenerators() {
                this.prefixes = ["Alpha", "Beta", "Gamma", "Delta", "Neo", "Proto", "Hyper", "Cyber", "Dark", "Lost", "Royal", "Azure", "Crimson", "Void", "Solar", "Lunar", "Emerald", "Obsidian"];
                this.roots = ["Orion", "Cygnus", "Draco", "Lyra", "Vela", "Hydra", "Cetus", "Lupus", "Pavo", "Volans", "Aries", "Leo", "Gemini", "Ursa", "Vortex", "Helix", "Prism", "Shard", "Echo", "Serpens", "Phoenix"];
                this.suffixes = ["Major", "Minor", "Prime", "Zero", "Cluster", "Nebula", "Expanse", "Quadrant", "Sector", "Knot", "Web", "Crown", "Trident", "Gate", "Symphony", "Paradox"];
            }

            init() {
                window.addEventListener('resize', () => this.resize());
                this.resize();

                // Pointer Events
                this.canvas.addEventListener('pointerdown', e => this.onPointerDown(e));
                window.addEventListener('pointermove', e => this.onPointerMove(e));
                window.addEventListener('pointerup', e => this.onPointerUp(e));
                this.canvas.addEventListener('wheel', e => this.onWheel(e), { passive: false });

                // Keyboard
                window.addEventListener('keydown', e => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z') this.commands.undo(); // Changed from this.undo()
                });

                // Initial mode setup
                this.setMode('draw');
                // Initial color state setup
                this.updateColorModeUI();

                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);
            }

            /**
             * Resizes the canvas to fill its container and redraws the background.
             * The call to generateStaticBackground is here, so we must ensure the definition comes first.
             */
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.generateDeepSpace();
                this.draw();
            }

            generateDeepSpace() {
                // 1. Background Stars (Faint, static)
                this.backgroundStars = [];
                const count = 400;
                for (let i = 0; i < count; i++) {
                    this.backgroundStars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        r: Math.random() * 0.8 + 0.1,
                        alpha: Math.random() * 0.3 + 0.05 // Fainter
                    });
                }

                // 2. Galaxies (Spiral clusters)
                this.galaxies = [];
                const galaxyCount = 3;
                for (let i = 0; i < galaxyCount; i++) {
                    this.galaxies.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        color: ['#ff0055', '#5500ff', '#00aaff'][Math.floor(Math.random() * 3)],
                        angle: Math.random() * Math.PI * 2,
                        size: 50 + Math.random() * 100
                    });
                }

                // 3. Black Holes
                this.blackHoles = [];
                const bhCount = 1; // Rare
                for (let i = 0; i < bhCount; i++) {
                    this.blackHoles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: 20 + Math.random() * 20
                    });
                }

                // 4. Nebulae (Large colorful clouds)
                this.nebulae = [];
                const nebulaCount = 5;
                for (let i = 0; i < nebulaCount; i++) {
                    this.nebulae.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: 300 + Math.random() * 400,
                        color: ['#4400cc', '#0033aa', '#cc0066', '#330033'][Math.floor(Math.random() * 4)],
                        alpha: 0.05 + Math.random() * 0.15 // Fainter
                    });
                }
            }

            setMode(newMode) {
                this.mode = newMode;
                document.getElementById('drawModeBtn').classList.remove('active');
                document.getElementById('selectModeBtn').classList.remove('active');

                if (newMode === 'draw') {
                    document.getElementById('drawModeBtn').classList.add('active');
                    this.canvas.style.cursor = 'crosshair';
                } else if (newMode === 'select') {
                    document.getElementById('selectModeBtn').classList.add('active');
                    this.canvas.style.cursor = 'pointer';
                }
            }

            /* --- NEW COLOR CONTROLS --- */

            getRainbowHex() {
                return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
            }

            setFixedColor(hexColor) {
                this.activeColor = hexColor;
                this.colorMode = 'fixed';
                this.updateColorModeUI();
                this.showToast(`Active color set to ${hexColor}`);
            }

            setRainbowMode() {
                this.colorMode = 'rainbow';
                this.updateColorModeUI();
                this.showToast("Active color set to Rainbow Mode üåà");
            }

            updateColorModeUI() {
                const fixedIndicator = document.getElementById('fixedModeIndicator');
                const rainbowBtn = document.getElementById('rainbowBtn');
                const colorText = document.getElementById('currentColorModeText');
                const colorInput = document.getElementById('colorInput');

                colorInput.value = this.activeColor; // Keep input updated

                if (this.colorMode === 'fixed') {
                    fixedIndicator.classList.add('active');
                    rainbowBtn.classList.remove('active');
                    fixedIndicator.style.background = this.activeColor;
                    colorText.innerText = `Color Mode: Fixed (${this.activeColor})`;
                } else {
                    fixedIndicator.classList.remove('active');
                    rainbowBtn.classList.add('active');
                    colorText.innerText = "Color Mode: Rainbow (Random per star)";
                }
            }

            /* --- Input Handling --- */

            getWorldPos(e) {
                return {
                    x: (e.clientX - this.canvas.width / 2 - this.camera.x) / this.camera.zoom,
                    y: (e.clientY - this.canvas.height / 2 - this.camera.y) / this.camera.zoom
                };
            }

            onPointerDown(e) {
                this.pointer.isDown = true;
                this.pointer.startX = e.clientX;
                this.pointer.startY = e.clientY;
                this.pointer.camStartX = this.camera.x;
                this.pointer.camStartY = this.camera.y;

                const world = this.getWorldPos(e);
                const hitDist = (this.config.starBaseRad * 4) / this.camera.zoom;
                const starHit = this.stars.find(s => Math.hypot(s.x - world.x, s.y - world.y) < hitDist);

                // Refresh cluster assignments if we hit a star, in case we drag a group
                if (starHit) {
                    this.refreshClusterAssignments();

                    // In select mode, clicking a star initiates a cluster drag
                    if (this.mode === 'select' && starHit.clusterId) {
                        // Determine the cluster ID to drag (it's either the cluster name string or the star's ID string)
                        this.draggedClusterId = String(starHit.clusterId);
                        this.pointer.lastWorldX = world.x;
                        this.pointer.lastWorldY = world.y;

                        // Capture stars for Undo
                        this.dragStartStars = this.stars.filter(s => String(s.clusterId) === this.draggedClusterId);
                        return;
                    }

                    // If not in select mode, allow single star drag
                    if (this.mode === 'draw') {
                        this.draggedStar = starHit;
                        this.dragStartStars = [starHit];
                    }
                }
            }

            onPointerMove(e) {
                const world = this.getWorldPos(e);

                // Hover Logic
                const hitDist = (this.config.starBaseRad * 4) / this.camera.zoom;
                this.hoveredStar = this.stars.find(s => Math.hypot(s.x - world.x, s.y - world.y) < hitDist);

                // Cursor Feedback
                let newCursor = 'default';
                if (this.draggedStar || this.draggedClusterId || this.pointer.dragging) {
                    newCursor = 'grabbing';
                } else if (this.hoveredStar) {
                    newCursor = 'move';
                } else if (this.mode === 'draw') {
                    newCursor = 'crosshair';
                }
                this.canvas.style.cursor = newCursor;


                if (!this.pointer.isDown) return;

                const dx = e.clientX - this.pointer.startX;
                const dy = e.clientY - this.pointer.startY;
                const distMoved = Math.hypot(dx, dy);

                if (distMoved > 5) {
                    this.pointer.dragging = true;
                }

                if (this.draggedClusterId) {
                    // Calculate world delta since last move
                    const deltaWorldX = world.x - this.pointer.lastWorldX;
                    const deltaWorldY = world.y - this.pointer.lastWorldY;

                    const draggedIdString = this.draggedClusterId;
                    // Move all stars in the cluster
                    this.stars.forEach(s => {
                        // Use strict comparison on the clusterId string
                        if (String(s.clusterId) === draggedIdString) {
                            s.x += deltaWorldX;
                            s.y += deltaWorldY;
                        }
                    });

                    // Update last position
                    this.pointer.lastWorldX = world.x;
                    this.pointer.lastWorldY = world.y;

                } else if (this.draggedStar) {
                    this.draggedStar.x = world.x;
                    this.draggedStar.y = world.y;
                } else if (this.pointer.dragging) {
                    // Pan View
                    this.camera.x = this.pointer.camStartX + dx;
                    this.camera.y = this.pointer.camStartY + dy;
                }
            }

            onPointerUp(e) {
                const world = this.getWorldPos(e);
                const hitDist = (this.config.starBaseRad * 4) / this.camera.zoom;
                const clickedStar = this.stars.find(s => Math.hypot(s.x - world.x, s.y - world.y) < hitDist);

                if (!this.pointer.dragging && !clickedStar) {
                    // Empty Space Clicked - Create Star (ONLY in draw mode)
                    if (this.mode === 'draw') {
                        this.createStar(world.x, world.y);
                    }
                } else if (this.pointer.dragging && this.dragStartStars.length > 0) {
                    // Drag finished - Record Command
                    // Calculate delta based on the first star in the group vs its start pos
                    // (Simpler: just calculate delta from pointer start to end, but we have world coords)

                    // We need the total delta applied.
                    // Let's assume the drag was valid.
                    // We can compare current pos of first star with its snapshot pos.

                    const currentS = this.stars.find(s => s.id === this.dragStartStars[0].id);
                    if (currentS) {
                        const snapshotS = this.dragStartStars[0];
                        const dx = currentS.x - snapshotS.x;
                        const dy = currentS.y - snapshotS.y;

                        if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                            this.commands.execute(new MoveStarsCommand(this.dragStartStars, dx, dy));
                        }
                    }
                }

                // Reset interaction state
                this.pointer.isDown = false;
                this.pointer.dragging = false;
                this.draggedStar = null;
                this.draggedClusterId = null;
                this.dragStartStars = [];
            }

            onWheel(e) {
                e.preventDefault();
                const zoomSpeed = 0.0015;
                const newZoom = Math.max(0.1, Math.min(6, this.camera.zoom - e.deltaY * zoomSpeed));

                const worldPos = this.getWorldPos(e);
                this.camera.zoom = newZoom;

                this.camera.x = e.clientX - this.canvas.width / 2 - worldPos.x * this.camera.zoom;
                this.camera.y = e.clientY - this.canvas.height / 2 - worldPos.y * this.camera.zoom;
            }

            /* --- Star Creation --- */

            createStar(x, y) {
                if (this.introActive) this.introActive = false;

                let starColor = this.activeColor;
                if (this.colorMode === 'rainbow') {
                    starColor = this.getRainbowHex();
                }

                const newStar = {
                    x, y,
                    id: Math.floor(Date.now() + Math.random() * 1000).toString(),
                    phase: Math.random() * Math.PI * 2,
                    color: starColor,
                    clusterId: null, // Will be calculated in refreshClusterAssignments()
                };

                this.commands.execute(new AddStarCommand(newStar));
                this.draw();
            }

            /**
             * Re-calculates connections and assigns cluster names/IDs to all star objects.
             * Guarantees that s.clusterId is always a string (either the constellation name or the star's unique string ID).
             */
            refreshClusterAssignments() {
                const { lines, clusters } = this.calculateGeometry();

                // Map to hold assignments: { starId: clusterName/starId }
                const assignmentMap = new Map();

                // 1. Assign deterministic name (string) to all members of large clusters (>= minGroupSize)
                clusters.forEach(c => {
                    if (c.length >= this.config.minGroupSize) {
                        const name = this.getConstellationName(c);
                        c.forEach(star => {
                            assignmentMap.set(star.id, name);
                        });
                    }
                });

                // 2. Apply assignments back to the main stars array
                this.stars.forEach(s => {
                    // If a star is part of a large cluster, use the mapped string name. Otherwise, use its unique string ID (s.id).
                    s.clusterId = assignmentMap.get(s.id) || s.id;
                });

                return { lines, clusters };
            }

            /* --- Utility Methods --- */

            getStarColor(s) {
                return s.color || '#e0faff'; // Fallback to default if somehow color is missing
            }

            hexToRgb(hex) {
                const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [
                    parseInt(result[1], 16),
                    parseInt(result[2], 16),
                    parseInt(result[3], 16)
                ] : [224, 240, 255]; // Default blue/white
            }


            /* --- Core Logic (State Management) --- */

            // saveState removed - using Command Pattern

            undo() {
                this.commands.undo();
            }

            requestClear() {
                document.getElementById('clearModal').classList.add('active');
            }

            closeModal() {
                document.getElementById('clearModal').classList.remove('active');
            }

            confirmClear() {
                this.commands.execute(new ClearUniverseCommand(this.stars));
                this.camera = { x: 0, y: 0, zoom: 1 };
                this.closeModal();
                this.draw();
            }

            resetView() {
                this.camera = { x: 0, y: 0, zoom: 1 };
            }

            adjustZoom(delta) {
                this.camera.zoom = Math.max(0.1, Math.min(6, this.camera.zoom + delta));
            }

            getConstellationName(group) {
                const sortedIds = group.map(s => String(s.id)).sort((a, b) => a.localeCompare(b));
                let seed = 0;
                sortedIds.forEach((id, i) => {
                    for (let j = 0; j < id.length; j++) {
                        seed += id.charCodeAt(j) * (j + 1) * (i + 1);
                    }
                });
                seed = Math.floor(seed);

                const pre = this.prefixes[seed % this.prefixes.length];
                const root = this.roots[(seed * 13) % this.roots.length];
                const suf = this.suffixes[(seed * 7) % this.suffixes.length];

                const type = seed % 3;
                if (type === 0) return `${pre} ${root}`;
                if (type === 1) return `${root} ${suf}`;
                return `The ${pre} ${root} ${suf}`;
            }

            /* --- Rendering --- */

            animate(time) {
                this.draw(time);
                requestAnimationFrame(this.animate);
            }

            draw(time) {
                const { ctx, canvas } = this;

                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.fillStyle = this.config.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Static Background Stars
                const paraX = this.camera.x * 0.1;
                const paraY = this.camera.y * 0.1;

                ctx.fillStyle = "#ffffff";
                this.backgroundStars.forEach(s => {
                    let sx = (s.x + paraX) % canvas.width;
                    let sy = (s.y + paraY) % canvas.height;
                    if (sx < 0) sx += canvas.width;
                    if (sy < 0) sy += canvas.height;

                    ctx.globalAlpha = s.alpha;
                    ctx.beginPath();
                    ctx.arc(sx, sy, s.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1.0;

                // World Transform
                ctx.translate(canvas.width / 2 + this.camera.x, canvas.height / 2 + this.camera.y);
                ctx.scale(this.camera.zoom, this.camera.zoom);

                // Calculations & Cluster ID Assignment
                const { lines, clusters } = this.refreshClusterAssignments();

                // 0. Draw Deep Space Background
                this.drawDeepSpace();

                // 1. Draw Grid Lines (Glow Pass + Core Pass)
                if (lines.length > 0) {
                    ctx.lineCap = 'round';
                    ctx.shadowBlur = 10;

                    lines.forEach(l => {
                        const alpha = Math.max(0, 1 - (l.dist / this.config.maxConnectDist));
                        // Line color based on s1's star color
                        const starColor = this.getStarColor(l.s1);
                        const [r, g, b] = this.hexToRgb(starColor);

                        ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.8)`;
                        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha * 0.3})`;
                        ctx.lineWidth = 3 / this.camera.zoom;
                        ctx.beginPath();
                        ctx.moveTo(l.s1.x, l.s1.y);
                        ctx.lineTo(l.s2.x, l.s2.y);
                        ctx.stroke();
                    });
                    ctx.shadowBlur = 0;

                    lines.forEach(l => {
                        const alpha = Math.max(0, 1 - (l.dist / this.config.maxConnectDist));
                        const starColor = this.getStarColor(l.s1);

                        ctx.strokeStyle = starColor;
                        ctx.globalAlpha = alpha * 0.8;
                        ctx.lineWidth = 1 / this.camera.zoom;
                        ctx.beginPath();
                        ctx.moveTo(l.s1.x, l.s1.y);
                        ctx.lineTo(l.s2.x, l.s2.y);
                        ctx.stroke();
                    });
                    ctx.globalAlpha = 1.0;
                }

                // 6. Draw Text Labels
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.font = `600 ${14 / this.camera.zoom}px 'Exo 2'`;

                clusters.forEach(c => {
                    // Only draw names for clusters that meet the minimum size threshold AND have a generated name
                    const name = String(c[0].clusterId);
                    if (c.length < this.config.minGroupSize || name === String(c[0].id)) return;

                    // Centroid Calculation
                    let cx = 0, cy = 0;
                    c.forEach(s => { cx += s.x; cy += s.y; });
                    cx /= c.length; cy /= c.length;

                    const avgColor = this.getStarColor(c[0]);

                    // Draw Text Label
                    ctx.fillStyle = avgColor;
                    ctx.shadowColor = "black";
                    ctx.shadowBlur = 4;
                    ctx.fillText(name, cx, cy + (30 / this.camera.zoom));
                    ctx.shadowBlur = 0;
                });

                // 7. Draw Stars
                const timeNow = performance.now();
                this.stars.forEach(s => {
                    const isHover = (s === this.hoveredStar);

                    const twinkle = Math.sin(timeNow * 0.003 + s.phase) * 0.2 + 0.8;
                    const scale = isHover ? 1.5 : 1.0;
                    const radius = this.config.starBaseRad * twinkle * scale / this.camera.zoom;
                    const starColor = this.getStarColor(s);
                    const [r, g, b] = this.hexToRgb(starColor);

                    // Draw Glow
                    const glowRad = radius * 6;
                    const grad = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, glowRad);
                    grad.addColorStop(0, `rgba(255, 255, 255, ${isHover ? 0.9 : 0.6})`);
                    grad.addColorStop(0.2, `rgba(${r}, ${g}, ${b}, 0.3)`);
                    grad.addColorStop(1, "rgba(0,0,0,0)");

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, glowRad, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw Core (Star Shape)
                    ctx.fillStyle = starColor;
                    this.drawStarShape(ctx, s.x, s.y, radius);
                });

                // Update HUD
                const statEl = document.getElementById('stats');
                const constellationCount = clusters.filter(c => c.length >= this.config.minGroupSize).length;
                if (statEl) statEl.innerText = `Mode: ${this.mode.charAt(0).toUpperCase() + this.mode.slice(1)} | Stars: ${this.stars.length} | Constellations: ${constellationCount} | Zoom: ${this.camera.zoom.toFixed(2)}x`;

                this.drawIntro();
            }

            drawIntro() {
                if (!this.introActive) return;

                const now = Date.now();
                const elapsed = now - this.introStartTime;
                const progress = Math.min(elapsed / this.introDuration, 1);

                if (progress >= 1) {
                    this.introActive = false;
                    return;
                }

                // Animation: Zoom Out (Scale 2.5 -> 0)
                // Opacity: 0 -> 1 (at 15%) -> 1 (at 85%) -> 0 (at 100%)

                let scale = 2.5 - (2.5 * progress); // Linear zoom out to 0
                let opacity = 0;

                if (progress < 0.15) {
                    opacity = progress / 0.15;
                } else if (progress < 0.85) {
                    opacity = 1;
                } else {
                    opacity = 1 - ((progress - 0.85) / 0.15);
                }

                const ctx = this.ctx;
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform for full screen overlay

                // Dim background slightly
                ctx.fillStyle = `rgba(0, 0, 0, ${opacity > 0 ? 0.8 : 0})`;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                ctx.scale(scale, scale);

                ctx.font = '900 60px "Orbitron", sans-serif';
                ctx.fillStyle = `rgba(0, 243, 255, ${opacity})`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = `rgba(0, 243, 255, ${opacity * 0.5})`;
                ctx.shadowBlur = 20;
                ctx.fillText("UNLEASH YOUR CREATIVITY IN 4D", 0, 0);

                ctx.restore();
            }

            toggleBackground(enabled) {
                this.config.showBackground = enabled;
                this.draw();
            }

            drawDeepSpace() {
                if (!this.config.showBackground) return;

                const ctx = this.ctx;
                const time = performance.now() * 0.0005;

                // 1. Static Stars (Parallax could be added here if we tracked camera better, but static is fine for depth)
                ctx.fillStyle = "white";
                this.backgroundStars.forEach(s => {
                    ctx.globalAlpha = s.alpha;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                // 1.5 Nebulae
                ctx.globalCompositeOperation = 'screen'; // Blend nicely
                this.nebulae.forEach(n => {
                    const grad = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.size);
                    grad.addColorStop(0, n.color);
                    grad.addColorStop(1, 'transparent');

                    ctx.globalAlpha = n.alpha;
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, n.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalCompositeOperation = 'source-over'; // Reset
                ctx.globalAlpha = 1;

                // 2. Galaxies
                this.galaxies.forEach(g => {
                    ctx.save();
                    ctx.translate(g.x, g.y);
                    ctx.rotate(g.angle + time * 0.1);

                    // Simple spiral effect
                    const spiralGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, g.size);
                    spiralGradient.addColorStop(0, 'rgba(255,255,255,0.8)');
                    spiralGradient.addColorStop(0.2, g.color);
                    spiralGradient.addColorStop(1, 'transparent');

                    ctx.fillStyle = spiralGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, g.size, 0, Math.PI * 2);
                    ctx.fill();

                    // Add some spiral arms (particles)
                    ctx.fillStyle = g.color;
                    for (let j = 0; j < 4; j++) {
                        ctx.rotate(Math.PI / 2);
                        for (let k = 0; k < 10; k++) {
                            const dist = (k / 10) * g.size;
                            const size = (1 - k / 10) * 3;
                            ctx.globalAlpha = 0.5;
                            ctx.beginPath();
                            ctx.arc(dist, Math.sin(dist * 0.1 - time) * 10, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    ctx.restore();
                });

                // 3. Black Holes
                this.blackHoles.forEach(bh => {
                    ctx.save();
                    ctx.translate(bh.x, bh.y);

                    // Accretion Disk
                    const diskGrad = ctx.createRadialGradient(0, 0, bh.size * 0.5, 0, 0, bh.size * 2);
                    diskGrad.addColorStop(0, 'black');
                    diskGrad.addColorStop(0.4, 'rgba(255, 100, 50, 0.8)'); // Orange/Red glow
                    diskGrad.addColorStop(1, 'transparent');

                    ctx.fillStyle = diskGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, bh.size * 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Event Horizon
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(0, 0, bh.size * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                    ctx.stroke();

                    ctx.restore();
                });

                // 4. Shooting Stars
                // Spawn logic
                if (Math.random() < 0.02) { // 2% chance per frame
                    this.shootingStars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 1.0
                    });
                }

                // Update & Draw Shooting Stars
                for (let i = this.shootingStars.length - 1; i >= 0; i--) {
                    const s = this.shootingStars[i];
                    s.x += s.vx;
                    s.y += s.vy;
                    s.life -= 0.02;

                    if (s.life <= 0) {
                        this.shootingStars.splice(i, 1);
                        continue;
                    }

                    ctx.strokeStyle = `rgba(255, 255, 255, ${s.life})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y);
                    ctx.lineTo(s.x - s.vx * 3, s.y - s.vy * 3); // Trail
                    ctx.stroke();
                }

                ctx.globalAlpha = 1;
            }

            drawStarShape(ctx, x, y, r) {
                ctx.beginPath();
                const pr = r * 0.5;
                ctx.moveTo(x, y - r);
                ctx.lineTo(x + pr, y - pr);
                ctx.lineTo(x + r, y);
                ctx.lineTo(x + pr, y + pr);
                ctx.lineTo(x, y + r);
                ctx.lineTo(x - pr, y + pr);
                ctx.lineTo(x - r, y);
                ctx.lineTo(x - pr, y - pr);
                ctx.closePath();
                ctx.fill();
            }

            calculateGeometry() {
                const lines = [];
                const adj = {};
                this.stars.forEach(s => adj[s.id] = []);

                // 1. Populate Grid
                this.grid.clear();
                this.stars.forEach(s => this.grid.add(s));

                // 2. Query Grid for Connections
                // We only need to check each pair once. 
                // To avoid duplicates (A-B and B-A), we can check id string comparison or just add both and filter later?
                // Optimization: For each star, get neighbors. Only connect if neighbor.id > star.id (canonical order)

                this.stars.forEach(s1 => {
                    const neighbors = this.grid.getNearby(s1.x, s1.y);
                    neighbors.forEach(s2 => {
                        if (s1.id >= s2.id) return; // Unique pairs only

                        const dist = Math.hypot(s1.x - s2.x, s1.y - s2.y);
                        if (dist < this.config.maxConnectDist) {
                            lines.push({ s1, s2, dist });
                            adj[s1.id].push(s2.id);
                            adj[s2.id].push(s1.id);
                        }
                    });
                });

                // BFS for clusters (unchanged logic, just runs on the adjacency list built above)
                const clusters = [];
                const visited = new Set();
                this.stars.forEach(star => {
                    if (!visited.has(star.id)) {
                        const cluster = [];
                        const queue = [star.id];
                        visited.add(star.id);
                        while (queue.length) {
                            const id = queue.shift();
                            const s = this.stars.find(x => x.id === id);
                            if (s) cluster.push(s);
                            adj[id].forEach(nid => {
                                if (!visited.has(nid)) {
                                    visited.add(nid);
                                    queue.push(nid);
                                }
                            });
                        }
                        if (cluster.length > 0) clusters.push(cluster);
                    }
                });

                return { lines, clusters };
            }

            showToast(msg) {
                const t = document.getElementById('toast');
                t.innerText = msg;
                t.classList.add('visible');
                setTimeout(() => t.classList.remove('visible'), 2000);
            }

            /* --- Utility Methods --- */

            saveUniverse() {
                if (this.stars.length === 0) {
                    this.showToast("Nothing to save!");
                    return;
                }
                const data = JSON.stringify(this.stars);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `interstellar_universe_${Date.now()}.json`;
                link.click();
                this.showToast("Project Saved");
            }

            loadUniverse(input) {
                const file = input.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        let stars;
                        const content = e.target.result;

                        if (file.name.endsWith('.svg') || file.type === 'image/svg+xml') {
                            // Extract JSON from <desc id="aether-state">
                            const match = content.match(/<desc id="aether-state">([\s\S]*?)<\/desc>/);
                            if (match && match[1]) {
                                try {
                                    // Try Base64 decode first (new format)
                                    stars = JSON.parse(atob(match[1]));
                                } catch (e) {
                                    // Fallback for plain text (if any exist from previous step)
                                    stars = JSON.parse(match[1]);
                                }
                            } else {
                                throw new Error("Legacy SVG: No save data found. Please export a new SVG.");
                            }
                        } else {
                            // Assume JSON
                            stars = JSON.parse(content);
                        }

                        if (Array.isArray(stars)) {
                            this.stars = stars;
                            this.commands.stack = []; // Clear undo history on load
                            this.refreshClusterAssignments();
                            this.draw();
                            this.showToast("Project Loaded");
                        } else {
                            throw new Error("Invalid format");
                        }
                    } catch (err) {
                        const msg = err.message.includes("Legacy") ? err.message : "Error: Invalid Project File";
                        this.showToast(msg);
                        console.error(err);
                    }
                };
                reader.readAsText(file);
                input.value = ''; // Reset input
            }

            downloadSVG() {
                if (this.stars.length === 0) {
                    this.showToast("Universe is empty!");
                    return;
                }

                // Ensure cluster IDs are assigned for naming in SVG
                this.refreshClusterAssignments();

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                this.stars.forEach(s => {
                    minX = Math.min(minX, s.x); minY = Math.min(minY, s.y);
                    maxX = Math.max(maxX, s.x); maxY = Math.max(maxY, s.y);
                });

                const pad = 100;
                const w = (maxX - minX) + pad * 2;
                const h = (maxY - minY) + pad * 2;
                const vbX = minX - pad;
                const vbY = minY - pad;

                const { lines, clusters } = this.calculateGeometry();

                // Serialize state for embedding (Base64 encoded to be safe in XML)
                const stateJson = JSON.stringify(this.stars);
                const stateB64 = btoa(stateJson);

                let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vbX} ${vbY} ${w} ${h}" style="background:#020205">
            <desc id="aether-state">${stateB64}</desc>
            <rect x="${vbX}" y="${vbY}" width="${w}" height="${h}" fill="#020205"/>`;

                // Lines
                lines.forEach(l => {
                    const op = (1 - (l.dist / this.config.maxConnectDist)).toFixed(2);
                    const [r, g, b] = this.hexToRgb(this.getStarColor(l.s1));
                    svg += `<line x1="${l.s1.x}" y1="${l.s1.y}" x2="${l.s2.x}" y2="${l.s2.y}" stroke="rgb(${r}, ${g}, ${b})" stroke-width="1.5" stroke-linecap="round" opacity="${op * 0.8}"/>`;
                });

                // Labels
                clusters.forEach(c => {
                    const name = String(c[0].clusterId);
                    if (c.length < this.config.minGroupSize || name === String(c[0].id)) return;

                    let cx = 0, cy = 0; c.forEach(s => { cx += s.x; cy += s.y }); cx /= c.length; cy /= c.length;
                    const color = this.getStarColor(c[0]);
                    svg += `<text x="${cx}" y="${cy + 30}" font-family="sans-serif" font-size="14" fill="${color}" text-anchor="middle" font-weight="600">${name}</text>`;
                });

                // Stars
                this.stars.forEach(s => {
                    const color = this.getStarColor(s);
                    const r = this.config.starBaseRad * 1.5;

                    // Star Shape
                    const pr = r * 0.5;
                    const pathData = `M${s.x} ${s.y - r} L${s.x + pr} ${s.y - pr} L${s.x + r} ${s.y} L${s.x + pr} ${s.y + pr} L${s.x} ${s.y + r} L${s.x - pr} ${s.y + pr} L${s.x - r} ${s.y} L${s.x - pr} ${s.y - pr} Z`;
                    svg += `<path d="${pathData}" fill="${color}" opacity="0.8"/>`;

                    // Core dot
                    svg += `<circle cx="${s.x}" cy="${s.y}" r="1.5" fill="white" />`;
                });

                svg += `</svg>`;

                const blob = new Blob([svg], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `AetherMap-${Date.now()}.svg`;
                link.click();
                this.showToast("Map Exported");
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            console.log("DOM ready, initializing app...");
            const app = new AetherEngine();
            window.app = app;
        });
    </script>
</body>

</html>
```