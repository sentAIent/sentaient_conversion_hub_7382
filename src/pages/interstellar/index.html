<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aether Map | Pre-Placement Cartographer</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Exo+2:wght@300;600&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-deep: #020205;
            --glass: rgba(16, 20, 30, 0.65);
            --glass-border: rgba(100, 220, 255, 0.15);
            --accent: #00f3ff;
            --accent-glow: rgba(0, 243, 255, 0.4);
            --text-main: #e0faff;
            --text-dim: #5c7a8a;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-deep);
            font-family: 'Exo 2', sans-serif;
            color: var(--text-main);
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            touch-action: none;
            /* Prevents scrolling on mobile while drawing */
        }

        /* --- HUD UI --- */
        .hud {
            position: absolute;
            z-index: 10;
            padding: 16px;
            pointer-events: none;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-panel {
            pointer-events: auto;
            background: var(--glass);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        /* Top Left Info */
        .info-panel {
            align-self: flex-start;
            padding: 20px 24px;
            max-width: 320px;
        }

        h1 {
            margin: 0;
            font-family: 'Cinzel', serif;
            font-size: 22px;
            color: var(--accent);
            text-shadow: 0 0 15px var(--accent-glow);
            letter-spacing: 2px;
        }

        p.subtitle {
            margin: 8px 0 0;
            font-size: 13px;
            color: var(--text-dim);
            line-height: 1.5;
        }

        /* Left Side Color Controls (below info panel) */
        #colorControls {
            position: absolute;
            top: 190px;
            left: 20px;
            align-self: flex-start;
            padding: 15px;
            max-width: 280px;
            display: flex;
            flex-direction: column;
        }

        #colorControls h2 {
            font-size: 16px;
            margin: 0 0 10px 0;
            color: var(--accent);
            text-shadow: none;
            text-transform: uppercase;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            align-items: center;
        }

        .color-input-container {
            position: relative;
            flex-shrink: 0;
        }

        #colorInput {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            border: 1px solid var(--glass-border);
            padding: 0;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            border-radius: 8px;
            overflow: hidden;
            flex-shrink: 0;
        }

        /* Customize the color swatch appearance within the native input */
        #colorInput::-webkit-color-swatch {
            border: 2px solid white;
            border-radius: 6px;
        }

        #colorInput::-moz-color-swatch {
            border: 2px solid white;
            border-radius: 6px;
        }

        /* General Small Button Styling */
        .btn-small {
            flex-grow: 1;
            padding: 10px 12px;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            color: var(--text-main);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn-small:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Active Color Mode Indicator */
        .color-mode-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent);
            border: 2px solid var(--bg-deep);
            box-shadow: 0 0 10px var(--accent);
            opacity: 0;
            transition: opacity 0.2s, background 0.2s;
        }

        .color-mode-indicator.active {
            opacity: 1;
        }

        #rainbowBtn.active {
            background: #ff0077;
            border-color: #ff0077;
            color: #fff;
            box-shadow: 0 0 15px #ff0077;
        }

        /* Active Background Toggle Styling */
        .bg-toggle.active {
            background: var(--accent);
            color: var(--bg-deep);
            border-color: var(--accent);
            box-shadow: 0 0 10px var(--accent-glow);
        }

        /* Bottom Left Tools */
        .toolbar {
            align-self: flex-start;
            margin-bottom: 20px;
            margin-left: 20px;
            display: flex;
            gap: 12px;
            padding: 10px;
            border-radius: 16px;
        }

        .btn {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid transparent;
            color: var(--text-main);
            width: 48px;
            height: 48px;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            position: relative;
        }

        .btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
            filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.5));
        }

        .btn:hover {
            background: rgba(0, 243, 255, 0.1);
            border-color: var(--accent-glow);
            transform: translateY(-2px);
            color: var(--accent);
            box-shadow: 0 0 15px var(--accent-glow);
        }

        .btn:active {
            transform: translateY(1px);
        }

        /* Active button style for selection mode */
        .btn.active {
            background: var(--accent);
            color: var(--bg-deep);
            border-color: var(--accent);
            box-shadow: 0 0 20px var(--accent);
            transform: none;
        }

        .btn.active:hover {
            background: var(--accent);
            color: var(--bg-deep);
        }


        /* Tooltip */
        .btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 115%;
            left: 50%;
            transform: translateX(-50%);
            background: #000;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            border: 1px solid #333;
        }

        .btn:hover::after {
            opacity: 1;
        }

        /* Zoom Controls (Left) */
        .zoom-controls {
            position: absolute;
            left: 20px;
            bottom: 100px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: auto;
        }

        .zoom-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: var(--text-main);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: 0.2s;
        }

        .zoom-btn:hover {
            background: var(--accent);
            color: #000;
        }

        /* Stats */
        .stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 11px;
            font-family: monospace;
            color: var(--text-dim);
            pointer-events: none;
        }

        /* Modal & Toast (unchanged) */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal {
            background: #0f1219;
            border: 1px solid var(--accent);
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.15);
            max-width: 300px;
        }

        .modal h2 {
            margin-top: 0;
            color: #fff;
            font-family: 'Cinzel', serif;
        }

        .modal-actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .btn-primary {
            background: var(--accent);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        .btn-secondary {
            background: transparent;
            color: #aaa;
            border: 1px solid #333;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn-secondary:hover {
            border-color: #666;
            color: #fff;
        }

        .toast {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            background: rgba(0, 243, 255, 0.15);
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 8px 24px;
            border-radius: 30px;
            font-size: 12px;
            font-weight: 600;
            opacity: 0;
            transition: all 0.3s;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Responsive Controls */
        @media (max-width: 768px) {
            .hud-panel.info-panel {
                top: 10px;
                left: 10px;
                max-width: 180px;
            }

            .hud-panel.toolbar {
                width: 95%;
                padding: 4px;
                gap: 4px;
                flex-wrap: wrap;
                justify-content: center;
                bottom: 10px;
            }

            #rotationControls {
                top: auto;
                bottom: 80px;
                right: 10px;
                max-width: 180px;
            }

            #bgControls {
                display: none;
                /* Hide background controls on mobile if needed, or collapse */
            }
        }

        @media (max-width: 480px) {
            .hud-panel h1 {
                font-size: 16px;
            }

            .btn {
                padding: 6px;
            }

            .btn svg {
                width: 18px;
                height: 18px;
            }
        }
    </style>
</head>

<body>

    <div id="toast" class="toast">Action Successful</div>

    <div class="hud">
        <div class="hud-panel info-panel">
            <h1>Interstellar Spacetime</h1>
            <p class="subtitle">
                Click empty space to create stars (Draw Mode).<br>
                Stars use the active color or random rainbow mode.<br>
                Select tool allows for cluster drag and panning.
            </p>
        </div>

        <div id="colorControls" class="hud-panel">
            <h2>New Star Color</h2>

            <div class="btn-group">
                <!-- Color input sets the fixed color mode -->
                <div class="color-input-container">
                    <input type="color" id="colorInput" value="#00f3ff" onchange="app.setFixedColor(this.value)">
                    <div id="fixedModeIndicator" class="color-mode-indicator active"></div>
                </div>

                <button class="btn-small" id="rainbowBtn" onclick="app.setRainbowMode()">
                    <span style="font-size: 16px;">ðŸŒˆ</span> Rainbow Mode
                </button>
            </div>
            <p style="font-size: 10px; margin-top: 15px; color: var(--text-dim);">
                <span id="currentColorModeText">Color Mode: Fixed (#00f3ff)</span>
            </p>
        </div>

        <div id="bgControls" class="hud-panel"
            style="top: 330px; left: 20px; position: absolute; padding: 15px; max-width: 280px;">
            <h2 style="font-size: 16px; margin: 0 0 10px 0; color: var(--accent); text-transform: uppercase;">Background
                Style</h2>
            <div style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px;">
                <button class="btn-small bg-toggle active" data-style="deep-space"
                    onclick="app.toggleBgStyle('deep-space')">Deep Space</button>
                <button class="btn-small bg-toggle" data-style="nebula"
                    onclick="app.toggleBgStyle('nebula')">Nebula</button>
                <button class="btn-small bg-toggle" data-style="alien"
                    onclick="app.toggleBgStyle('alien')">Alien</button>
                <button class="btn-small bg-toggle" data-style="cyber"
                    onclick="app.toggleBgStyle('cyber')">Matrix</button>
            </div>

            <div id="matrixThemeDisplay"
                style="font-size: 11px; color: var(--accent); margin-bottom: 8px; min-height: 15px;"></div>

            <!-- Matrix Speed Control (visible when Matrix is active) -->
            <div id="matrixSpeedControl" style="display: none; margin-bottom: 10px;">
                <label
                    style="font-size: 11px; color: var(--text); display: flex; justify-content: space-between; align-items: center;">
                    <span>Matrix Speed:</span>
                    <span id="matrixSpeedValue" style="color: var(--accent);">1.0x</span>
                </label>
                <input type="range" id="matrixSpeedSlider" min="0.1" max="8" step="0.1" value="1"
                    style="width: 100%; margin-top: 4px; accent-color: var(--accent);">

                <label
                    style="font-size: 11px; color: var(--text); display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                    <span>Code Length:</span>
                    <span id="matrixLengthValue" style="color: var(--accent);">1.0x</span>
                </label>
                <input type="range" id="matrixLengthSlider" min="0.2" max="3" step="0.1" value="1"
                    style="width: 100%; margin-top: 4px; accent-color: var(--accent);">

                <label
                    style="font-size: 11px; color: var(--text); display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                    <span>Matrix Color:</span>
                </label>
                <div style="display: flex; gap: 8px; align-items: center; margin-top: 4px;">
                    <input type="color" id="matrixColorPicker" value="#00ff00"
                        style="width: 40px; height: 28px; border: none; background: transparent; cursor: pointer;">
                    <input type="text" id="matrixColorHex" value="#00ff00" maxlength="7"
                        style="flex: 1; padding: 4px 8px; background: rgba(0,0,0,0.4); border: 1px solid var(--glass-border); border-radius: 4px; color: var(--accent); font-family: monospace; font-size: 12px;">
                </div>
            </div>

            <button class="btn-small" onclick="app.generateBackground()" style="width: 100%;">
                Regenerate Background
            </button>
        </div>

        <!-- 3D Rotation Controls -->
        <div id="rotationControls" class="hud-panel"
            style="position: absolute; top: 330px; right: 20px; padding: 15px; max-width: 200px;">
            <h2 style="font-size: 14px; margin: 0 0 10px 0; color: var(--accent); text-transform: uppercase;">3D
                Rotation</h2>

            <label
                style="font-size: 11px; color: var(--text); display: flex; justify-content: space-between; align-items: center;">
                <span>X Axis:</span>
                <span id="rotXValue" style="color: var(--accent);">0Â°</span>
            </label>
            <input type="range" id="rotXSlider" min="-180" max="180" step="1" value="0"
                style="width: 100%; margin-top: 4px; accent-color: var(--accent);">

            <label
                style="font-size: 11px; color: var(--text); display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                <span>Y Axis:</span>
                <span id="rotYValue" style="color: var(--accent);">0Â°</span>
            </label>
            <input type="range" id="rotYSlider" min="-180" max="180" step="1" value="0"
                style="width: 100%; margin-top: 4px; accent-color: var(--accent);">

            <label
                style="font-size: 11px; color: var(--text); display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                <span>Z Axis:</span>
                <span id="rotZValue" style="color: var(--accent);">0Â°</span>
            </label>
            <input type="range" id="rotZSlider" min="-180" max="180" step="1" value="0"
                style="width: 100%; margin-top: 4px; accent-color: var(--accent);">

            <button class="btn-small" onclick="app.resetRotation()" style="width: 100%; margin-top: 10px;">
                Reset Rotation
            </button>
        </div>

        <div class="hud-panel toolbar">
            <button class="btn" id="drawModeBtn" onclick="app.setMode('draw')" data-tooltip="Draw Mode (Create Stars)">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z" />
                </svg>
            </button>
            <button class="btn" id="selectModeBtn" onclick="app.setMode('select')"
                data-tooltip="Drag Star/Cluster Mode">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M7 19h10V4H7v15zm-2-2V6c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2v11c0 1.1-.9 2-2 2H7c-1.1 0-2-.9-2-2zM4 21c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-2H4v2z" />
                </svg>
            </button>
            <div style="width: 12px; border-left: 1px solid rgba(255,255,255,0.1);"></div>
            <button class="btn" onclick="app.undo()" data-tooltip="Undo (Ctrl+Z)">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z" />
                </svg>
            </button>
            <button class="btn" onclick="app.requestClear()" data-tooltip="Clear Universe">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M15 16h4v2h-4zm0-8h7v2h-7zm0 4h6v2h-6zM3 18c0 1.1.9 2 2 2h6c1.1 0 2-.9 2-2V8H3v10zM14 5h-3l-1-1H6L5 5H2v2h12z" />
                </svg>
            </button>
            <button class="btn" onclick="app.downloadSVG()" data-tooltip="Export SVG">
                <svg viewBox="0 0 24 24">
                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z" />
                </svg>
            </button>
            <button class="btn" onclick="app.triggerLoadSVG()" data-tooltip="Load SVG">
                <svg viewBox="0 0 24 24">
                    <path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z" />
                </svg>
            </button>
            <div style="display: flex; align-items: center; margin-right: 5px;">
                <select id="videoDuration"
                    style="background: rgba(0,0,0,0.5); border: 1px solid var(--glass-border); color: var(--accent); border-radius: 4px; padding: 2px; font-size: 11px; height: 32px; width: 45px; cursor: pointer;">
                    <option value="5000">5s</option>
                    <option value="10000">10s</option>
                </select>
            </div>
            <button class="btn" id="exportVideoBtn" onclick="app.exportVideo()" data-tooltip="Export Video">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z" />
                </svg>
            </button>
            <div style="width: 12px; border-left: 1px solid rgba(255,255,255,0.1);"></div>
            <button class="btn"
                onclick="document.getElementById('templatePanel').style.display = document.getElementById('templatePanel').style.display === 'none' ? 'block' : 'none'"
                data-tooltip="Templates">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H5v-4h9v4zm5 0h-4v-4h4v4zm0-5H5V5h14v7z" />
                </svg>
            </button>
        </div>

        <!-- Template Selection Panel -->
        <div id="templatePanel" class="hud-panel"
            style="position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); width: 400px; max-height: 400px; display: none; overflow-y: auto; z-index: 100;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h2 style="font-size: 14px; margin: 0; color: var(--accent); text-transform: uppercase;">
                    Constellation Templates</h2>
                <button class="btn-small" onclick="document.getElementById('templatePanel').style.display='none'"
                    style="min-width: 24px; padding: 2px 6px;">âœ•</button>
            </div>

            <div
                style="margin-bottom: 10px; display: flex; align-items: center; gap: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--glass-border);">
                <label
                    style="font-size: 12px; color: var(--text); display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="templateRainbowMode"
                        style="margin-right: 5px; accent-color: var(--accent);">
                    Rainbow Mode
                </label>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <span style="font-size: 12px; color: var(--text);">Color:</span>
                    <input type="color" id="templateColorPicker" value="#00ffff"
                        style="border: none; width: 24px; height: 24px; cursor: pointer; background: none;">
                </div>
            </div>
            <div style="margin-bottom: 10px;">
                <h3
                    style="font-size: 12px; color: var(--text-dim); margin: 5px 0; border-bottom: 1px solid var(--glass-border);">
                    Zodiac Signs</h3>
                <div id="zodiacTemplates" style="display: flex; flex-wrap: wrap; gap: 5px;"></div>
            </div>

            <div style="margin-bottom: 10px;">
                <h3
                    style="font-size: 12px; color: var(--text-dim); margin: 5px 0; border-bottom: 1px solid var(--glass-border);">
                    Animals</h3>
                <div id="animalTemplates" style="display: flex; flex-wrap: wrap; gap: 5px;"></div>
            </div>

            <div>
                <h3
                    style="font-size: 12px; color: var(--text-dim); margin: 5px 0; border-bottom: 1px solid var(--glass-border);">
                    Mythology</h3>
                <div id="mythTemplates" style="display: flex; flex-wrap: wrap; gap: 5px;"></div>
            </div>
        </div>
    </div>

    <!-- Hidden file input for loading SVG -->
    <input type="file" id="svgFileInput" accept=".svg" style="display: none;" onchange="app.loadSVG(event)">

    <div class="zoom-controls">
        <button class="zoom-btn" onclick="app.adjustZoom(0.1)">+</button>
        <button class="zoom-btn" onclick="app.resetView()" data-tooltip="Reset View">âŸ²</button>
        <button class="zoom-btn" onclick="app.adjustZoom(-0.1)">-</button>
    </div>

    <div class="stats" id="stats">
        Mode: Draw | Stars: 0 | Constellations: 0 | Zoom: 1.00x
    </div>

    <!-- Confirmation Modal -->
    <div id="clearModal" class="modal-overlay">
        <div class="modal">
            <h2>Implode Universe?</h2>
            <p style="color: #888; margin-bottom: 20px;">This will remove all stars. This action cannot be undone
                easily.</p>
            <div class="modal-actions">
                <button class="btn-secondary" onclick="app.closeModal()">Cancel</button>
                <button class="btn-primary" onclick="app.confirmClear()"
                    style="background-color: #ff3333; border-color: #cc0000; color: white;">Implode</button>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        /**
         * Aether Map Engine v5.0 - Pre-Placement Color Model
         */
        class AetherEngine {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });

                // Configuration
                this.config = {
                    maxConnectDist: 180,
                    starBaseRad: 3.5,
                    minGroupSize: 3,
                    bgColor: '#020205',
                    showBackground: true,
                };

                // World size for background generation
                this.worldSize = 8000;

                // State
                this.stars = [];
                this.camera = { x: 0, y: 0, zoom: 1, targetZoom: 1 };
                this.history = [];
                this.mode = 'draw'; // 'draw' or 'select'

                // NEW COLOR STATE
                this.activeColor = '#00f3ff';
                this.colorMode = 'fixed'; // 'fixed' or 'rainbow'
                this.activeStyles = new Set(['deep-space']); // Support multiple styles
                this.matrixSpeedMultiplier = 1.0; // User-adjustable cyber speed
                this.matrixLengthMultiplier = 1.0; // User-adjustable cyber stream length
                this.matrixColor = '#00ff00'; // User-adjustable matrix stream color

                // 3D Rotation State (degrees)
                this.rotationX = 0;
                this.rotationY = 0;
                this.rotationZ = 0;

                // Interaction State
                this.pointer = { x: 0, y: 0, startX: 0, startY: 0, isDown: false, dragging: false, lastWorldX: 0, lastWorldY: 0 };
                this.hoveredStar = null;
                this.draggedStar = null;
                this.draggedClusterId = null; // Used only for dragging entire clusters

                // Generators
                this.initNameGenerators();
                this.initTemplates();

                // Performance
                this.backgroundStars = [];

                this.init();
            }

            async initTemplates() {
                try {
                    const [zodiac, animals, mythology] = await Promise.all([
                        fetch('./templates/zodiac.json').then(r => r.json()),
                        fetch('./templates/animals.json').then(r => r.json()),
                        fetch('./templates/mythology.json').then(r => r.json())
                    ]);

                    this.templates = { zodiac, animals, mythology };

                    // Render Buttons
                    const createBtn = (category, key, containerId) => {
                        const btn = document.createElement('button');
                        btn.className = 'btn-small';
                        btn.style.margin = '2px';
                        btn.style.textTransform = 'capitalize';
                        btn.innerText = key;
                        btn.onclick = () => this.loadTemplate(category, key);
                        document.getElementById(containerId).appendChild(btn);
                    };

                    if (this.templates.zodiac) Object.keys(this.templates.zodiac).forEach(k => createBtn('zodiac', k, 'zodiacTemplates'));
                    if (this.templates.animals) Object.keys(this.templates.animals).forEach(k => createBtn('animals', k, 'animalTemplates'));
                    if (this.templates.mythology) Object.keys(this.templates.mythology).forEach(k => createBtn('mythology', k, 'mythTemplates'));

                } catch (e) {
                    console.error('Failed to load templates:', e);
                    this.showToast('Error loading templates');
                }
            }

            loadTemplate(category, key) {
                const points = this.templates[category][key];
                if (!points) return;

                // Clear existing
                this.stars = [];
                this.history = [];

                // Calculate center of viewport
                const cx = this.camera.x + this.canvas.width / 2 / this.camera.zoom;
                const cy = this.camera.y + this.canvas.height / 2 / this.camera.zoom;
                const scale = 3; // Scale up the normalized coordinates

                // Check Rainbow Mode and Color Picker
                const isRainbow = document.getElementById('templateRainbowMode')?.checked;
                const templateColor = document.getElementById('templateColorPicker')?.value || '#00ffff';

                // Create stars with 3D Depth
                const newStars = points.map((p, i) => {
                    let zDepth = 0;

                    if (p.length >= 3) {
                        // Explicit Z from template data
                        zDepth = p[2] * scale;
                    } else {
                        // Implicit 3D: Map 2D constellations onto a gentle celestial curve
                        // Calculate distance from center of constellation (0,0 in definition)
                        const dist = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
                        // Curve edges away from viewer (negative Z) to simulate looking into a dome
                        zDepth = -(dist * dist) * 0.05 * scale;
                    }

                    return {
                        id: Date.now() + i,
                        x: cx + p[0] * scale,
                        y: cy + p[1] * scale,
                        z: zDepth,
                        color: isRainbow ? this.getRainbowHex() : templateColor,
                        phase: Math.random() * Math.PI * 2,
                        clusterId: key.charAt(0).toUpperCase() + key.slice(1)
                    };
                });

                this.stars = newStars;

                // Close panel
                document.getElementById('templatePanel').style.display = 'none';
                this.showToast(`Loaded ${key} template`);
                this.draw();
            }

            initNameGenerators() {
                this.prefixes = ["Alpha", "Beta", "Gamma", "Delta", "Neo", "Proto", "Hyper", "Cyber", "Dark", "Lost", "Royal", "Azure", "Crimson", "Void", "Solar", "Lunar", "Emerald", "Obsidian"];
                this.roots = ["Orion", "Cygnus", "Draco", "Lyra", "Vela", "Hydra", "Cetus", "Lupus", "Pavo", "Volans", "Aries", "Leo", "Gemini", "Ursa", "Vortex", "Helix", "Prism", "Shard", "Echo", "Serpens", "Phoenix"];
                this.suffixes = ["Major", "Minor", "Prime", "Zero", "Cluster", "Nebula", "Expanse", "Quadrant", "Sector", "Knot", "Web", "Crown", "Trident", "Gate", "Symphony", "Paradox"];
            }

            init() {
                window.addEventListener('resize', () => this.resize());

                // Pointer Events
                this.canvas.addEventListener('pointerdown', e => this.onPointerDown(e));
                window.addEventListener('pointermove', e => this.onPointerMove(e));
                window.addEventListener('pointerup', e => this.onPointerUp(e));
                this.canvas.addEventListener('wheel', e => this.onWheel(e), { passive: false });

                // Keyboard
                window.addEventListener('keydown', e => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z') this.undo();
                });

                // Initial mode setup
                this.setMode('draw');
                // Initial color state setup
                this.updateColorModeUI();

                // Cyber speed slider
                this.matrixColorCustomized = false;

                // Matrix (previously Cyber) speed slider
                const matrixSpeedSlider = document.getElementById('matrixSpeedSlider');
                if (matrixSpeedSlider) {
                    matrixSpeedSlider.addEventListener('input', (e) => {
                        this.matrixSpeedMultiplier = parseFloat(e.target.value);
                        document.getElementById('matrixSpeedValue').textContent = this.matrixSpeedMultiplier.toFixed(1) + 'x';
                    });
                }

                // Matrix length slider
                const matrixLengthSlider = document.getElementById('matrixLengthSlider');
                if (matrixLengthSlider) {
                    matrixLengthSlider.addEventListener('input', (e) => {
                        this.matrixLengthMultiplier = parseFloat(e.target.value);
                        document.getElementById('matrixLengthValue').textContent = this.matrixLengthMultiplier.toFixed(1) + 'x';
                    });
                }

                // Matrix color picker
                const matrixColorPicker = document.getElementById('matrixColorPicker');
                const matrixColorHex = document.getElementById('matrixColorHex');
                if (matrixColorPicker) {
                    matrixColorPicker.addEventListener('input', (e) => {
                        this.matrixColor = e.target.value;
                        this.matrixColorCustomized = true;
                        if (matrixColorHex) matrixColorHex.value = e.target.value;
                        if (this.matrixStreams) this.matrixStreams.forEach(s => s.color = this.matrixColor);
                    });
                }
                if (matrixColorHex) {
                    matrixColorHex.addEventListener('input', (e) => {
                        let val = e.target.value;
                        if (val.match(/^#[0-9A-Fa-f]{6}$/)) {
                            this.matrixColor = val;
                            this.matrixColorCustomized = true;
                            if (matrixColorPicker) matrixColorPicker.value = val;
                            if (this.matrixStreams) this.matrixStreams.forEach(s => s.color = this.matrixColor);
                        }
                    });
                }

                // 3D Rotation sliders
                const rotXSlider = document.getElementById('rotXSlider');
                const rotYSlider = document.getElementById('rotYSlider');
                const rotZSlider = document.getElementById('rotZSlider');

                if (rotXSlider) {
                    rotXSlider.addEventListener('input', (e) => {
                        this.rotationX = parseFloat(e.target.value);
                        document.getElementById('rotXValue').textContent = this.rotationX + 'Â°';
                    });
                }
                if (rotYSlider) {
                    rotYSlider.addEventListener('input', (e) => {
                        this.rotationY = parseFloat(e.target.value);
                        document.getElementById('rotYValue').textContent = this.rotationY + 'Â°';
                    });
                }
                if (rotZSlider) {
                    rotZSlider.addEventListener('input', (e) => {
                        this.rotationZ = parseFloat(e.target.value);
                        document.getElementById('rotZValue').textContent = this.rotationZ + 'Â°';
                    });
                }

                // Trigger initial background generation
                this.resize();

                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);
            }

            /**
             * Resizes the canvas to fill its container and redraws the background.
             * The call to generateStaticBackground is here, so we must ensure the definition comes first.
             */
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                // This line now calls the function defined immediately below for guaranteed availability
                this.backgroundStars = this.generateStaticBackground();
                this.generateBackground(); // Ensure dynamic background is also regenerated
                this.draw();
            }

            /**
             * FIX: Added the missing function to generate static background stars.
             * This method is now positioned explicitly before other methods that rely on it
             * (like resize) to ensure availability in sensitive execution environments.
             */
            generateStaticBackground() {
                const bgStars = [];
                const count = 300; // number of background stars
                for (let i = 0; i < count; i++) {
                    bgStars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: Math.random() * 0.5 + 0.1,
                        alpha: Math.random() * 0.5 + 0.2
                    });
                }
                return bgStars;
            }

            setMode(newMode) {
                this.mode = newMode;
                document.getElementById('drawModeBtn').classList.remove('active');
                document.getElementById('selectModeBtn').classList.remove('active');

                if (newMode === 'draw') {
                    document.getElementById('drawModeBtn').classList.add('active');
                    this.canvas.style.cursor = 'crosshair';
                } else if (newMode === 'select') {
                    document.getElementById('selectModeBtn').classList.add('active');
                    this.canvas.style.cursor = 'pointer';
                }
            }

            /* --- NEW COLOR CONTROLS --- */

            getRainbowHex() {
                return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
            }

            setFixedColor(hexColor) {
                this.activeColor = hexColor;
                this.colorMode = 'fixed';
                this.updateColorModeUI();
                this.showToast(`Active color set to ${hexColor}`);
            }

            setRainbowMode() {
                this.colorMode = 'rainbow';
                this.updateColorModeUI();
                this.showToast("Active color set to Rainbow Mode ðŸŒˆ");
            }

            toggleBgStyle(style) {
                if (this.activeStyles.has(style)) {
                    // Allow deselecting all styles for minimal black background
                    this.activeStyles.delete(style);
                } else {
                    this.activeStyles.add(style);
                }

                this.updateBgUI();
                this.generateBackground();
            }

            updateBgUI() {
                // Update Buttons
                document.querySelectorAll('.bg-toggle').forEach(btn => {
                    const style = btn.getAttribute('data-style');
                    if (this.activeStyles.has(style)) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });

                // Update theme display and speed control visibility
                const themeDisplay = document.getElementById('matrixThemeDisplay');
                const speedControl = document.getElementById('matrixSpeedControl');
                if (this.activeStyles.has('cyber')) {
                    themeDisplay.style.display = 'block';
                    speedControl.style.display = 'block';
                } else {
                    themeDisplay.style.display = 'none';
                    speedControl.style.display = 'none';
                }
            }

            updateColorModeUI() {
                const fixedIndicator = document.getElementById('fixedModeIndicator');
                const rainbowBtn = document.getElementById('rainbowBtn');
                const colorText = document.getElementById('currentColorModeText');
                const colorInput = document.getElementById('colorInput');

                colorInput.value = this.activeColor; // Keep input updated

                if (this.colorMode === 'fixed') {
                    fixedIndicator.classList.add('active');
                    rainbowBtn.classList.remove('active');
                    fixedIndicator.style.background = this.activeColor;
                    colorText.innerText = `Color Mode: Fixed (${this.activeColor})`;
                } else {
                    fixedIndicator.classList.remove('active');
                    rainbowBtn.classList.add('active');
                    colorText.innerText = "Color Mode: Rainbow (Random per star)";
                }
            }

            /* --- Input Handling --- */

            getWorldPos(e) {
                return {
                    x: (e.clientX - this.canvas.width / 2 - this.camera.x) / this.camera.zoom,
                    y: (e.clientY - this.canvas.height / 2 - this.camera.y) / this.camera.zoom
                };
            }

            onPointerDown(e) {
                // Only track canvas interactions
                this.pointer.onCanvas = (e.target === this.canvas);
                this.pointer.isDown = true;
                this.pointer.startX = e.clientX;
                this.pointer.startY = e.clientY;
                this.pointer.camStartX = this.camera.x;
                this.pointer.camStartY = this.camera.y;

                const world = this.getWorldPos(e);
                const hitDist = (this.config.starBaseRad * 4) / this.camera.zoom;
                const starHit = this.stars.find(s => Math.hypot(s.x - world.x, s.y - world.y) < hitDist);

                // Refresh cluster assignments if we hit a star, in case we drag a group
                if (starHit) {
                    this.refreshClusterAssignments();

                    // In select mode, clicking a star initiates a cluster drag
                    if (this.mode === 'select' && starHit.clusterId) {
                        // Determine the cluster ID to drag (it's either the cluster name string or the star's ID string)
                        this.draggedClusterId = String(starHit.clusterId);
                        this.pointer.lastWorldX = world.x;
                        this.pointer.lastWorldY = world.y;
                        this.saveState();
                        return;
                    }

                    // If not in select mode, allow single star drag
                    if (this.mode === 'draw') {
                        this.draggedStar = starHit;
                        this.saveState();
                    }
                }
            }

            onPointerMove(e) {
                const world = this.getWorldPos(e);

                // Hover Logic
                const hitDist = (this.config.starBaseRad * 4) / this.camera.zoom;
                this.hoveredStar = this.stars.find(s => Math.hypot(s.x - world.x, s.y - world.y) < hitDist);

                // Cursor Feedback
                let newCursor = 'default';
                if (this.draggedStar || this.draggedClusterId || this.pointer.dragging) {
                    newCursor = 'grabbing';
                } else if (this.hoveredStar) {
                    newCursor = 'move';
                } else if (this.mode === 'draw') {
                    newCursor = 'crosshair';
                }
                this.canvas.style.cursor = newCursor;


                if (!this.pointer.isDown) return;

                const dx = e.clientX - this.pointer.startX;
                const dy = e.clientY - this.pointer.startY;
                const distMoved = Math.hypot(dx, dy);

                if (distMoved > 5) {
                    this.pointer.dragging = true;
                }

                if (this.draggedClusterId) {
                    // Calculate world delta since last move
                    const deltaWorldX = world.x - this.pointer.lastWorldX;
                    const deltaWorldY = world.y - this.pointer.lastWorldY;

                    const draggedIdString = this.draggedClusterId;
                    // Move all stars in the cluster
                    this.stars.forEach(s => {
                        // Use strict comparison on the clusterId string
                        if (String(s.clusterId) === draggedIdString) {
                            s.x += deltaWorldX;
                            s.y += deltaWorldY;
                        }
                    });

                    // Update last position
                    this.pointer.lastWorldX = world.x;
                    this.pointer.lastWorldY = world.y;

                } else if (this.draggedStar) {
                    this.draggedStar.x = world.x;
                    this.draggedStar.y = world.y;
                } else if (this.pointer.dragging) {
                    // Pan View
                    this.camera.x = this.pointer.camStartX + dx;
                    this.camera.y = this.pointer.camStartY + dy;
                }
            }

            onPointerUp(e) {
                // Only process star creation if pointer started on canvas
                if (this.pointer.onCanvas) {
                    const world = this.getWorldPos(e);
                    const hitDist = (this.config.starBaseRad * 4) / this.camera.zoom;
                    const clickedStar = this.stars.find(s => Math.hypot(s.x - world.x, s.y - world.y) < hitDist);

                    if (!this.pointer.dragging && !clickedStar) {
                        // Empty Space Clicked - Create Star (ONLY in draw mode)
                        if (this.mode === 'draw') {
                            this.saveState(); // Save BEFORE action

                            // Determine 3D position
                            const center = this.getConstellationCenter();
                            const pos3D = this.inverseRotate3D(world.x, world.y, center.x, center.y);

                            this.createStar(pos3D.x, pos3D.y, pos3D.z);
                        }
                    }
                }

                // Reset interaction state
                this.pointer.isDown = false;
                this.pointer.dragging = false;
                this.pointer.onCanvas = false;
                this.draggedStar = null;
                this.draggedClusterId = null;
            }

            onWheel(e) {
                e.preventDefault();
                const zoomSpeed = 0.0015;
                const newZoom = Math.max(0.1, Math.min(6, this.camera.zoom - e.deltaY * zoomSpeed));

                const worldPos = this.getWorldPos(e);
                this.camera.zoom = newZoom;

                this.camera.x = e.clientX - this.canvas.width / 2 - worldPos.x * this.camera.zoom;
                this.camera.y = e.clientY - this.canvas.height / 2 - worldPos.y * this.camera.zoom;
            }

            /* --- Star Creation --- */

            createStar(x, y, z = 0) {
                let starColor = this.activeColor;
                if (this.colorMode === 'rainbow') {
                    starColor = this.getRainbowHex();
                }

                this.stars.push({
                    x, y,
                    z: z, // Store Z coordinate
                    id: Math.floor(Date.now() + Math.random() * 1000).toString(),
                    phase: Math.random() * Math.PI * 2,
                    color: starColor,
                    clusterId: null, // Will be calculated in refreshClusterAssignments()
                });
                this.draw();
            }

            /**
             * Re-calculates connections and assigns cluster names/IDs to all star objects.
             * Guarantees that s.clusterId is always a string (either the constellation name or the star's unique string ID).
             */
            refreshClusterAssignments() {
                const { lines, clusters } = this.calculateGeometry();

                // Map to hold assignments: { starId: clusterName/starId }
                const assignmentMap = new Map();

                // 1. Assign deterministic name (string) to all members of large clusters (>= minGroupSize)
                clusters.forEach(c => {
                    if (c.length >= this.config.minGroupSize) {
                        const name = this.getConstellationName(c);
                        c.forEach(star => {
                            assignmentMap.set(star.id, name);
                        });
                    }
                });

                // 2. Apply assignments back to the main stars array
                this.stars.forEach(s => {
                    // If a star is part of a large cluster, use the mapped string name. Otherwise, use its unique string ID (s.id).
                    s.clusterId = assignmentMap.get(s.id) || s.id;
                });

                return { lines, clusters };
            }

            /* --- Utility Methods --- */

            getStarColor(s) {
                return s.color || '#e0faff'; // Fallback to default if somehow color is missing
            }

            hexToRgb(hex) {
                const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [
                    parseInt(result[1], 16),
                    parseInt(result[2], 16),
                    parseInt(result[3], 16)
                ] : [224, 240, 255]; // Default blue/white
            }


            /* --- Core Logic (State Management) --- */

            saveState() {
                // Save a deep copy of the stars array before an action that changes it
                const newState = JSON.stringify(this.stars.map(s => ({
                    x: s.x,
                    y: s.y,
                    id: String(s.id),
                    phase: s.phase,
                    color: s.color,
                })));
                if (this.history.length > 25) this.history.shift();
                this.history.push(newState);
                console.log('[UNDO] saveState called, history length:', this.history.length);
            }

            undo() {
                console.log('[UNDO] undo() called, history length:', this.history.length);
                if (this.history.length === 0) {
                    this.showToast("Nothing to undo");
                    return;
                }
                // Pop the last saved state and restore it
                const prevState = this.history.pop();
                if (prevState) {
                    this.stars = JSON.parse(prevState);
                    console.log('[UNDO] Restored state with', this.stars.length, 'stars');
                } else {
                    this.stars = [];
                }

                this.draw();
                this.showToast(`Undone (${this.history.length} remaining)`);
            }

            requestClear() {
                document.getElementById('clearModal').classList.add('active');
            }

            closeModal() {
                document.getElementById('clearModal').classList.remove('active');
            }

            confirmClear() {
                this.saveState();
                this.stars = [];
                this.camera = { x: 0, y: 0, zoom: 1 };
                this.closeModal();
                this.draw();
                this.showToast("Universe Imploded");
            }

            resetView() {
                this.camera = { x: 0, y: 0, zoom: 1 };
            }

            adjustZoom(delta) {
                this.camera.zoom = Math.max(0.1, Math.min(6, this.camera.zoom + delta));
            }

            getConstellationName(group) {
                const sortedIds = group.map(s => String(s.id)).sort((a, b) => a.localeCompare(b));
                let seed = 0;
                sortedIds.forEach((id, i) => {
                    for (let j = 0; j < id.length; j++) {
                        seed += id.charCodeAt(j) * (j + 1) * (i + 1);
                    }
                });
                seed = Math.floor(seed);

                const pre = this.prefixes[seed % this.prefixes.length];
                const root = this.roots[(seed * 13) % this.roots.length];
                const suf = this.suffixes[(seed * 7) % this.suffixes.length];

                const type = seed % 3;
                if (type === 0) return `${pre} ${root}`;
                if (type === 1) return `${root} ${suf}`;
                return `The ${pre} ${root} ${suf}`;
            }

            // Duplicate setBgStyle removed

            // ... (updateColorModeUI omitted)

            generateBackground() {
                // Allow empty activeStyles for minimal black background with just faint stars

                this.showBackground = true;
                this.staticStars = [];
                this.galaxies = [];
                this.blackHoles = [];
                this.shootingStars = [];
                this.backgroundStars = [];
                this.nebulae = [];
                this.spacecraft = [];
                this.matrixStreams = [];

                // State handling for Cyber theme history
                try {
                    const savedHistory = localStorage.getItem('matrixThemeHistory');
                    this.themeHistory = savedHistory ? JSON.parse(savedHistory) : [];
                    this.lastMatrixFamily = localStorage.getItem('matrixLastFamily') || '';
                } catch (e) {
                    this.themeHistory = [];
                    this.lastMatrixFamily = '';
                }

                // 1. Static Stars (Mixed Palette)
                this.generateStaticStars();

                // 2. Compose Layers based on active styles
                // Order matters for layering (Deep Space -> Nebula -> Alien -> Cyber)
                if (this.activeStyles.has('deep-space')) this.generateDeepSpaceStyle();
                if (this.activeStyles.has('nebula')) this.generateNebulaStyle();
                if (this.activeStyles.has('alien')) this.generateAlienStyle();
                if (this.activeStyles.has('cyber')) this.generateCyberStyle();
            }

            generateStaticStars() {
                const count = 150;
                let activeColors = [];

                // Aggregate colors from active styles
                if (this.activeStyles.has('deep-space')) activeColors.push('#ffffff');
                if (this.activeStyles.has('nebula')) activeColors.push('#ffffff', '#ffeebb', '#ccffff');
                if (this.activeStyles.has('alien')) activeColors.push('#00ff00', '#aa00ff');
                if (this.activeStyles.has('cyber')) activeColors.push('#00f3ff');

                // Fallback
                if (activeColors.length === 0) activeColors = ['#ffffff'];

                for (let i = 0; i < count; i++) {
                    this.staticStars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: Math.random() * 1.5 + 0.5,
                        alpha: Math.random() * 0.5 + 0.1,
                        color: activeColors[Math.floor(Math.random() * activeColors.length)]
                    });
                }
            }

            generateDeepSpaceStyle() {
                const range = this.worldSize;
                const half = range / 2;

                // 1. Background Stars (Faint, static)
                const count = 2000;
                for (let i = 0; i < count; i++) {
                    this.backgroundStars.push({
                        x: (Math.random() * range) - half,
                        y: (Math.random() * range) - half,
                        r: Math.random() * 0.8 + 0.1,
                        alpha: Math.random() * 0.3 + 0.05
                    });
                }

                // 2. Galaxies
                const galaxyCount = 10;
                for (let i = 0; i < galaxyCount; i++) {
                    this.galaxies.push({
                        x: (Math.random() * range) - half,
                        y: (Math.random() * range) - half,
                        color: ['#ff0055', '#5500ff', '#00aaff'][Math.floor(Math.random() * 3)],
                        angle: Math.random() * Math.PI * 2,
                        size: 100 + Math.random() * 300
                    });
                }

                // 3. Black Holes
                this.blackHoles.push({
                    x: (Math.random() * range) - half,
                    y: (Math.random() * range) - half,
                    size: 50 + Math.random() * 100
                });

                // 4. Nebulae
                const nebulaCount = 20;
                for (let i = 0; i < nebulaCount; i++) {
                    this.nebulae.push({
                        x: (Math.random() * range) - half,
                        y: (Math.random() * range) - half,
                        size: 1000 + Math.random() * 2000,
                        color: ['#4400cc', '#0033aa', '#cc0066', '#330033'][Math.floor(Math.random() * 4)],
                        alpha: 0.05 + Math.random() * 0.15
                    });
                }

                // 5. Detailed Planets
                this.planets = [];
                const planetTypes = [
                    { name: 'gas-giant', colors: ['#E8C273', '#C17B3A', '#8B5A2B'], hasAtmosphere: true },
                    { name: 'ice-giant', colors: ['#87CEEB', '#4682B4', '#5F9EA0'], hasAtmosphere: true },
                    { name: 'terrestrial', colors: ['#228B22', '#8B4513', '#2E8B57'], hasAtmosphere: true },
                    { name: 'desert', colors: ['#EDC9AF', '#D2691E', '#CD853F'], hasAtmosphere: false },
                    { name: 'volcanic', colors: ['#8B0000', '#FF4500', '#DC143C'], hasAtmosphere: true },
                    { name: 'ocean', colors: ['#0077BE', '#005A87', '#003F5C'], hasAtmosphere: true }
                ];
                const planetCount = 8;
                for (let i = 0; i < planetCount; i++) {
                    const type = planetTypes[Math.floor(Math.random() * planetTypes.length)];
                    const hasRings = Math.random() > 0.6; // 40% chance of rings
                    const radius = 40 + Math.random() * 120;
                    this.planets.push({
                        x: (Math.random() * range * 0.8) - half * 0.8,
                        y: (Math.random() * range * 0.8) - half * 0.8,
                        radius: radius,
                        type: type.name,
                        baseColor: type.colors[0],
                        secondaryColor: type.colors[1],
                        tertiaryColor: type.colors[2],
                        hasAtmosphere: type.hasAtmosphere,
                        atmosphereColor: type.name === 'ice-giant' ? '#ADD8E6' : (type.name === 'volcanic' ? '#FF6347' : '#87CEEB'),
                        hasRings: hasRings,
                        ringColor: hasRings ? `hsl(${Math.random() * 60 + 20}, 40%, 60%)` : null,
                        ringInnerRadius: radius * 1.3,
                        ringOuterRadius: radius * 2.2,
                        textureSeed: Math.random() * 1000,
                        rotation: Math.random() * Math.PI * 2,
                        axialTilt: (Math.random() - 0.5) * 0.6 // -0.3 to 0.3 radians
                    });
                }
            }

            generateNebulaStyle() {
                const range = this.worldSize;
                const half = range / 2;

                // Dense Nebulae
                const nebulaCount = 40;
                for (let i = 0; i < nebulaCount; i++) {
                    this.nebulae.push({
                        x: (Math.random() * range) - half,
                        y: (Math.random() * range) - half,
                        size: 1000 + Math.random() * 2000,
                        color: ['#ff0055', '#ffaa00', '#00ffaa', '#0055ff'][Math.floor(Math.random() * 4)],
                        alpha: 0.1 + Math.random() * 0.2
                    });
                }
                // Fewer stars
                for (let i = 0; i < 1000; i++) {
                    this.backgroundStars.push({
                        x: (Math.random() * range) - half,
                        y: (Math.random() * range) - half,
                        r: Math.random() * 1.5 + 0.5,
                        alpha: Math.random() * 0.5 + 0.2
                    });
                }
            }

            generateAlienStyle() {
                const range = this.worldSize;
                const half = range / 2;

                // Green/Purple Theme (Randomized Mix)
                const theme = Math.random();
                let color1, color2;
                if (theme < 0.33) { color1 = '#00ff00'; color2 = '#ccff00'; }
                else if (theme < 0.66) { color1 = '#aa00ff'; color2 = '#ff00aa'; }
                else { color1 = '#00ffff'; color2 = '#0000ff'; }

                for (let i = 0; i < 1500; i++) {
                    this.backgroundStars.push({
                        x: (Math.random() * range) - half,
                        y: (Math.random() * range) - half,
                        r: Math.random() * 0.8 + 0.2,
                        alpha: Math.random() * 0.4 + 0.1,
                        color: Math.random() > 0.5 ? color1 : color2
                    });
                }

                // Epic Alien Spacecraft Fleet
                const craftCount = 20;
                const shipClasses = [
                    { name: 'saucer', baseSize: 50, complexity: 'high', weight: 3 },      // Classic flying saucer
                    { name: 'cruiser', baseSize: 70, complexity: 'high', weight: 2 },
                    { name: 'fighter', baseSize: 25, complexity: 'medium', weight: 3 },
                    { name: 'mothership', baseSize: 200, complexity: 'high', weight: 1 },
                    { name: 'probe', baseSize: 12, complexity: 'low', weight: 2 },
                    { name: 'destroyer', baseSize: 90, complexity: 'high', weight: 2 },
                    { name: 'interceptor', baseSize: 35, complexity: 'medium', weight: 2 }
                ];

                // Build weighted selection pool
                const pool = [];
                shipClasses.forEach(sc => {
                    for (let w = 0; w < sc.weight; w++) pool.push(sc);
                });

                for (let i = 0; i < craftCount; i++) {
                    const shipClass = pool[Math.floor(Math.random() * pool.length)];
                    const hue = Math.random() * 360;
                    const size = shipClass.baseSize * (0.7 + Math.random() * 0.6);
                    const isSaucer = shipClass.name === 'saucer';

                    this.spacecraft.push({
                        x: (Math.random() * range) - half,
                        y: (Math.random() * range) - half,
                        vx: (Math.random() - 0.5) * (isSaucer ? 2 : 3),
                        vy: (Math.random() - 0.5) * (isSaucer ? 2 : 3),
                        size: size,
                        shipClass: shipClass.name,
                        complexity: shipClass.complexity,
                        // Primary hull - metallic chrome for saucers, colored for others
                        hullColor: isSaucer ? `hsl(${hue}, 10%, 50%)` : `hsl(${hue}, 30%, 40%)`,
                        hullHighlight: isSaucer ? `hsl(${hue}, 5%, 85%)` : `hsl(${hue}, 20%, 70%)`,
                        hullShadow: isSaucer ? `hsl(${hue}, 15%, 25%)` : `hsl(${hue}, 40%, 20%)`,
                        // Engine colors - bright neon
                        engineColor: `hsl(${(hue + 180) % 360}, 100%, 60%)`,
                        engineGlow: `hsl(${(hue + 180) % 360}, 100%, 85%)`,
                        // Accent running lights
                        lightColor: `hsl(${Math.random() * 60 + 300}, 100%, 55%)`, // Purple-pink range
                        lightColor2: `hsl(${Math.random() * 60}, 100%, 50%)`,       // Red-yellow range
                        lightPhase: Math.random() * Math.PI * 2,
                        // Detail parameters
                        detailSeed: Math.random() * 1000,
                        wingAngle: 0.3 + Math.random() * 0.4,
                        engineCount: shipClass.name === 'mothership' ? 6 : (shipClass.name === 'destroyer' ? 4 : (shipClass.name === 'cruiser' ? 3 : 2)),
                        // Saucer-specific
                        domeColor: `hsl(${Math.random() * 180 + 160}, 80%, 70%)`, // Cyan-green dome
                        beamActive: Math.random() > 0.7, // 30% have active tractor beam
                        beamColor: `hsl(${Math.random() * 60 + 80}, 100%, 70%)`,  // Green-yellow beam
                        ringCount: isSaucer ? Math.floor(Math.random() * 3) + 2 : 0, // 2-4 light rings
                        rotationSpeed: (Math.random() - 0.5) * 0.02, // Spinning saucer lights
                        rotation: Math.random() * Math.PI * 2,
                        // Shield effect for some ships
                        hasShield: Math.random() > 0.8,
                        shieldColor: `hsl(${Math.random() * 60 + 180}, 70%, 60%)`,
                        shieldPhase: Math.random() * Math.PI * 2
                    });
                }
            }

            generateCyberStyle() {
                // Reset custom color flag so new generation allows random themes again
                this.matrixColorCustomized = false;

                // Matrix Rain Setup (Screen Space)
                this.matrixStreams = [];
                const fontSize = 14;
                const columns = Math.ceil(this.canvas.width / fontSize);

                // Base Themes
                // Top 20 Curated Cyber Colors + Rainbow Surge
                const themes = [
                    { name: 'System Yellow', color: '#FFFF00', family: 'yellow' },
                    { name: 'Neon Pink', color: '#FF1493', family: 'pink' },
                    { name: 'Chrome Static', color: '#C0C0C0', family: 'mono' }, // Silver
                    { name: 'Royal Data', color: '#4169E1', family: 'blue' }, // Royal Blue
                    { name: 'Navy Blue', color: '#000080', family: 'blue' },
                    { name: 'White Noise', color: '#FFFFFF', family: 'mono' },
                    { name: 'Golden Key', color: '#FFD700', family: 'yellow' }, // Gold
                    { name: 'Firewall Orange', color: '#FF4500', family: 'pink' },
                    { name: 'Cyan Future', color: '#00FFFF', family: 'blue' },
                    { name: 'Lime Access', color: '#32CD32', family: 'green' },
                    { name: 'Purple Haze', color: '#800080', family: 'purple' },
                    { name: 'Crimson Error', color: '#DC143C', family: 'pink' },
                    { name: 'Teal Glitch', color: '#008080', family: 'green' },
                    { name: 'Magenta Core', color: '#FF00FF', family: 'pink' },
                    { name: 'Violet Mainframe', color: '#EE82EE', family: 'purple' },
                    { name: 'Emerald Link', color: '#50C878', family: 'green' },
                    { name: 'Sapphire Stream', color: '#0F52BA', family: 'blue' },
                    { name: 'Ruby Firewall', color: '#E0115F', family: 'pink' },
                    { name: 'Amber Alert', color: '#FFBF00', family: 'yellow' },
                    { name: 'Ice Blue', color: '#A5F2F3', family: 'blue' },
                    { name: 'sentAIent Blue', color: '#60A9FF', family: 'blue' },
                    { name: 'Rainbow Surge', color: 'rainbow', family: 'rainbow' }
                ];

                // History Buffer Logic (Last 5 themes) + Family Check
                // Filter out ANY theme that is in the history buffer OR matches the last family
                const lastFamily = this.lastMatrixFamily || '';

                let availableThemes = themes.filter(t => !this.themeHistory.includes(t.name));

                // Try to filter by family too, but ensure we don't empty the pool
                const familyFiltered = availableThemes.filter(t => t.family !== lastFamily);
                if (familyFiltered.length > 0) {
                    availableThemes = familyFiltered;
                }

                // Fallback: If we ran out of themes (unlikely), just avoid the very last one
                let pool = availableThemes;
                if (pool.length === 0) {
                    const lastTheme = this.themeHistory[this.themeHistory.length - 1];
                    pool = themes.filter(t => t.name !== lastTheme);
                }

                const themeIndex = Math.floor(Math.random() * pool.length);
                const theme = pool[themeIndex];

                // Update History
                this.themeHistory.push(theme.name);
                if (this.themeHistory.length > 5) {
                    this.themeHistory.shift(); // Keep only last 5
                }
                this.lastMatrixFamily = theme.family; // Track family

                // Persist to LocalStorage
                try {
                    localStorage.setItem('matrixThemeHistory', JSON.stringify(this.themeHistory));
                    localStorage.setItem('matrixLastFamily', this.lastMatrixFamily);
                } catch (e) {
                    console.warn('LocalStorage failed', e);
                }

                console.log(`[Matrix] Selected: ${theme.name} (${theme.family}), History: ${JSON.stringify(this.themeHistory)}, Pool Size: ${pool.length}`);

                this.matrixTheme = theme;

                // Discrete Speed Levels: Crawl, Slow, Normal, Fast, Hyper, Ludicrous
                const speedLevels = [
                    { name: 'Crawl', value: 0.2 },
                    { name: 'Slow', value: 0.5 },
                    { name: 'Normal', value: 1.0 },
                    { name: 'Fast', value: 2.0 },
                    { name: 'Hyper', value: 4.0 },
                    { name: 'Ludicrous', value: 8.0 }
                ];
                const selectedSpeed = speedLevels[Math.floor(Math.random() * speedLevels.length)];
                this.matrixSpeedMultiplier = selectedSpeed.value;

                this.showToast(`Cyber Theme: ${theme.name} (Speed: ${selectedSpeed.name}) [v14]`);

                // Update UI Display
                const displayEl = document.getElementById('matrixThemeDisplay');
                if (displayEl) {
                    displayEl.innerText = `Theme: ${theme.name} | Family: ${theme.family.charAt(0).toUpperCase() + theme.family.slice(1)}`;
                }

                // Sync speed slider with current value
                const slider = document.getElementById('matrixSpeedSlider');
                const sliderValue = document.getElementById('matrixSpeedValue');
                if (slider) slider.value = this.matrixSpeedMultiplier;
                if (sliderValue) sliderValue.textContent = this.matrixSpeedMultiplier.toFixed(1) + 'x';

                for (let i = 0; i < columns; i++) {
                    const depth = Math.random(); // 0 to 1
                    const size = Math.floor(10 + depth * 14); // 10px to 24px
                    // Apply speed multiplier with per-stream variance
                    const speed = (2 + depth * 8 + Math.random() * 2) * this.matrixSpeedMultiplier;

                    // Massive Trails: 600 to 1500 characters (3x longer)
                    const len = 600 + Math.floor(Math.random() * 9000);
                    const chars = [];
                    for (let j = 0; j < len; j++) {
                        chars.push(String.fromCharCode(0x30A0 + Math.random() * 96));
                    }

                    // Handle Rainbow Theme
                    let streamColor = theme.color;
                    if (this.matrixColorCustomized) {
                        streamColor = this.matrixColor;
                    } else if (theme.name === 'Rainbow Surge') {
                        // Calculate hue based on column index (i) to cycle through the spectrum
                        const hue = (i * 360 / columns) % 360;
                        streamColor = `hsl(${hue}, 100%, 50%)`; // Full saturation, mid lightness
                    }

                    this.matrixStreams.push({
                        x: i * fontSize, // Fixed columns
                        y: Math.random() * this.canvas.height, // Starting Y position
                        baseSpeed: (2 + depth * 8 + Math.random() * 2), // Store base speed
                        chars: chars,
                        color: streamColor,
                        size: size,
                        opacity: 0.3 + depth * 0.7 // Closer = brighter
                    });
                }
            }

            /* --- Rendering --- */

            animate(time) {
                // Update spacecraft positions
                if (this.spacecraft && this.spacecraft.length > 0) {
                    const range = this.worldSize;
                    const half = range / 2;
                    this.spacecraft.forEach(s => {
                        s.x += s.vx;
                        s.y += s.vy;
                        // Wrap around world bounds
                        if (s.x > half) s.x = -half;
                        if (s.x < -half) s.x = half;
                        if (s.y > half) s.y = -half;
                        if (s.y < -half) s.y = half;
                    });
                }

                this.draw(time);
                requestAnimationFrame(this.animate);
            }

            draw(time) {
                const { ctx, canvas } = this;

                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.fillStyle = this.config.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Static Background Stars (Screen Space)
                if (this.config.showBackground) {
                    const paraX = this.camera.x * 0.05;
                    const paraY = this.camera.y * 0.05;

                    this.staticStars.forEach(s => {
                        let sx = (s.x + paraX) % canvas.width;
                        let sy = (s.y + paraY) % canvas.height;
                        if (sx < 0) sx += canvas.width;
                        if (sy < 0) sy += canvas.height;

                        ctx.fillStyle = s.color;
                        ctx.globalAlpha = s.alpha;
                        ctx.beginPath();
                        ctx.arc(sx, sy, s.size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.globalAlpha = 1.0;

                    // Cyber Matrix Rain (Screen Space)
                    // Only draw if cyber style is active
                    if (this.activeStyles.has('cyber') && this.matrixStreams) {
                        ctx.textAlign = 'center';
                        const speedMult = this.matrixSpeedMultiplier || 1.0;
                        const lengthMult = this.matrixLengthMultiplier || 1.0;

                        // Base visible length: 20 chars at 1x, slider scales from ~4 to ~60 chars
                        const baseVisibleLength = 20;

                        this.matrixStreams.forEach(stream => {
                            // Update with real-time speed multiplier
                            stream.y += stream.baseSpeed * speedMult;

                            // Calculate visible length based on slider (independent of array size)
                            const visibleLength = Math.max(3, Math.floor(baseVisibleLength * lengthMult));

                            if (stream.y - (visibleLength * stream.size) > canvas.height) {
                                stream.y = -stream.size; // Reset to top
                            }

                            // Draw
                            ctx.font = `${stream.size}px monospace`;

                            // Only draw visible characters based on length multiplier
                            for (let i = 0; i < visibleLength && i < stream.chars.length; i++) {
                                const char = stream.chars[i];
                                const charY = stream.y - (i * stream.size);
                                if (charY < -stream.size || charY > canvas.height + stream.size) continue;

                                // Improved visibility: Fade out only near the end of the tail
                                const relativePos = 1 - (i / visibleLength);
                                const alpha = Math.pow(relativePos, 0.5) * stream.opacity;

                                ctx.globalAlpha = alpha;
                                ctx.fillStyle = stream.color;
                                ctx.shadowBlur = 0;

                                ctx.fillText(char, stream.x, charY);
                            }
                        });
                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1.0;
                    }
                }

                // World Transform
                ctx.translate(canvas.width / 2 + this.camera.x, canvas.height / 2 + this.camera.y);
                ctx.scale(this.camera.zoom, this.camera.zoom);

                // Calculations & Cluster ID Assignment
                const { lines, clusters } = this.refreshClusterAssignments();

                // 0. Draw Background Layers
                // Always draw background stars and nebulae if they exist
                this.drawBackgroundElements();

                // Draw deep space specific elements (galaxies, black holes, planets)
                if (this.activeStyles.has('deep-space')) this.drawDeepSpaceSpecific();

                // 1. Draw Grid Lines (Glow Pass + Core Pass) with 3D rotation
                if (lines.length > 0) {
                    ctx.lineCap = 'round';
                    ctx.shadowBlur = 10;

                    // Rotation center (constellation center)
                    const center = this.getConstellationCenter();
                    const rotCenterX = center.x;
                    const rotCenterY = center.y;
                    const rotCenterZ = center.z;

                    lines.forEach(l => {
                        const alpha = Math.max(0, 1 - (l.dist / this.config.maxConnectDist));
                        const starColor = this.getStarColor(l.s1);
                        const [r, g, b] = this.hexToRgb(starColor);

                        // Apply 3D rotation
                        const s1z = l.s1.z || 0;
                        const s2z = l.s2.z || 0;
                        const p1 = this.rotate3D(l.s1.x, l.s1.y, s1z, rotCenterX, rotCenterY);
                        const p2 = this.rotate3D(l.s2.x, l.s2.y, s2z, rotCenterX, rotCenterY);

                        ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.8)`;
                        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha * 0.3})`;
                        ctx.lineWidth = 3 / this.camera.zoom;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    });
                    ctx.shadowBlur = 0;

                    lines.forEach(l => {
                        const alpha = Math.max(0, 1 - (l.dist / this.config.maxConnectDist));
                        const starColor = this.getStarColor(l.s1);

                        // Apply 3D rotation
                        const s1z = l.s1.z || 0;
                        const s2z = l.s2.z || 0;
                        const p1 = this.rotate3D(l.s1.x, l.s1.y, s1z, rotCenterX, rotCenterY);
                        const p2 = this.rotate3D(l.s2.x, l.s2.y, s2z, rotCenterX, rotCenterY);

                        ctx.strokeStyle = starColor;
                        ctx.globalAlpha = alpha * 0.8;
                        ctx.lineWidth = 1 / this.camera.zoom;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    });
                    ctx.globalAlpha = 1.0;
                }

                // 6. Draw Text Labels
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.font = `600 ${14 / this.camera.zoom}px 'Exo 2'`;

                clusters.forEach(c => {
                    // Only draw names for clusters that meet the minimum size threshold AND have a generated name
                    const name = String(c[0].clusterId);
                    if (c.length < this.config.minGroupSize || name === String(c[0].id)) return;

                    // Centroid Calculation
                    let cx = 0, cy = 0;
                    c.forEach(s => { cx += s.x; cy += s.y; });
                    cx /= c.length; cy /= c.length;

                    const avgColor = this.getStarColor(c[0]);

                    // Draw Text Label
                    ctx.fillStyle = avgColor;
                    ctx.shadowColor = "black";
                    ctx.shadowBlur = 4;
                    ctx.fillText(name, cx, cy + (30 / this.camera.zoom));
                    ctx.shadowBlur = 0;
                });

                // 7. Draw Stars with 3D rotation
                const timeNow = performance.now();
                // Use constellation center for rotation
                const center = this.getConstellationCenter();
                const rotCenterX = center.x;
                const rotCenterY = center.y;
                // Note: we just pass centerX/Y as pivot, Z pivot is implicitly handled by rotate3D logic relative to 0? 
                // Wait, rotate3D logic (let pz = z) rotates AROUND (centerX, centerY, 0).
                // If the constellation center has Z != 0, we should translate Z too?
                // rotate3D implementation: let px = x - centerX; let py = y - centerY; let pz = z; 
                // So it assumes pivot Z is 0. If center.z is not 0, we should subtract it.
                // But let's stick to previous logical structure where we just updated rotate3D signature.
                // Ideally: let pz = z - (center.z || 0);
                // Let's rely on the definition where we pass Z.

                this.stars.forEach(s => {
                    const isHover = (s === this.hoveredStar);

                    // Apply 3D rotation
                    const sz = s.z || 0;
                    const rotated = this.rotate3D(s.x, s.y, sz, rotCenterX, rotCenterY);
                    const rx = rotated.x;
                    const ry = rotated.y;
                    const rScale = rotated.scale;

                    const twinkle = Math.sin(timeNow * 0.003 + s.phase) * 0.2 + 0.8;
                    const scale = isHover ? 1.5 : 1.0;
                    const radius = this.config.starBaseRad * twinkle * scale * rScale / this.camera.zoom;
                    const starColor = this.getStarColor(s);
                    const [r, g, b] = this.hexToRgb(starColor);

                    // Draw Glow
                    const glowRad = radius * 6;
                    const grad = ctx.createRadialGradient(rx, ry, 0, rx, ry, glowRad);
                    grad.addColorStop(0, `rgba(255, 255, 255, ${isHover ? 0.9 : 0.6})`);
                    grad.addColorStop(0.2, `rgba(${r}, ${g}, ${b}, 0.3)`);
                    grad.addColorStop(1, "rgba(0,0,0,0)");

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(rx, ry, glowRad, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw Core (Star Shape)
                    ctx.fillStyle = starColor;
                    this.drawStarShape(ctx, rx, ry, radius);
                });

                // Update HUD
                const statEl = document.getElementById('stats');
                const constellationCount = clusters.filter(c => c.length >= this.config.minGroupSize).length;
                if (statEl) statEl.innerText = `Mode: ${this.mode.charAt(0).toUpperCase() + this.mode.slice(1)} | Stars: ${this.stars.length} | Constellations: ${constellationCount} | Zoom: ${this.camera.zoom.toFixed(2)}x`;
            }

            drawBackgroundElements() {
                if (!this.config.showBackground) return;

                const ctx = this.ctx;

                // 1. Background Stars (from all active styles)
                if (this.backgroundStars && this.backgroundStars.length > 0) {
                    this.backgroundStars.forEach(s => {
                        ctx.fillStyle = s.color || "white";
                        ctx.globalAlpha = s.alpha;
                        ctx.beginPath();
                        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.globalAlpha = 1;
                }

                // 2. Nebulae (from nebula + deep-space styles)
                if (this.nebulae && this.nebulae.length > 0) {
                    ctx.globalCompositeOperation = 'screen';
                    this.nebulae.forEach(n => {
                        const grad = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.size);
                        grad.addColorStop(0, n.color);
                        grad.addColorStop(1, 'transparent');

                        ctx.globalAlpha = n.alpha;
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.arc(n.x, n.y, n.size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.globalAlpha = 1;
                }

                // 3. Spacecraft (from alien style) - ENHANCED RENDERING
                if (this.activeStyles.has('alien') && this.spacecraft && this.spacecraft.length > 0) {
                    const time = performance.now() * 0.001;
                    this.spacecraft.forEach(s => {
                        ctx.save();
                        ctx.translate(s.x, s.y);

                        // Update rotation for saucers
                        if (s.rotationSpeed) s.rotation += s.rotationSpeed;

                        const size = s.size;
                        const zoom = this.camera.zoom;
                        const angle = Math.atan2(s.vy, s.vx);

                        // Shield effect (drawn first, behind ship)
                        if (s.hasShield) {
                            const shieldPulse = Math.sin(time * 2 + s.shieldPhase) * 0.3 + 0.4;
                            ctx.globalAlpha = shieldPulse * 0.4;
                            const shieldGrad = ctx.createRadialGradient(0, 0, size * 0.5, 0, 0, size * 1.5);
                            shieldGrad.addColorStop(0, 'transparent');
                            shieldGrad.addColorStop(0.7, s.shieldColor || 'rgba(100,200,255,0.3)');
                            shieldGrad.addColorStop(1, 'transparent');
                            ctx.fillStyle = shieldGrad;
                            ctx.beginPath();
                            ctx.arc(0, 0, size * 1.5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }

                        // Tractor beam (for saucers)
                        if (s.beamActive && s.shipClass === 'saucer') {
                            const beamPulse = Math.sin(time * 5) * 0.2 + 0.6;
                            ctx.globalAlpha = beamPulse * 0.5;
                            const beamGrad = ctx.createLinearGradient(0, size * 0.2, 0, size * 3);
                            beamGrad.addColorStop(0, s.beamColor || '#88ff88');
                            beamGrad.addColorStop(1, 'transparent');
                            ctx.fillStyle = beamGrad;
                            ctx.beginPath();
                            ctx.moveTo(-size * 0.3, size * 0.2);
                            ctx.lineTo(-size * 0.8, size * 3);
                            ctx.lineTo(size * 0.8, size * 3);
                            ctx.lineTo(size * 0.3, size * 0.2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }

                        // Rotate for directional ships (not saucers)
                        if (s.shipClass !== 'saucer') {
                            ctx.rotate(angle);
                        }

                        // Engine trails (for non-saucers)
                        if (s.shipClass !== 'saucer' && s.shipClass !== 'probe') {
                            ctx.globalAlpha = 0.7;
                            const trailLength = size * 2;
                            const engineSpacing = size * 0.25;
                            const engineCount = s.engineCount || 2;

                            for (let i = 0; i < engineCount; i++) {
                                const offsetY = (i - (engineCount - 1) / 2) * engineSpacing;
                                const flicker = 0.7 + Math.sin(time * 15 + s.detailSeed + i) * 0.3;
                                const trailGrad = ctx.createLinearGradient(-size * 0.7, offsetY, -size * 0.7 - trailLength * flicker, offsetY);
                                trailGrad.addColorStop(0, s.engineGlow || '#ffffff');
                                trailGrad.addColorStop(0.15, s.engineColor || '#00aaff');
                                trailGrad.addColorStop(1, 'transparent');

                                ctx.fillStyle = trailGrad;
                                ctx.beginPath();
                                ctx.moveTo(-size * 0.65, offsetY - 4);
                                ctx.quadraticCurveTo(-size * 0.7 - trailLength * 0.5 * flicker, offsetY, -size * 0.7 - trailLength * flicker, offsetY);
                                ctx.quadraticCurveTo(-size * 0.7 - trailLength * 0.5 * flicker, offsetY, -size * 0.65, offsetY + 4);
                                ctx.closePath();
                                ctx.fill();
                            }
                            ctx.globalAlpha = 1;
                        }

                        // Hull gradient
                        const hullGrad = ctx.createLinearGradient(0, -size * 0.5, 0, size * 0.5);
                        hullGrad.addColorStop(0, s.hullHighlight || '#ccc');
                        hullGrad.addColorStop(0.3, s.hullColor || '#888');
                        hullGrad.addColorStop(1, s.hullShadow || '#333');
                        ctx.fillStyle = hullGrad;
                        ctx.strokeStyle = s.hullHighlight || '#ddd';
                        ctx.lineWidth = 1.5 / zoom;

                        // === FLYING SAUCER ===
                        if (s.shipClass === 'saucer') {
                            // Main disc body
                            ctx.beginPath();
                            ctx.ellipse(0, 0, size, size * 0.25, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();

                            // Upper dome (glass cockpit)
                            const domeGrad = ctx.createRadialGradient(-size * 0.1, -size * 0.15, 0, 0, -size * 0.05, size * 0.4);
                            domeGrad.addColorStop(0, '#ffffff');
                            domeGrad.addColorStop(0.3, s.domeColor || '#88ffff');
                            domeGrad.addColorStop(0.7, s.domeColor || '#44aaaa');
                            domeGrad.addColorStop(1, 'rgba(0,50,50,0.8)');
                            ctx.fillStyle = domeGrad;
                            ctx.beginPath();
                            ctx.ellipse(0, -size * 0.08, size * 0.35, size * 0.25, 0, Math.PI, 0);
                            ctx.fill();

                            // Rotating underside lights
                            const ringCount = s.ringCount || 3;
                            for (let ring = 0; ring < ringCount; ring++) {
                                const ringRadius = size * (0.5 + ring * 0.15);
                                const lightCount = 8 + ring * 4;
                                for (let i = 0; i < lightCount; i++) {
                                    const lightAngle = (i / lightCount) * Math.PI * 2 + s.rotation + ring * 0.5;
                                    const lx = Math.cos(lightAngle) * ringRadius;
                                    const ly = Math.sin(lightAngle) * ringRadius * 0.25 + size * 0.1;
                                    const pulse = Math.sin(time * 4 + i + ring) * 0.4 + 0.6;

                                    ctx.globalAlpha = pulse;
                                    ctx.fillStyle = i % 2 === 0 ? (s.lightColor || '#ff00ff') : (s.lightColor2 || '#ffff00');
                                    ctx.beginPath();
                                    ctx.arc(lx, ly, 3 / zoom, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                            ctx.globalAlpha = 1;

                            // Center glow
                            const centerGlow = ctx.createRadialGradient(0, size * 0.1, 0, 0, size * 0.1, size * 0.3);
                            centerGlow.addColorStop(0, s.engineGlow || '#ffffff');
                            centerGlow.addColorStop(0.5, s.engineColor || '#00ffff');
                            centerGlow.addColorStop(1, 'transparent');
                            ctx.fillStyle = centerGlow;
                            ctx.beginPath();
                            ctx.arc(0, size * 0.1, size * 0.3, 0, Math.PI * 2);
                            ctx.fill();

                            // === CRUISER / DESTROYER ===
                        } else if (s.shipClass === 'cruiser' || s.shipClass === 'destroyer') {
                            const isDestroyer = s.shipClass === 'destroyer';
                            ctx.beginPath();
                            ctx.moveTo(size * 1.1, 0);
                            ctx.lineTo(size * 0.3, -size * 0.3);
                            ctx.lineTo(-size * 0.4, -size * 0.35);
                            ctx.lineTo(-size * 0.9, -size * 0.2);
                            ctx.lineTo(-size * 0.9, size * 0.2);
                            ctx.lineTo(-size * 0.4, size * 0.35);
                            ctx.lineTo(size * 0.3, size * 0.3);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();

                            // Wings
                            ctx.beginPath();
                            ctx.moveTo(-size * 0.1, -size * 0.3);
                            ctx.lineTo(-size * (isDestroyer ? 0.5 : 0.4), -size * 0.9);
                            ctx.lineTo(-size * (isDestroyer ? 0.7 : 0.6), -size * 0.9);
                            ctx.lineTo(-size * 0.5, -size * 0.35);
                            ctx.closePath();
                            ctx.fill();
                            ctx.beginPath();
                            ctx.moveTo(-size * 0.1, size * 0.3);
                            ctx.lineTo(-size * (isDestroyer ? 0.5 : 0.4), size * 0.9);
                            ctx.lineTo(-size * (isDestroyer ? 0.7 : 0.6), size * 0.9);
                            ctx.lineTo(-size * 0.5, size * 0.35);
                            ctx.closePath();
                            ctx.fill();

                            // Cockpit window
                            ctx.fillStyle = 'rgba(100,200,255,0.7)';
                            ctx.beginPath();
                            ctx.ellipse(size * 0.5, 0, size * 0.15, size * 0.08, 0, 0, Math.PI * 2);
                            ctx.fill();

                            // === FIGHTER / INTERCEPTOR ===
                        } else if (s.shipClass === 'fighter' || s.shipClass === 'interceptor') {
                            const isInterceptor = s.shipClass === 'interceptor';
                            ctx.beginPath();
                            ctx.moveTo(size * 0.9, 0);
                            ctx.lineTo(size * 0.1, -size * (isInterceptor ? 0.5 : 0.4));
                            ctx.lineTo(-size * 0.7, -size * 0.2);
                            ctx.lineTo(-size * 0.7, size * 0.2);
                            ctx.lineTo(size * 0.1, size * (isInterceptor ? 0.5 : 0.4));
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();

                            // === MOTHERSHIP ===
                        } else if (s.shipClass === 'mothership') {
                            // Main hull
                            ctx.beginPath();
                            ctx.ellipse(0, 0, size * 1.2, size * 0.5, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();

                            // Command bridge
                            ctx.beginPath();
                            ctx.ellipse(size * 0.4, -size * 0.15, size * 0.4, size * 0.25, 0, Math.PI, 0);
                            ctx.fill();

                            // Hangar bays
                            ctx.fillStyle = 'rgba(255,200,100,0.6)';
                            for (let i = -2; i <= 2; i++) {
                                ctx.beginPath();
                                ctx.rect(i * size * 0.3 - size * 0.08, size * 0.3, size * 0.16, size * 0.1);
                                ctx.fill();
                            }

                            // Running lights
                            for (let i = 0; i < 12; i++) {
                                const lAngle = (i / 12) * Math.PI * 2;
                                const lx = Math.cos(lAngle) * size * 1.1;
                                const ly = Math.sin(lAngle) * size * 0.45;
                                const pulse = Math.sin(time * 2 + i * 0.5) * 0.3 + 0.7;
                                ctx.globalAlpha = pulse;
                                ctx.fillStyle = i % 3 === 0 ? '#ff0000' : (i % 3 === 1 ? '#00ff00' : '#ffffff');
                                ctx.beginPath();
                                ctx.arc(lx, ly, 4 / zoom, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            ctx.globalAlpha = 1;

                            // === PROBE ===
                        } else {
                            // Spherical probe with antenna
                            const probeGrad = ctx.createRadialGradient(-size * 0.15, -size * 0.15, 0, 0, 0, size * 0.5);
                            probeGrad.addColorStop(0, '#ffffff');
                            probeGrad.addColorStop(0.5, s.hullColor || '#888');
                            probeGrad.addColorStop(1, s.hullShadow || '#222');
                            ctx.fillStyle = probeGrad;
                            ctx.beginPath();
                            ctx.arc(0, 0, size * 0.5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();

                            // Antenna
                            ctx.strokeStyle = '#aaa';
                            ctx.lineWidth = 2 / zoom;
                            ctx.beginPath();
                            ctx.moveTo(0, -size * 0.5);
                            ctx.lineTo(0, -size * 1.2);
                            ctx.stroke();

                            // Blinking tip
                            const tipPulse = Math.sin(time * 8 + s.lightPhase) > 0 ? 1 : 0.2;
                            ctx.globalAlpha = tipPulse;
                            ctx.fillStyle = '#ff0000';
                            ctx.beginPath();
                            ctx.arc(0, -size * 1.2, 3 / zoom, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }

                        // Navigation lights (for non-probes, non-saucers)
                        if (s.shipClass !== 'probe' && s.shipClass !== 'saucer') {
                            const lightPulse = Math.sin(time * 3 + (s.lightPhase || 0)) * 0.5 + 0.5;
                            ctx.fillStyle = s.lightColor || '#ff00ff';
                            ctx.globalAlpha = lightPulse;
                            ctx.beginPath();
                            ctx.arc(size * 0.85, 0, 3 / zoom, 0, Math.PI * 2);
                            ctx.fill();

                            // Wing tip lights
                            ctx.fillStyle = '#00ff00';
                            ctx.beginPath();
                            ctx.arc(-size * 0.5, -size * 0.6, 2 / zoom, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = '#ff0000';
                            ctx.beginPath();
                            ctx.arc(-size * 0.5, size * 0.6, 2 / zoom, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }

                        ctx.restore();
                    });
                }
            }

            drawDeepSpaceSpecific() {
                if (!this.config.showBackground) return;

                const ctx = this.ctx;
                const time = performance.now() * 0.0005;

                // 1. Galaxies
                if (this.galaxies && this.galaxies.length > 0) {
                    this.galaxies.forEach(g => {
                        ctx.save();
                        ctx.translate(g.x, g.y);
                        ctx.rotate(g.angle + time * 0.1);

                        const spiralGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, g.size);
                        spiralGradient.addColorStop(0, 'rgba(255,255,255,0.8)');
                        spiralGradient.addColorStop(0.2, g.color);
                        spiralGradient.addColorStop(1, 'transparent');

                        ctx.fillStyle = spiralGradient;
                        ctx.beginPath();
                        for (let i = 0; i < 3; i++) {
                            ctx.rotate(Math.PI * 2 / 3);
                            ctx.ellipse(0, 0, g.size, g.size / 4, 0, 0, Math.PI * 2); // Corrected ellipse center
                        }
                        ctx.fill();
                        ctx.restore();
                    });
                }

                // 2. Black Holes
                if (this.blackHoles && this.blackHoles.length > 0) {
                    this.blackHoles.forEach(bh => {
                        ctx.save();
                        ctx.translate(bh.x, bh.y);

                        // Accretion disk
                        ctx.beginPath();
                        ctx.strokeStyle = 'orange';
                        ctx.lineWidth = 2;
                        ctx.arc(0, 0, bh.size * 1.5, 0, Math.PI * 2);
                        ctx.stroke();

                        // Event Horizon
                        ctx.beginPath();
                        ctx.fillStyle = 'black';
                        ctx.arc(0, 0, bh.size, 0, Math.PI * 2);
                        ctx.fill();

                        // Glow
                        ctx.shadowColor = 'purple';
                        ctx.shadowBlur = 20;
                        ctx.stroke();
                        ctx.shadowBlur = 0;

                        ctx.restore();
                    });
                }

                // 3. Planets (with zoom-based detail)
                if (this.planets && this.planets.length > 0) {
                    const zoom = this.camera.zoom;
                    this.planets.forEach(p => {
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.axialTilt);

                        const screenRadius = p.radius * zoom;
                        const detailLevel = Math.min(3, Math.floor(screenRadius / 30)); // 0-3 detail levels

                        // Draw rings behind (if at angle)
                        if (p.hasRings && p.axialTilt < 0) {
                            this.drawPlanetRings(ctx, p, screenRadius);
                        }

                        // Atmospheric glow (outer)
                        if (p.hasAtmosphere) {
                            const atmosGrad = ctx.createRadialGradient(0, 0, p.radius * 0.95, 0, 0, p.radius * 1.15);
                            atmosGrad.addColorStop(0, 'transparent');
                            atmosGrad.addColorStop(0.5, p.atmosphereColor + '40');
                            atmosGrad.addColorStop(1, 'transparent');
                            ctx.fillStyle = atmosGrad;
                            ctx.beginPath();
                            ctx.arc(0, 0, p.radius * 1.15, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Planet body with 3D gradient
                        const bodyGrad = ctx.createRadialGradient(
                            -p.radius * 0.3, -p.radius * 0.3, 0,
                            0, 0, p.radius
                        );
                        bodyGrad.addColorStop(0, p.secondaryColor);
                        bodyGrad.addColorStop(0.4, p.baseColor);
                        bodyGrad.addColorStop(0.8, p.tertiaryColor);
                        bodyGrad.addColorStop(1, '#000000');

                        ctx.fillStyle = bodyGrad;
                        ctx.beginPath();
                        ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
                        ctx.fill();

                        // Surface texture (procedural bands/patterns based on zoom)
                        if (detailLevel >= 1) {
                            ctx.globalAlpha = 0.3;
                            ctx.strokeStyle = p.tertiaryColor;
                            ctx.lineWidth = 2 / zoom;

                            // Draw bands for gas giants
                            if (p.type === 'gas-giant' || p.type === 'ice-giant') {
                                for (let i = -4; i <= 4; i++) {
                                    const bandY = p.radius * (i * 0.15);
                                    const bandWidth = Math.sqrt(p.radius * p.radius - bandY * bandY);
                                    if (bandWidth > 0) {
                                        ctx.beginPath();
                                        ctx.ellipse(0, bandY, bandWidth, 3, 0, 0, Math.PI * 2);
                                        ctx.stroke();
                                    }
                                }
                            }

                            // Draw continents for terrestrial/ocean
                            if ((p.type === 'terrestrial' || p.type === 'ocean') && detailLevel >= 2) {
                                ctx.fillStyle = p.type === 'ocean' ? p.baseColor : p.secondaryColor;
                                const seed = p.textureSeed;
                                for (let j = 0; j < 5; j++) {
                                    const cx = Math.cos(seed + j * 1.2) * p.radius * 0.5;
                                    const cy = Math.sin(seed * 0.7 + j) * p.radius * 0.4;
                                    const cr = p.radius * (0.15 + Math.sin(seed + j) * 0.1);
                                    ctx.beginPath();
                                    ctx.arc(cx, cy, cr, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                            ctx.globalAlpha = 1;
                        }

                        // Shadow side
                        const shadowGrad = ctx.createLinearGradient(-p.radius, 0, p.radius, 0);
                        shadowGrad.addColorStop(0, 'transparent');
                        shadowGrad.addColorStop(0.6, 'transparent');
                        shadowGrad.addColorStop(1, 'rgba(0,0,0,0.6)');
                        ctx.fillStyle = shadowGrad;
                        ctx.beginPath();
                        ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw rings in front (if at angle)
                        if (p.hasRings && p.axialTilt >= 0) {
                            this.drawPlanetRings(ctx, p, screenRadius);
                        }

                        ctx.restore();
                    });
                }
            }

            // Helper method for drawing planet rings
            drawPlanetRings(ctx, planet, screenRadius) {
                const p = planet;
                ctx.strokeStyle = p.ringColor;
                ctx.lineWidth = (p.ringOuterRadius - p.ringInnerRadius) * 0.3;
                ctx.globalAlpha = 0.6;

                // Multiple ring bands
                for (let i = 0; i < 3; i++) {
                    const ringR = p.ringInnerRadius + (p.ringOuterRadius - p.ringInnerRadius) * (i / 3 + 0.15);
                    ctx.beginPath();
                    ctx.ellipse(0, 0, ringR, ringR * 0.2, 0, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }

            drawStarShape(ctx, x, y, r) {
                ctx.beginPath();
                const pr = r * 0.5;
                ctx.moveTo(x, y - r);
                ctx.lineTo(x + pr, y - pr);
                ctx.lineTo(x + r, y);
                ctx.lineTo(x + pr, y + pr);
                ctx.lineTo(x, y + r);
                ctx.lineTo(x - pr, y + pr);
                ctx.lineTo(x - r, y);
                ctx.lineTo(x - pr, y - pr);
                ctx.closePath();
                ctx.fill();
            }

            // Get the center point of all stars (constellation center)
            getConstellationCenter() {
                if (this.stars.length === 0) {
                    return { x: this.canvas.width / 2, y: this.canvas.height / 2, z: 0 };
                }
                let sumX = 0, sumY = 0, sumZ = 0;
                this.stars.forEach(s => {
                    sumX += s.x;
                    sumY += s.y;
                    sumZ += (s.z || 0);
                });
                return {
                    x: sumX / this.stars.length,
                    y: sumY / this.stars.length,
                    z: sumZ / this.stars.length
                };
            }

            // 3D Rotation: Rotate a point around a given center
            rotate3D(x, y, z, centerX, centerY) {
                // Convert degrees to radians
                const radX = this.rotationX * Math.PI / 180;
                const radY = this.rotationY * Math.PI / 180;
                const radZ = this.rotationZ * Math.PI / 180;

                // Translate to origin (center of view)
                let px = x - centerX;
                let py = y - centerY;
                let pz = z;

                // Rotation around X axis
                let y1 = py * Math.cos(radX) - pz * Math.sin(radX);
                let z1 = py * Math.sin(radX) + pz * Math.cos(radX);
                py = y1;
                pz = z1;

                // Rotation around Y axis
                let x1 = px * Math.cos(radY) + pz * Math.sin(radY);
                z1 = -px * Math.sin(radY) + pz * Math.cos(radY);
                px = x1;
                pz = z1;

                // Rotation around Z axis
                x1 = px * Math.cos(radZ) - py * Math.sin(radZ);
                y1 = px * Math.sin(radZ) + py * Math.cos(radZ);
                px = x1;
                py = y1;

                // Simple perspective projection (optional depth effect)
                const fov = 800;
                const scale = fov / (fov + pz);

                // Translate back
                return {
                    x: px * scale + centerX,
                    y: py * scale + centerY,
                    scale: scale
                };
            }

            // Inverse 3D Rotation: Project screen point back to 3D world (at Z=0 plane relative to rotation)
            inverseRotate3D(x, y, centerX, centerY) {
                // Negate angles for inverse rotation
                const radX = -this.rotationX * Math.PI / 180;
                const radY = -this.rotationY * Math.PI / 180;
                const radZ = -this.rotationZ * Math.PI / 180;

                // Translate to origin
                let px = x - centerX;
                let py = y - centerY;
                let pz = 0; // Assume we are clicking on the plane passing through center

                // Inverse Order: X^-1( Y^-1( Z^-1( P ) ) )
                // Note: Forward was RotZ(RotY(RotX(P))). Inverse is RotXinv(RotYinv(RotZinv(P))).

                // 1. Inverse Z Rotation
                let x1 = px * Math.cos(radZ) - py * Math.sin(radZ);
                let y1 = px * Math.sin(radZ) + py * Math.cos(radZ);
                px = x1;
                py = y1;

                // 2. Inverse Y Rotation
                x1 = px * Math.cos(radY) + pz * Math.sin(radY);
                let z1 = -px * Math.sin(radY) + pz * Math.cos(radY);
                px = x1;
                pz = z1;

                // 3. Inverse X Rotation
                y1 = py * Math.cos(radX) - pz * Math.sin(radX);
                z1 = py * Math.sin(radX) + pz * Math.cos(radX);
                py = y1;
                pz = z1;

                // Translate back
                return {
                    x: px + centerX,
                    y: py + centerY,
                    z: pz
                };
            }

            // Reset rotation sliders and values
            resetRotation() {
                this.rotationX = 0;
                this.rotationY = 0;
                this.rotationZ = 0;

                const xSlider = document.getElementById('rotXSlider');
                const ySlider = document.getElementById('rotYSlider');
                const zSlider = document.getElementById('rotZSlider');

                if (xSlider) { xSlider.value = 0; document.getElementById('rotXValue').textContent = '0Â°'; }
                if (ySlider) { ySlider.value = 0; document.getElementById('rotYValue').textContent = '0Â°'; }
                if (zSlider) { zSlider.value = 0; document.getElementById('rotZValue').textContent = '0Â°'; }
            }

            calculateGeometry() {
                const lines = [];
                const adj = {};
                this.stars.forEach(s => adj[s.id] = []);

                for (let i = 0; i < this.stars.length; i++) {
                    for (let j = i + 1; j < this.stars.length; j++) {
                        const s1 = this.stars[i];
                        const s2 = this.stars[j];
                        const dist = Math.hypot(s1.x - s2.x, s1.y - s2.y);

                        if (dist < this.config.maxConnectDist) {
                            lines.push({ s1, s2, dist });
                            adj[s1.id].push(s2.id);
                            adj[s2.id].push(s1.id);
                        }
                    }
                }

                // BFS for clusters
                const clusters = [];
                const visited = new Set();
                this.stars.forEach(star => {
                    if (!visited.has(star.id)) {
                        const cluster = [];
                        const queue = [star.id];
                        visited.add(star.id);
                        while (queue.length) {
                            const id = queue.shift();
                            const s = this.stars.find(x => x.id === id);
                            if (s) cluster.push(s);
                            adj[id].forEach(nid => {
                                if (!visited.has(nid)) {
                                    visited.add(nid);
                                    queue.push(nid);
                                }
                            });
                        }
                        if (cluster.length > 0) clusters.push(cluster);
                    }
                });

                return { lines, clusters };
            }

            showToast(msg) {
                const t = document.getElementById('toast');
                t.innerText = msg;
                t.classList.add('visible');
                setTimeout(() => t.classList.remove('visible'), 2000);
            }

            downloadSVG() {
                if (this.stars.length === 0) {
                    this.showToast("Universe is empty!");
                    return;
                }

                // Ensure cluster IDs are assigned for naming in SVG
                this.refreshClusterAssignments();

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                this.stars.forEach(s => {
                    minX = Math.min(minX, s.x); minY = Math.min(minY, s.y);
                    maxX = Math.max(maxX, s.x); maxY = Math.max(maxY, s.y);
                });

                const pad = 100;
                const w = (maxX - minX) + pad * 2;
                const h = (maxY - minY) + pad * 2;
                const vbX = minX - pad;
                const vbY = minY - pad;

                const { lines, clusters } = this.calculateGeometry();

                let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vbX} ${vbY} ${w} ${h}" style="background:#020205">
            <rect x="${vbX}" y="${vbY}" width="${w}" height="${h}" fill="#020205"/>`;

                // Lines
                lines.forEach(l => {
                    const op = (1 - (l.dist / this.config.maxConnectDist)).toFixed(2);
                    const [r, g, b] = this.hexToRgb(this.getStarColor(l.s1));
                    svg += `<line x1="${l.s1.x}" y1="${l.s1.y}" x2="${l.s2.x}" y2="${l.s2.y}" stroke="rgb(${r}, ${g}, ${b})" stroke-width="1.5" stroke-linecap="round" opacity="${op * 0.8}"/>`;
                });

                // Labels
                clusters.forEach(c => {
                    const name = String(c[0].clusterId);
                    if (c.length < this.config.minGroupSize || name === String(c[0].id)) return;

                    let cx = 0, cy = 0; c.forEach(s => { cx += s.x; cy += s.y }); cx /= c.length; cy /= c.length;
                    const color = this.getStarColor(c[0]);
                    svg += `<text x="${cx}" y="${cy + 30}" font-family="sans-serif" font-size="14" fill="${color}" text-anchor="middle" font-weight="600">${name}</text>`;
                });

                // Stars
                this.stars.forEach(s => {
                    const color = this.getStarColor(s);
                    const r = this.config.starBaseRad * 1.5;

                    // Star Shape
                    const pr = r * 0.5;
                    const pathData = `M${s.x} ${s.y - r} L${s.x + pr} ${s.y - pr} L${s.x + r} ${s.y} L${s.x + pr} ${s.y + pr} L${s.x} ${s.y + r} L${s.x - pr} ${s.y + pr} L${s.x - r} ${s.y} L${s.x - pr} ${s.y - pr} Z`;
                    svg += `<path d="${pathData}" fill="${color}" opacity="0.8"/>`;

                    // Core dot
                    svg += `<circle cx="${s.x}" cy="${s.y}" r="1.5" fill="white" />`;
                });

                svg += `</svg>`;

                // FileSaver-style download for Chrome compatibility
                const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
                const filename = `AetherMap-${Date.now()}.svg`;

                // Try using msSaveBlob for IE/Edge compatibility
                if (typeof window.navigator.msSaveBlob !== 'undefined') {
                    window.navigator.msSaveBlob(blob, filename);
                    this.showToast("Map Exported");
                    return;
                }

                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;

                // Dispatch a real click event instead of calling click()
                const event = new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true
                });
                link.dispatchEvent(event);

                // Clean up after a delay
                setTimeout(() => {
                    window.URL.revokeObjectURL(url);
                }, 1000);

                this.showToast("Map Exported");
            }

            // Trigger the hidden file input for loading SVG
            triggerLoadSVG() {
                document.getElementById('svgFileInput').click();
            }

            // Load and parse an SVG file to restore stars
            loadSVG(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const svgContent = e.target.result;
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(svgContent, 'image/svg+xml');

                        // Find all path elements (stars)
                        const pathElements = doc.querySelectorAll('path[fill][opacity]');

                        if (pathElements.length === 0) {
                            this.showToast("No stars found in SVG");
                            return;
                        }

                        // Clear current stars and history
                        this.stars = [];
                        this.history = [];

                        // Parse each path to extract star data
                        pathElements.forEach((path, index) => {
                            const d = path.getAttribute('d');
                            const fill = path.getAttribute('fill');

                            // Parse path: M{x} {y-r} L...
                            const match = d.match(/M([-\d.]+)\s+([-\d.]+)/);
                            if (match) {
                                const topX = parseFloat(match[1]);
                                const topY = parseFloat(match[2]);
                                const r = this.config.starBaseRad * 1.5;
                                const y = topY + r;

                                this.stars.push({
                                    id: Date.now() + index,
                                    x: topX,
                                    y: y,
                                    color: fill,
                                    phase: Math.random() * Math.PI * 2,
                                    clusterId: null
                                });
                            }
                        });

                        event.target.value = '';
                        this.showToast(`Loaded ${this.stars.length} stars`);
                        this.draw();
                    } catch (err) {
                        console.error('Error parsing SVG:', err);
                        this.showToast("Error loading SVG file");
                    }
                };
                reader.readAsText(file);
            }

            // Export canvas animation as video
            exportVideo() {
                if (this._isRecording) {
                    this.showToast("Already recording...");
                    return;
                }

                // Get selected duration
                const durationSelect = document.getElementById('videoDuration');
                const duration = durationSelect ? parseInt(durationSelect.value) : 5000;
                const durationSec = duration / 1000;

                this._isRecording = true;
                const btn = document.getElementById('exportVideoBtn');
                if (btn) btn.classList.add('active');

                this.showToast(`Recording ${durationSec} seconds...`);

                const stream = this.canvas.captureStream(30);
                const chunks = [];

                const mimeType = MediaRecorder.isTypeSupported('video/webm;codecs=vp9')
                    ? 'video/webm;codecs=vp9'
                    : 'video/webm';

                const recorder = new MediaRecorder(stream, { mimeType });

                recorder.ondataavailable = (e) => {
                    if (e.data.size > 0) chunks.push(e.data);
                };

                recorder.onstop = () => {
                    this._isRecording = false;
                    if (btn) btn.classList.remove('active');

                    const blob = new Blob(chunks, { type: mimeType });
                    const filename = `Interstellar-${Date.now()}.webm`;
                    const url = window.URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;

                    // Dispatch a real click event for Chrome compatibility
                    const event = new MouseEvent('click', {
                        view: window,
                        bubbles: true,
                        cancelable: true
                    });
                    link.dispatchEvent(event);

                    // Clean up after a delay
                    setTimeout(() => {
                        window.URL.revokeObjectURL(url);
                    }, 1000);

                    this.showToast("Video exported!");
                };

                recorder.onerror = (e) => {
                    this._isRecording = false;
                    if (btn) btn.classList.remove('active');
                    console.error('Recording error:', e);
                    this.showToast("Recording failed");
                };

                recorder.start();

                setTimeout(() => {
                    if (recorder.state === 'recording') {
                        recorder.stop();
                    }
                }, duration);
            }
        }

        const app = new AetherEngine();
    </script>
</body>

</html>