<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aether Map | Pre-Placement Cartographer</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Exo+2:wght@300;600&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-deep: #020205;
            --glass: rgba(16, 20, 30, 0.85);
            --glass-border: rgba(100, 220, 255, 0.2);
            --accent: #00f3ff;
            --accent-glow: rgba(0, 243, 255, 0.4);
            --text-main: #e0faff;
            --text-dim: #5c7a8a;
            --bar-height: 52px;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-deep);
            font-family: 'Exo 2', sans-serif;
            color: var(--text-main);
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            touch-action: none;
            /* Prevents scrolling on mobile while drawing */
        }

        /* --- HUD UI --- */
        .hud {
            position: absolute;
            z-index: 10;
            padding: 16px;
            pointer-events: none;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-panel {
            pointer-events: auto;
            background: var(--glass);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        /* Top Left Info */
        .info-panel {
            align-self: flex-start;
            padding: 20px 24px;
            max-width: 320px;
        }

        h1 {
            margin: 0;
            font-family: 'Cinzel', serif;
            font-size: 22px;
            color: var(--accent);
            text-shadow: 0 0 15px var(--accent-glow);
            letter-spacing: 2px;
        }

        p.subtitle {
            margin: 8px 0 0;
            font-size: 13px;
            color: var(--text-dim);
            line-height: 1.5;
        }

        /* Left Side Color Controls (below info panel) */
        #colorControls {
            position: absolute;
            top: 190px;
            left: 20px;
            align-self: flex-start;
            padding: 15px;
            max-width: 280px;
            display: flex;
            flex-direction: column;
        }

        #colorControls h2 {
            font-size: 16px;
            margin: 0 0 10px 0;
            color: var(--accent);
            text-shadow: none;
            text-transform: uppercase;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            align-items: center;
        }

        .color-input-container {
            position: relative;
            flex-shrink: 0;
        }

        #colorInput {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            border: 1px solid var(--glass-border);
            padding: 0;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            border-radius: 8px;
            overflow: hidden;
            flex-shrink: 0;
        }

        /* Customize the color swatch appearance within the native input */
        #colorInput::-webkit-color-swatch {
            border: 2px solid white;
            border-radius: 6px;
        }

        #colorInput::-moz-color-swatch {
            border: 2px solid white;
            border-radius: 6px;
        }

        /* General Small Button Styling */
        .btn-small {
            flex-grow: 1;
            padding: 10px 12px;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            color: var(--text-main);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn-small:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Active Color Mode Indicator */
        .color-mode-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent);
            border: 2px solid var(--bg-deep);
            box-shadow: 0 0 10px var(--accent);
            opacity: 0;
            transition: opacity 0.2s, background 0.2s;
        }

        .color-mode-indicator.active {
            opacity: 1;
        }

        #rainbowBtn.active {
            background: #ff0077;
            border-color: #ff0077;
            color: #fff;
            box-shadow: 0 0 15px #ff0077;
        }

        /* Active Background Toggle Styling */
        .bg-toggle.active {
            background: var(--accent);
            color: var(--bg-deep);
            border-color: var(--accent);
            box-shadow: 0 0 10px var(--accent-glow);
        }

        /* Active Button Small Styling (for Warp, Drift, Colors buttons) */
        .btn-small.active {
            background: var(--accent);
            color: var(--bg-deep);
            border-color: var(--accent);
            box-shadow: 0 0 15px var(--accent-glow);
        }

        /* Bottom Left Tools */
        .toolbar {
            align-self: flex-start;
            margin-bottom: 20px;
            margin-left: 20px;
            display: flex;
            gap: 12px;
            padding: 10px;
            border-radius: 16px;
        }

        .btn {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid transparent;
            color: var(--text-main);
            width: 48px;
            height: 48px;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            position: relative;
        }

        .btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
            filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.5));
        }

        .btn:hover {
            background: rgba(0, 243, 255, 0.1);
            border-color: var(--accent-glow);
            transform: translateY(-2px);
            color: var(--accent);
            box-shadow: 0 0 15px var(--accent-glow);
        }

        .btn:active {
            transform: translateY(1px);
        }

        /* Active button style for selection mode */
        .btn.active {
            background: var(--accent);
            color: var(--bg-deep);
            border-color: var(--accent);
            box-shadow: 0 0 20px var(--accent);
            transform: none;
        }

        .btn.active:hover {
            background: var(--accent);
            color: var(--bg-deep);
        }


        /* Tooltip */
        .btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 115%;
            left: 50%;
            transform: translateX(-50%);
            background: #000;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            border: 1px solid #333;
        }

        .btn:hover::after {
            opacity: 1;
        }

        /* Zoom Controls (Left) */
        .zoom-controls {
            position: absolute;
            left: 20px;
            bottom: 100px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: auto;
        }

        .zoom-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: var(--text-main);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: 0.2s;
        }

        .zoom-btn:hover {
            background: var(--accent);
            color: #000;
        }

        /* Stats */
        .stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 11px;
            font-family: monospace;
            color: var(--text-dim);
            pointer-events: none;
        }

        /* Modal & Toast (unchanged) */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal {
            background: #0f1219;
            border: 1px solid var(--accent);
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.15);
            max-width: 300px;
        }

        .modal h2 {
            margin-top: 0;
            color: #fff;
            font-family: 'Cinzel', serif;
        }

        .modal-actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .btn-primary {
            background: var(--accent);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        .btn-secondary {
            background: transparent;
            color: #aaa;
            border: 1px solid #333;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn-secondary:hover {
            border-color: #666;
            color: #fff;
        }

        .toast {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            background: rgba(0, 243, 255, 0.15);
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 8px 24px;
            border-radius: 30px;
            font-size: 12px;
            font-weight: 600;
            opacity: 0;
            transition: all 0.3s;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* HUD Panels */
        #bgControls {
            position: absolute;
            top: 330px;
            left: 20px;
            padding: 15px;
            max-width: 280px;
        }

        #rotationControls {
            position: absolute;
            top: 330px;
            right: 20px;
            padding: 15px;
            max-width: 200px;
        }

        /* Responsive Controls */
        @media (max-width: 768px) {
            .hud-panel.info-panel {
                top: 10px;
                left: 10px;
                max-width: 180px;
            }

            .hud-panel.toolbar {
                width: 95%;
                padding: 4px;
                gap: 4px;
                flex-wrap: wrap;
                justify-content: center;
                bottom: 10px;
            }

            #rotationControls {
                top: auto;
                bottom: 80px;
                right: 10px;
                max-width: 150px;
                /* Smaller width for mobile */
            }

            #bgControls {
                display: none;
                /* Hide non-essential controls on small screens */
            }
        }

        @media (max-width: 480px) {
            .hud-panel h1 {
                font-size: 16px;
            }

            .btn {
                padding: 6px;
            }

            .btn svg {
                width: 18px;
                height: 18px;
            }
        }

        /* === TOP BAR - Enhanced Glassmorphism === */
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--bar-height);
            background: rgba(10, 15, 25, 0.65);
            backdrop-filter: blur(24px) saturate(1.2);
            -webkit-backdrop-filter: blur(24px) saturate(1.2);
            border-bottom: 1px solid rgba(100, 220, 255, 0.12);
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            padding: 0 20px;
            z-index: 100;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .top-bar h1 {
            margin: 0;
            font-family: 'Cinzel', serif;
            font-size: 15px;
            color: var(--accent);
            text-shadow: 0 0 15px var(--accent-glow);
            letter-spacing: 1.5px;
            white-space: nowrap;
        }

        .top-bar-center {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            flex-wrap: nowrap;
        }

        /* Visual group - Frosted Glass Pods */
        .bar-group {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.04);
            backdrop-filter: blur(8px);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04), 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .bar-group+.bar-group {
            margin-left: 4px;
        }

        .top-bar-right {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: flex-end;
        }

        /* === BOTTOM BAR - Enhanced Glassmorphism === */
        .bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: var(--bar-height);
            background: rgba(10, 15, 25, 0.65);
            backdrop-filter: blur(24px) saturate(1.2);
            -webkit-backdrop-filter: blur(24px) saturate(1.2);
            border-top: 1px solid rgba(100, 220, 255, 0.12);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
            box-shadow: 0 -4px 30px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .bottom-bar-left,
        .bottom-bar-center,
        .bottom-bar-right {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .bottom-bar-center {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        /* Bottom bar tool buttons - Glassmorphic */
        .bottom-bar .btn {
            background: rgba(255, 255, 255, 0.06);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(100, 220, 255, 0.15);
            width: 40px;
            height: 40px;
            border-radius: 10px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
            transition: all 0.2s ease;
        }

        .bottom-bar .btn:hover {
            background: rgba(0, 243, 255, 0.12);
            border-color: rgba(0, 243, 255, 0.4);
            box-shadow: 0 0 20px var(--accent-glow), inset 0 1px 0 rgba(255, 255, 255, 0.08);
            transform: translateY(-1px);
        }

        /* Zoom buttons - Glassmorphic Circles */
        .bottom-bar .zoom-btn {
            width: 32px;
            height: 32px;
            font-size: 15px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.06);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(100, 220, 255, 0.18);
            border-radius: 50%;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
            transition: all 0.2s ease;
        }

        .bottom-bar .zoom-btn:hover {
            background: rgba(0, 243, 255, 0.15);
            border-color: var(--accent);
            box-shadow: 0 0 15px var(--accent-glow);
        }

        /* === REGENERATE BUTTON - Make it stand out === */
        .btn-regen {
            background: linear-gradient(135deg, rgba(0, 243, 255, 0.15) 0%, rgba(0, 180, 220, 0.1) 100%) !important;
            border: 1px solid rgba(0, 243, 255, 0.4) !important;
            color: var(--accent) !important;
            font-size: 15px;
            min-width: 32px;
            transition: all 0.25s ease;
        }

        .btn-regen:hover {
            background: linear-gradient(135deg, rgba(0, 243, 255, 0.3) 0%, rgba(0, 180, 220, 0.2) 100%) !important;
            border-color: var(--accent) !important;
            box-shadow: 0 0 20px var(--accent-glow), inset 0 0 10px rgba(0, 243, 255, 0.1) !important;
            transform: rotate(90deg);
        }

        /* === IMPROVED DIVIDER === */
        .divider {
            width: 1px;
            height: 28px;
            background: linear-gradient(180deg, transparent 0%, rgba(100, 220, 255, 0.3) 50%, transparent 100%);
            margin: 0 4px;
        }

        /* === POPUP PANELS === */
        .popup-panel {
            position: fixed;
            background: var(--glass);
            backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 10px 0 0 10px;
            padding: 10px;
            z-index: 150;
            width: 110px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
            overflow-x: hidden;
            max-height: calc(100vh - var(--bar-height) - 80px);
        }

        .popup-panel.hidden {
            display: none;
        }

        .popup-panel h3 {
            margin: 0 0 8px 0;
            font-size: 10px;
            color: var(--accent);
            text-transform: uppercase;
            position: sticky;
            top: -10px;
            background: var(--glass);
            padding: 5px 0;
            z-index: 1;
        }

        #matrixPanel {
            top: calc(var(--bar-height) + 8px);
            right: 0;
            max-height: calc(50vh - var(--bar-height) - 20px);
        }

        #rotationPanel {
            bottom: calc(var(--bar-height) + 8px);
            right: 0;
            top: auto;
            max-height: calc(50vh - var(--bar-height) - 20px);
        }

        .color-picker-mini {
            width: 28px;
            height: 28px;
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            cursor: pointer;
            padding: 0;
        }

        /* Star color pickers - just the color boxes, no border */
        .color-picker-mini.star-color {
            border: none;
            border-radius: 2px;
            width: 20px;
            height: 20px;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background: none;
            cursor: pointer;
        }

        .color-picker-mini.star-color::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-picker-mini.star-color::-webkit-color-swatch {
            border: none;
            border-radius: 2px;
        }

        .color-picker-mini.star-color::-moz-color-swatch {
            border: none;
            border-radius: 2px;
        }

        /* Star colors group - no background/border, just the label and boxes */
        .star-colors-group {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 0 8px;
        }

        .star-colors-label {
            font-size: 9px;
            text-transform: uppercase;
            color: var(--text-dim);
            letter-spacing: 0.5px;
            margin-right: 4px;
        }

        /* ========== FLIGHT MODE HUD ========== */
        .flight-hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            pointer-events: none;
        }

        .flight-hud.hidden {
            display: none;
        }

        .hud-controls,
        .hud-speed,
        .hud-inventory,
        .hud-leaderboard {
            background: linear-gradient(135deg, rgba(0, 15, 30, 0.9) 0%, rgba(0, 30, 50, 0.85) 100%);
            border: 2px solid rgba(0, 243, 255, 0.4);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .hud-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            min-width: 220px;
        }

        .hud-speed {
            position: absolute;
            top: 20px;
            right: 20px;
            min-width: 180px;
            text-align: center;
        }

        .hud-inventory {
            position: absolute;
            bottom: 20px;
            left: 20px;
            min-width: 300px;
            max-height: 300px;
            overflow-y: auto;
        }

        .hud-leaderboard {
            position: absolute;
            bottom: 20px;
            right: 20px;
            min-width: 250px;
        }

        .hud-controls h3,
        .hud-inventory h3,
        .hud-leaderboard h3 {
            margin: 0 0 12px 0;
            font-size: 16px;
            color: #00f3ff;
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.8);
            letter-spacing: 2px;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 6px 0;
            font-size: 13px;
            color: #e0faff;
        }

        .control-row kbd {
            display: inline-block;
            padding: 4px 8px;
            background: linear-gradient(180deg, #1a2a3a 0%, #0f1f2f 100%);
            border: 1px solid rgba(0, 243, 255, 0.5);
            border-radius: 4px;
            font-size: 12px;
            min-width: 24px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .speed-label {
            font-size: 12px;
            color: #5c7a8a;
            letter-spacing: 2px;
        }

        .speed-value {
            font-size: 42px;
            font-weight: bold;
            color: #00f3ff;
            text-shadow: 0 0 15px rgba(0, 243, 255, 0.8);
            margin: 8px 0;
        }

        .speed-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 50, 80, 0.5);
            border-radius: 4px;
            overflow: hidden;
            margin: 12px 0 8px 0;
        }

        .speed-fill {
            height: 100%;
            background: linear-gradient(90deg, #00f3ff 0%, #00a8ff 50%, #0080ff 100%);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.8);
            transition: width 0.1s;
            width: 0%;
        }

        .speed-max {
            font-size: 10px;
            color: #5c7a8a;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }

        .inventory-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            background: rgba(0, 50, 80, 0.3);
            border: 1px solid rgba(0, 243, 255, 0.2);
            border-radius: 6px;
            font-size: 12px;
        }

        .inventory-item .name {
            color: #e0faff;
            font-weight: bold;
        }

        .inventory-item .count {
            color: #00f3ff;
            font-size: 14px;
        }

        .total-value {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 243, 255, 0.3);
            text-align: right;
            font-size: 16px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        }

        .leaderboard-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: rgba(0, 50, 80, 0.3);
            border: 1px solid rgba(0, 243, 255, 0.2);
            border-radius: 6px;
            font-size: 13px;
        }

        .leaderboard-entry.rank-1 {
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.2) 0%, rgba(0, 50, 80, 0.3) 100%);
            border-color: rgba(255, 215, 0, 0.5);
        }

        .leaderboard-entry .wealth {
            color: #ffd700;
            font-weight: bold;
        }

        /* Gem Icons */
        .gem-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            vertical-align: middle;
        }

        /* Floating Windows (Map & Leaders) */
        .floating-window {
            position: fixed;
            z-index: 50;
            background: rgba(10, 20, 30, 0.9);
            border: 1px solid rgba(0, 243, 255, 0.4);
            border-radius: 8px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .floating-window.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
        }

        .map-window {
            bottom: 15px;
            left: 15px;
            width: 200px;
            height: 150px;
        }

        .leaders-window {
            bottom: 100px;
            /* Above mobile toggle */
            right: 15px;
            width: 220px;
            max-height: 250px;
        }

        .window-header {
            background: rgba(0, 243, 255, 0.15);
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(0, 243, 255, 0.2);
            cursor: grab;
        }

        .window-content {
            padding: 10px;
            overflow-y: auto;
            flex: 1;
        }

        /* Specific Button Styles */
        .btn-sell-all {
            background: linear-gradient(90deg, #ff3333, #aa0000);
            border: 1px solid #ff5555;
            color: white;
            font-weight: bold;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .btn-sell-all:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(255, 50, 50, 0.5);
        }

        /* Ship Selection Modal */
        .ship-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .ship-option {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
            text-align: left;
        }

        .ship-option:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--accent);
        }

        .ship-option h3 {
            margin: 0 0 5px 0;
            color: var(--accent);
        }

        .ship-option p {
            margin: 0;
            font-size: 0.9em;
            color: #aaa;
        }

        /* ===== COCKPIT BAR (Above Bottom Bar) ===== */
        /* ===== COCKPIT BAR (Removed Container - Now separate floating items) ===== */
        /* --- FLIGHT HUD (Command Center) --- */
        .flight-hud {
            position: fixed;
            top: 60px;
            /* Below top bar */
            left: 0;
            width: 100%;
            height: calc(100% - 140px);
            /* Above bottom bar */
            pointer-events: none;
            /* Let clicks pass through to canvas */
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            /* Left Panel, Space, Right Panel */
            grid-template-rows: 1fr auto;
            /* Content, Bottom Gems */
            grid-template-areas:
                "left center right"
                "bottom bottom bottom";
            gap: 20px;
            padding: 20px;
            z-index: 20;
        }

        .hud-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
            /* Re-enable clicks for UI */
        }

        .hud-left {
            grid-area: left;
        }

        .hud-center {
            grid-area: center;
            display: flex;
            justify-content: center;
            align-items: flex-end;
        }

        .hud-right {
            grid-area: right;
        }

        .hud-bottom {
            grid-area: bottom;
            display: flex;
            justify-content: center;
            pointer-events: auto;
            max-height: 200px;
        }

        .cockpit-section {
            background: rgba(16, 24, 32, 0.85);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: 8px;
            color: #fff;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            width: 100%;
            /* Reset absolute positioning */
            position: static;
            min-width: 0;
            margin: 0;
        }



        /* Initial Positions Removed - Using Grid Layout */

        .cockpit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            /* Changed to move for dragging */
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(0, 243, 255, 0.2);
            padding: 6px 10px;
            border-radius: 10px 10px 0 0;
        }

        .cockpit-content {
            padding: 8px 12px;
        }

        .cockpit-section {
            background: rgba(0, 20, 40, 0.6);
            border: 1px solid rgba(0, 243, 255, 0.2);
            border-radius: 8px;
            padding: 8px 12px;
            min-width: 100px;
        }

        .cockpit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            margin-bottom: 6px;
        }

        .cockpit-header h4 {
            margin: 0;
            font-size: 10px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .cockpit-toggle {
            font-size: 8px;
            color: var(--accent);
            transition: transform 0.2s;
        }

        .cockpit-section.collapsed .cockpit-content {
            display: none;
        }

        .cockpit-section.collapsed {
            min-height: 0;
            padding-bottom: 2px;
        }

        .cockpit-section.collapsed .cockpit-toggle {
            transform: rotate(-90deg);
        }

        /* Controls Section */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
        }

        .controls-grid kbd {
            padding: 4px 6px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: 4px;
            font-size: 10px;
            text-align: center;
            color: var(--accent);
        }

        /* Radar Section */
        .radar-container {
            position: relative;
            width: 80px;
            height: 80px;
        }

        .radar-canvas {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 30, 20, 0.9) 0%, rgba(0, 10, 5, 0.95) 100%);
            border: 2px solid rgba(0, 243, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3), inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .radar-sweep {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50%;
            height: 2px;
            background: linear-gradient(90deg, rgba(0, 255, 100, 0.8) 0%, transparent 100%);
            transform-origin: left center;
            animation: radarSweep 3s linear infinite;
        }

        @keyframes radarSweep {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .radar-coords {
            font-size: 9px;
            color: rgba(0, 243, 255, 0.7);
            text-align: center;
            margin-top: 4px;
        }

        /* Velocity Section */
        .velocity-display {
            text-align: center;
        }

        .speed-gauge {
            position: relative;
            width: 60px;
            height: 60px;
            margin: 0 auto;
        }

        .speed-number {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            font-weight: bold;
            color: #00f3ff;
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.5);
        }

        .speed-unit {
            font-size: 8px;
            color: rgba(0, 243, 255, 0.6);
            text-align: center;
            margin-top: 2px;
        }

        .cockpit-zoom-controls {
            display: flex;
            gap: 4px;
            justify-content: center;
            margin-top: 6px;
            align-items: center;
        }

        .cockpit-zoom-controls .zoom-btn {
            width: 22px;
            height: 22px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: 4px;
            color: var(--accent);
            cursor: pointer;
        }

        .cockpit-zoom-controls .zoom-value {
            font-size: 10px;
            color: rgba(0, 243, 255, 0.8);
            min-width: 30px;
            text-align: center;
        }

        /* Gems Section - Expands horizontally to the right */
        .gems-section {
            min-width: 140px;
            max-width: none;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
        }

        .gems-grid {
            display: flex;
            flex-wrap: wrap;
            /* Allow wrapping to multiple rows */
            gap: 6px;
            max-width: 600px;
            /* Increased from 300px to show more gems */
            max-height: 120px;
            /* Limit height */
            overflow-x: auto;
            overflow-y: auto;
            /* Allow vertical scroll if needed */
            padding-bottom: 4px;
        }

        .gems-grid::-webkit-scrollbar {
            height: 3px;
        }

        .gems-grid::-webkit-scrollbar-thumb {
            background: rgba(0, 243, 255, 0.3);
            border-radius: 2px;
        }

        .gems-grid::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        .gem-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
            font-size: 14px;
            /* Increased from 10px */
            white-space: nowrap;
            flex-shrink: 0;
        }

        .gem-emoji {
            font-size: 14px;
        }

        .gem-count {
            color: #fff;
            font-weight: bold;
            font-size: 13px;
            /* Larger count */
        }

        .gems-total {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
            /* Increased from 11px */
            font-weight: bold;
            color: #ffd700;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* ===== FLOATING WINDOWS (Map & Leaders) ===== */
        .floating-window {
            position: fixed;
            background: linear-gradient(135deg, rgba(0, 15, 30, 0.95) 0%, rgba(0, 30, 50, 0.9) 100%);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
            backdrop-filter: blur(12px);
            z-index: 85;
            pointer-events: auto;
            overflow: hidden;
        }

        .floating-window.hidden {
            display: none;
        }

        .window-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(0, 243, 255, 0.2);
            cursor: move;
        }

        .window-header h4 {
            margin: 0;
            font-size: 11px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .window-controls {
            display: flex;
            gap: 4px;
        }

        .window-btn {
            width: 18px;
            height: 18px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: 3px;
            color: var(--accent);
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .window-btn:hover {
            background: rgba(0, 243, 255, 0.2);
        }

        .window-content {
            padding: 10px;
        }

        /* Map Window - Bottom Left */
        .map-window {
            left: 20px;
            bottom: 200px;
            /* Moved up to avoid cockpit */
            width: 200px;
            height: 180px;
        }

        .map-window.collapsed {
            height: auto;
        }

        .map-window.collapsed .window-content {
            display: none;
        }

        .map-canvas {
            width: 100%;
            height: 120px;
            background: radial-gradient(circle at center, rgba(0, 20, 40, 0.9) 0%, rgba(0, 5, 15, 0.95) 100%);
            border-radius: 6px;
            border: 1px solid rgba(0, 243, 255, 0.2);
        }

        .map-legend {
            display: flex;
            gap: 8px;
            margin-top: 6px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 3px;
            font-size: 8px;
            color: rgba(255, 255, 255, 0.7);
        }

        .legend-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* Leaders Window - Bottom Right */
        .leaders-window {
            right: 20px;
            bottom: 200px;
            /* Moved up to avoid cockpit */
            width: 180px;
        }

        .leaders-window.collapsed .window-content {
            display: none;
        }

        .leaders-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .leaders-list::-webkit-scrollbar {
            width: 3px;
        }

        .leaders-list::-webkit-scrollbar-thumb {
            background: rgba(0, 243, 255, 0.3);
            border-radius: 2px;
        }

        .leader-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 10px;
        }

        .leader-row:last-child {
            border-bottom: none;
        }

        .leader-rank {
            width: 20px;
            color: var(--accent);
            font-weight: bold;
        }

        .leader-name {
            flex: 1;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .leader-wealth {
            color: #ffd700;
            font-weight: bold;
        }

        /* Responsive adjustments */
        @media (max-width: 900px) {
            .flight-cockpit {
                padding: 6px 8px;
                gap: 6px;
            }

            .cockpit-section {
                padding: 6px 8px;
                min-width: 80px;
            }

            .radar-container {
                width: 60px;
                height: 60px;
            }

            .gems-section {
                max-width: 200px;
            }

            .gems-grid {
                max-width: 180px;
            }
        }

        @media (max-width: 600px) {
            .flight-cockpit {
                flex-wrap: wrap;
                justify-content: center;
            }

            .controls-section {
                display: none;
            }

            .map-window,
            .leaders-window {
                width: 150px;
                bottom: 110px;
            }
        }

        /* Fullscreen Map Styles */
        .fullscreen-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 2000;
            /* Ensure this is higher than everything else */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .fullscreen-modal.hidden {
            display: none;
        }

        .map-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 2001;
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border: 1px solid var(--accent);
            border-radius: 6px;
        }

        #fullscreenMapCanvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #fullscreenMapCanvas:active {
            cursor: grabbing;
        }
    </style>
</head>

<body>

    <div id="toast" class="toast">Action Successful</div>

    <!-- === TOP BAR === -->
    <div class="top-bar">
        <h1>Interstellar Spacetime</h1>

        <div class="top-bar-center">
            <!-- Star Colors Group -->
            <div class="star-colors-group">
                <span class="star-colors-label">Star Colors</span>
                <input type="color" id="starColor1" class="color-picker-mini star-color" value="#ffffff"
                    title="Star Color 1" onchange="app.updateStarColors()">
                <input type="color" id="starColor2" class="color-picker-mini star-color" value="#aaddff"
                    title="Star Color 2" onchange="app.updateStarColors()">
                <input type="color" id="starColor3" class="color-picker-mini star-color" value="#ffddaa"
                    title="Star Color 3" onchange="app.updateStarColors()">
            </div>
            <!-- Motion Group -->
            <div class="bar-group">
                <button class="btn-small" id="bgDriftBtn" onclick="app.toggleBgDrift()">Drift</button>
                <button class="btn-small" id="bgWarpBtn" onclick="app.toggleBgWarp()">Lightspeed</button>
                <input type="range" id="warpSpeedSlider" min="0" max="100" step="1" value="10" style="width: 50px;"
                    title="Warp Speed" oninput="app.setWarpSpeedMultiplier(this.value)">
            </div>
            <!-- Background Styles Group -->
            <div class="bar-group">
                <button class="btn-small bg-toggle" data-style="deep-space"
                    onclick="app.toggleBgStyle('deep-space')">Deep Space</button>
                <button class="btn-small bg-toggle" data-style="nebula"
                    onclick="app.toggleBgStyle('nebula')">Nebula</button>
                <button class="btn-small bg-toggle" data-style="alien"
                    onclick="app.toggleBgStyle('alien')">Alien</button>
                <button class="btn-small bg-toggle" data-style="cyber"
                    onclick="app.toggleBgStyle('cyber')">Matrix</button>
                <button class="btn-small btn-regen" onclick="app.generateBackground()"
                    title="Regenerate Background">âŸ³</button>
            </div>
        </div>

        <div class="top-bar-right">
            <input type="color" id="colorInput" class="color-picker-mini" value="#00f3ff"
                onchange="app.setFixedColor(this.value)">
            <button class="btn-small" id="rainbowBtn" onclick="app.setRainbowMode()">ðŸŒˆ</button>
            <div class="divider"></div>
            <button class="btn-small" id="rotationToggle" onclick="app.toggleRotationPanel()">3D</button>
        </div>
    </div>


    <!-- === MATRIX CONTROLS POPUP === -->
    <div id="matrixPanel" class="popup-panel hidden">
        <h3>Matrix</h3>
        <label style="font-size:10px">Speed: <span id="matrixSpeedValue">1.0x</span></label>
        <input type="range" id="matrixSpeedSlider" min="0.1" max="8" step="0.1" value="1" style="width:100%">

        <label style="font-size:10px;margin-top:6px;display:block">Length: <span
                id="matrixLengthValue">1.0x</span></label>
        <input type="range" id="matrixLengthSlider" min="0.2" max="3" step="0.1" value="1" style="width:100%">

        <label style="font-size:10px;margin-top:6px;display:block">Angle: <span id="matrixAngleValue">0Â°</span></label>
        <input type="range" id="matrixAngleSlider" min="0" max="360" step="5" value="0" style="width:100%">

        <div style="display:flex; gap:4px; margin-top:8px; align-items:center">
            <input type="color" id="matrixColorPicker" class="color-picker-mini" value="#00ff00"
                style="width:24px;height:24px">
            <button class="btn-small" id="matrixRainbowBtn" onclick="app.toggleMatrixRainbow()"
                style="font-size:10px;padding:6px">ðŸŒˆ</button>
        </div>
    </div>


    <!-- === FULLSCREEN MAP MODAL === -->
    <div id="expandedMapModal" class="fullscreen-modal hidden">
        <div class="map-controls">
            <button class="btn-small" onclick="app.closeExpandedMap()">CLOSE MAP</button>
            <span id="mapZoomLevel">Zoom: 1.0x</span>
        </div>
        <canvas id="fullscreenMapCanvas"></canvas>
    </div>

    <!-- === ROTATION CONTROLS POPUP === -->
    <div id="rotationPanel" class="popup-panel hidden">
        <h3>3D</h3>
        <label style="font-size:10px">X: <span id="rotXValue">0Â°</span></label>
        <input type="range" id="rotXSlider" min="-180" max="180" step="1" value="0" style="width:100%">
        <label style="font-size:10px;margin-top:6px;display:block">Y: <span id="rotYValue">0Â°</span></label>
        <input type="range" id="rotYSlider" min="-180" max="180" step="1" value="0" style="width:100%">
        <label style="font-size:10px;margin-top:6px;display:block">Z: <span id="rotZValue">0Â°</span></label>
        <input type="range" id="rotZSlider" min="-180" max="180" step="1" value="0" style="width:100%">
        <button class="btn-small" onclick="app.resetRotation()"
            style="width:100%; margin-top:8px;font-size:10px;padding:6px">Reset</button>
    </div>

    <!-- === UPGRADE STATION POPUP === -->
    <div id="upgradePanel" class="popup-panel hidden"
        style="width: 220px; max-height: 500px; top: 50%; left: 50%; transform: translate(-50%, -50%); border-radius: 12px; z-index: 200;">
        <h3
            style="text-align: center; font-size: 16px; margin-bottom: 15px; border-bottom: 1px solid var(--accent); padding-bottom: 8px;">
            Interstellar Dock</h3>

        <div
            style="margin-bottom: 15px; text-align: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
            <div style="font-size: 10px; color: #5c7a8a; letter-spacing: 2px;">AVAILABLE CREDITS</div>
            <div style="font-size: 24px; color: #ffd700; font-weight: bold; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);"
                id="dockCredits">$0</div>
        </div>

        <div id="upgradeList"
            style="display: flex; flex-direction: column; gap: 8px; overflow-y: auto; max-height: 300px; padding-right: 4px;">
            <!-- Generated via JS -->
        </div>

        <button class="btn-small" onclick="document.getElementById('upgradePanel').classList.add('hidden')"
            style="width: 100%; margin-top: 15px; padding: 10px; font-weight: bold;">CLOSE DOCK</button>
    </div>


    <!-- === BOTTOM BAR === -->
    <div class="bottom-bar">
        <div class="bottom-bar-left">
            <div class="bar-group">
                <button class="btn active" id="drawModeBtn" onclick="app.setMode('draw')" data-tooltip="Draw Stars">
                    <svg viewBox="0 0 24 24">
                        <path
                            d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z" />
                    </svg>
                </button>
                <button class="btn" id="selectModeBtn" onclick="app.setMode('select')" data-tooltip="Select/Drag">
                    <svg viewBox="0 0 24 24">
                        <path
                            d="M7 19h10V4H7v15zm-2-2V6c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2v11c0 1.1-.9 2-2 2H7c-1.1 0-2-.9-2-2z" />
                    </svg>
                </button>
            </div>
        </div>
        <div class="bottom-bar-center">
            <div class="bar-group">
                <button class="btn" onclick="app.undo()" data-tooltip="Undo">
                    <svg viewBox="0 0 24 24">
                        <path
                            d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z" />
                    </svg>
                </button>
                <button class="btn" onclick="app.requestClear()" data-tooltip="Clear">
                    <svg viewBox="0 0 24 24">
                        <path
                            d="M15 16h4v2h-4zm0-8h7v2h-7zm0 4h6v2h-6zM3 18c0 1.1.9 2 2 2h6c1.1 0 2-.9 2-2V8H3v10zM14 5h-3l-1-1H6L5 5H2v2h12z" />
                    </svg>
                </button>
            </div>
            <div class="bar-group">
                <button class="btn" onclick="app.downloadSVG()" data-tooltip="Export SVG">
                    <svg viewBox="0 0 24 24">
                        <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z" />
                    </svg>
                </button>
                <button class="btn" onclick="app.downloadPNG()" data-tooltip="Export PNG">
                    <svg viewBox="0 0 24 24">
                        <path
                            d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z" />
                    </svg>
                </button>
                <button class="btn" onclick="app.triggerLoadSVG()" data-tooltip="Load SVG">
                    <svg viewBox="0 0 24 24">
                        <path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z" />
                    </svg>
                </button>
            </div>
            <div class="bar-group">
                <select id="videoDuration"
                    style="background: var(--glass); border: 1px solid var(--glass-border); color: var(--text); padding: 4px 6px; border-radius: 4px; font-size: 11px; cursor: pointer;">
                    <option value="3000">3s</option>
                    <option value="5000" selected>5s</option>
                    <option value="10000">10s</option>
                </select>
                <button class="btn" id="exportVideoBtn" onclick="app.exportVideo()" data-tooltip="Record Video">
                    <svg viewBox="0 0 24 24">
                        <path
                            d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z" />
                    </svg>
                </button>
            </div>
            <div class="bar-group">
                <button class="btn" onclick="app.toggleTemplatePanel()" data-tooltip="Templates">
                    <svg viewBox="0 0 24 24">
                        <path
                            d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H5v-4h9v4zm5 0h-4v-4h4v4zm0-5H5V5h14v7z" />
                    </svg>
                </button>
                <button class="btn" onclick="app.toggleFlightMode()" data-tooltip="Flight Mode">ðŸš€</button>
                <button class="btn" id="selectShipBtn" onclick="app.showShipModal()" data-tooltip="Select Ship"
                    style="display:none">ðŸ›¸</button>
            </div>
        </div>
        <div class="bottom-bar-right">
            <div class="bar-group">
                <button class="zoom-btn" onclick="app.adjustZoom(-0.1)">-</button>
                <button class="zoom-btn" onclick="app.resetView()">âŸ²</button>
                <button class="zoom-btn" onclick="app.adjustZoom(0.1)">+</button>
            </div>
        </div>
    </div>

    <!-- Template Selection Panel -->
    <div id="templatePanel" class="hud-panel"
        style="position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); width: 400px; max-height: 400px; display: none; overflow-y: auto; z-index: 100;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h2 style="font-size: 14px; margin: 0; color: var(--accent); text-transform: uppercase;">
                Constellation Templates</h2>
            <button class="btn-small" onclick="document.getElementById('templatePanel').style.display='none'"
                style="min-width: 24px; padding: 2px 6px;">âœ•</button>
        </div>

        <div
            style="margin-bottom: 10px; display: flex; align-items: center; gap: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--glass-border);">
            <label style="font-size: 12px; color: var(--text); display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="templateRainbowMode" style="margin-right: 5px; accent-color: var(--accent);">
                Rainbow Mode
            </label>
            <div style="display: flex; align-items: center; gap: 5px;">
                <span style="font-size: 12px; color: var(--text);">Color:</span>
                <input type="color" id="templateColorPicker" value="#00ffff"
                    style="border: none; width: 24px; height: 24px; cursor: pointer; background: none;">
            </div>
        </div>
        <div style="margin-bottom: 10px;">
            <h3
                style="font-size: 12px; color: var(--text-dim); margin: 5px 0; border-bottom: 1px solid var(--glass-border);">
                Zodiac Signs</h3>
            <div id="zodiacTemplates" style="display: flex; flex-wrap: wrap; gap: 5px;"></div>
        </div>

        <div style="margin-bottom: 10px;">
            <h3
                style="font-size: 12px; color: var(--text-dim); margin: 5px 0; border-bottom: 1px solid var(--glass-border);">
                Animals</h3>
            <div id="animalTemplates" style="display: flex; flex-wrap: wrap; gap: 5px;"></div>
        </div>

        <div>
            <h3
                style="font-size: 12px; color: var(--text-dim); margin: 5px 0; border-bottom: 1px solid var(--glass-border);">
                Mythology</h3>
            <div id="mythTemplates" style="display: flex; flex-wrap: wrap; gap: 5px;"></div>
        </div>
    </div>
    </div>

    <!-- Hidden file input for loading SVG -->
    <input type="file" id="svgFileInput" accept=".svg" style="display: none;" onchange="app.loadSVG(event)">

    <!-- Zoom controls now integrated in bottom-bar -->

    <div class="stats" id="stats">
        Mode: Draw | Stars: 0 | Constellations: 0 | Zoom: 1.00x
    </div>

    <!-- Confirmation Modal -->
    <div id="clearModal" class="modal-overlay">
        <div class="modal">
            <h2>Implode Universe?</h2>
            <p style="color: #888; margin-bottom: 20px;">This will remove all stars. This action cannot be undone
                easily.</p>
            <div class="modal-actions">
                <button class="btn-secondary" onclick="app.closeModal()">Cancel</button>
                <button class="btn-primary" onclick="app.confirmClear()"
                    style="background-color: #ff3333; border-color: #cc0000; color: white;">Implode</button>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <!-- Flight Mode HUD Overlay -->
    <!-- Flight Mode HUD Overlay (Command Center Layout) -->
    <div id="flightHUD" class="flight-hud hidden">

        <!-- LEFT COLUMN: Radar & Ship Status -->
        <div class="hud-column hud-left">
            <!-- RADAR -->
            <div id="sectionRadar" class="cockpit-section">
                <div class="cockpit-header">
                    <h4>ðŸ“¡ Radar System</h4>
                    <button class="window-btn" onclick="app.toggleCockpitSection('sectionRadar')">âˆ’</button>
                </div>
                <div class="cockpit-content" style="display:flex; flex-direction:column; align-items:center;">
                    <div class="radar-container" style="margin-bottom:10px;">
                        <canvas id="radarCanvas" class="radar-canvas" width="120" height="120"></canvas>
                        <div class="radar-sweep"></div>
                    </div>
                    <div class="radar-coords" id="radarCoords" style="font-family:monospace; color:#0ff;">X: 0 Y: 0
                    </div>
                </div>
            </div>

            <!-- VELOCITY -->
            <div id="sectionVelocity" class="cockpit-section">
                <div class="cockpit-header">
                    <h4>âš¡ Engines</h4>
                </div>
                <div class="cockpit-content">
                    <div class="velocity-display" style="display:flex; align-items:center; gap:15px;">
                        <div class="speed-gauge" style="position:relative;">
                            <canvas id="speedGaugeCanvas" width="70" height="70"></canvas>
                            <div id="speedNumber" class="speed-number"
                                style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-weight:bold;">
                                0</div>
                        </div>
                        <div style="flex:1;">
                            <div class="speed-unit" style="color:var(--text-dim); font-size:11px;">VELOCITY (km/s)</div>
                            <div class="cockpit-zoom-controls" style="margin-top:10px; display:flex; gap:5px;">
                                <button class="zoom-btn" onclick="app.flightZoom(-0.2)">âˆ’</button>
                                <span id="zoomDisplay" class="zoom-value"
                                    style="background:rgba(0,0,0,0.5); padding:2px 6px; border-radius:4px;">1.0x</span>
                                <button class="zoom-btn" onclick="app.flightZoom(0.2)">+</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- CENTER COLUMN (Spacer) -->
        <div class="hud-column hud-center">
            <!-- Can put reticle or warnings here later -->
        </div>

        <!-- RIGHT COLUMN: Controls & Ship Config -->
        <div class="hud-column hud-right">
            <!-- CONTROLS -->
            <div id="sectionControls" class="cockpit-section">
                <div class="cockpit-header">
                    <h4>ðŸŽ® Flight Control</h4>
                    <button class="window-btn" onclick="app.toggleCockpitSection('sectionControls')">âˆ’</button>
                </div>
                <div class="cockpit-content">
                    <div class="controls-grid"
                        style="display:grid; grid-template-columns: repeat(4, 1fr); gap:5px; margin-bottom:15px;">
                        <kbd title="Forward">W</kbd><kbd title="Backward">S</kbd><kbd title="Roll Left">A</kbd><kbd
                            title="Roll Right">D</kbd>
                        <kbd title="Up">Q</kbd><kbd title="Down">E</kbd><kbd title="Pitch Up">R</kbd><kbd
                            title="Pitch Down">F</kbd>
                    </div>

                    <div style="border-top: 1px solid rgba(0,243,255,0.2); padding-top: 10px;">
                        <div
                            style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <label style="font-size: 12px; color: #aaa;">Paint:</label>
                            <div style="display:flex; align-items:center; gap:5px;">
                                <input type="color" id="shipColorPicker" value="#00f3ff"
                                    style="width: 30px; height: 30px; border:none; background:none; cursor:pointer;">
                                <button class="btn-small" onclick="app.resetShipColor()">â†º</button>
                            </div>
                        </div>

                        <button class="btn-small" style="width:100%; padding:8px;" onclick="app.toggleAutopilot()">
                            <span id="autopilotStatus">âœˆï¸ Engage Autopilot</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- BOTTOM ROW: Inventory / Gems -->
        <div class="hud-bottom">
            <div id="sectionGems" class="cockpit-section gems-section" style="width: 100%; max-width: 800px;">
                <div class="cockpit-header">
                    <h4>ðŸ’Ž Cargo Hold</h4>
                    <div style="display:flex; gap:10px;">
                        <button class="window-btn" id="btnToggleGemValues" onclick="app.toggleGemValues()"
                            title="Toggle Values">ðŸ’²</button>
                        <button class="window-btn" onclick="app.toggleCockpitSection('sectionGems')">âˆ’</button>
                    </div>
                </div>
                <div class="cockpit-content">
                    <div id="gemsGrid" class="gems-grid">
                        <!-- Populated by JS -->
                    </div>
                    <div class="wallet-display"
                        style="margin-top:10px; padding-top:10px; border-top:1px solid rgba(255,255,255,0.1); display:flex; justify-content:space-between; align-items:center;">
                        <div class="gems-total" style="font-size:12px;">Est. Value: <span id="gemsTotal">$0</span></div>
                        <span>Credits: <span id="walletValue">0</span> â‚µ</span>
                        <button class="btn-sell-all" onclick="app.sellAllGems()">Sell All</button>
                    </div>
                </div>
                <div class="resize-handle"
                    style="position:absolute; right:0; bottom:0; width:12px; height:12px; cursor:nwse-resize; background: linear-gradient(135deg, transparent 50%, rgba(0,243,255,0.3) 50%);">
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Map Window (Bottom Left, above cockpit) -->
    <div id="floatingMap" class="floating-window map-window hidden">
        <div class="window-header">
            <h4>ðŸ—ºï¸ Universe Map</h4>
            <div class="window-controls">
                <button class="window-btn" onclick="app.openExpandedMap()" title="Expand Map">â›¶</button>
                <button class="window-btn" onclick="app.toggleFloatingWindow('floatingMap')" title="Collapse">âˆ’</button>
            </div>
        </div>
        <div class="window-content">
            <canvas id="mapCanvas" class="map-canvas" width="180" height="120"></canvas>
            <div class="map-legend">
                <div class="legend-item">
                    <div class="legend-dot" style="background:#0f0"></div>You
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background:#ff0"></div>Stars
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background:#f0f"></div>Gems
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Leaders Window (Bottom Right, above cockpit) -->
    <div id="floatingLeaders" class="floating-window leaders-window hidden">
        <div class="window-header">
            <h4>ðŸ† Leaders</h4>
            <div class="window-controls">
                <button class="window-btn" onclick="app.toggleFloatingWindow('floatingLeaders')"
                    title="Collapse">âˆ’</button>
            </div>
        </div>
        <div class="window-content">
            <div id="floatingLeadersList" class="leaders-list">
                <!-- Populated by JS -->
            </div>
        </div>
    </div>

    <!-- Spacecraft Selection Modal -->
    <div id="shipModal" class="modal-overlay">
        <div class="modal">
            <h2>Select Spacecraft</h2>
            <div id="shipList" class="ship-list">
                <div class="ship-option" onclick="app.selectShip('interceptor')">
                    <h3>ðŸš€ Interceptor</h3>
                    <p>Balanced fighter. Speed: 50, Accel: 0.5</p>
                </div>
                <div class="ship-option" onclick="app.selectShip('saucer')">
                    <h3>ðŸ›¸ Saucer</h3>
                    <p>High speed, drift capability. Speed: 70, Accel: 0.7</p>
                </div>
                <div class="ship-option" onclick="app.selectShip('hauler')">
                    <h3>ðŸ“¦ Hauler</h3>
                    <p>Heavy, stable platform. Speed: 30, Accel: 0.3</p>
                </div>
                <div class="ship-option" onclick="app.selectShip('orion')">
                    <h3>â­ Orion</h3>
                    <p>Constellation class. Speed: 60, Accel: 0.6</p>
                </div>
                <div class="ship-option" onclick="app.selectShip('draco')">
                    <h3>ðŸ‰ Draco</h3>
                    <p>Dragon constellation. Speed: 80, Accel: 0.4</p>
                </div>
                <div class="ship-option" onclick="app.selectShip('phoenix')">
                    <h3>ðŸ”¥ Phoenix</h3>
                    <p>Reborn in fire. Speed: 55, Accel: 0.8</p>
                </div>
                <div class="ship-option" onclick="app.selectShip('harvester')">
                    <h3>ðŸ’Ž Starfighter</h3>
                    <p>Advanced combat vessel. Speed: 80, Accel: 0.8</p>
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn-secondary" onclick="app.hideShipModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Main Application Logic (Module) -->
    <!-- Mobile Joystick -->
    <div id="joystick-container"
        style="display: none; position: fixed; bottom: 30px; left: 30px; width: 120px; height: 120px; z-index: 1000;">
        <div id="joystick-base"
            style="width: 100%; height: 100%; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(0, 255, 255, 0.3); border-radius: 50%; position: relative; touch-action: none;">
            <div id="joystick-stick"
                style="width: 50px; height: 50px; background: rgba(0, 255, 255, 0.5); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px #00ffff;">
            </div>
        </div>
    </div>

    <!-- Mobile Toggle Button (Visible only on small screens or by default) -->
    <!-- Mobile Toggle Button (Visible always now via CSS) -->
    <button id="mobile-toggle" onclick="app.toggleMobileControls()"
        style="position: fixed; bottom: 85px; right: 30px; z-index: 1000; background: rgba(0,0,0,0.6); color: #0ff; border: 1px solid #0ff; padding: 12px; border-radius: 50%; font-size: 24px; cursor: pointer;">
        ðŸŽ®
    </button>

    <!-- Style for Mobile Visibility & UI Polish -->
    <style>
        /* Force Mobile Toggle Visible Always */
        #mobile-toggle {
            display: block !important;
            opacity: 0.6;
            transition: opacity 0.3s, transform 0.3s;
        }

        #mobile-toggle:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        /* Glassmorphism Common Style */
        .glass-panel {
            background: rgba(10, 20, 30, 0.75);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 243, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            color: #fff;
            padding: 15px;
        }

        /* Scrollbar Polish */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 243, 255, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 243, 255, 0.6);
        }
    </style>

    <script type="module">
        /**
         * Aether Map Engine v5.0 - Pre-Placement Color Model
         */
        class AetherEngine {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });

                // Configuration
                this.config = {
                    maxConnectDist: 180,
                    starBaseRad: 3.5,
                    minGroupSize: 3,
                    bgColor: '#020205',
                    showBackground: true,
                };

                // World size for background generation (covers full canvas at min zoom 0.1x)
                this.worldSize = 12000;

                // Procedural Universe Generation System
                this.sectorSize = 10000; // Each sector is 10k x 10k units
                this.loadedSectors = new Map(); // Map of "x,y" -> sector data
                this.currentSector = { x: 0, y: 0 }; // Player's current sector
                this.generationBoundary = 3000; // Generate new sectors when within this distance of edge

                // State
                this.stars = [];
                this.camera = { x: 0, y: 0, zoom: 1, targetZoom: 1 };
                this.history = [];
                this.mode = 'draw'; // 'draw' or 'select'

                // NEW COLOR STATE
                this.activeColor = '#00f3ff';
                this.colorMode = 'fixed'; // 'fixed' or 'rainbow'
                this.activeStyles = new Set(); // Start with no backgrounds active
                this.matrixSpeedMultiplier = 1.0; // User-adjustable cyber speed
                this.matrixLengthMultiplier = 1.0; // User-adjustable cyber stream length
                this.matrixColor = '#00ff00'; // User-adjustable matrix stream color
                this.matrixRainbowMode = false; // Rainbow color cycling for matrix
                this.matrixAngle = 0; // Angle in degrees for stream direction

                // Generic Background Mode Options
                this.starColors = ['#ffffff', '#aaddff', '#ffddaa']; // 3 customizable star colors
                this.bgDriftMode = false; // Star drift movement enabled  
                this.bgWarpMode = false; // Warp speed effect enabled
                this.warpSpeed = 0; // Current warp animation speed (for ramping)
                this.warpSpeedMultiplier = 1; // User-controlled warp intensity (0.5 to 5)
                this.warpStartTime = 0; // When warp mode started
                this.shootingStarsActive = []; // Active shooting stars in normal mode
                this.lastShootingStarTime = 0; // Last time a shooting star was spawned

                // Flight game state
                this.flightMode = false;
                this.keysPressed = {};
                this.credits = this.loadCredits();
                const savedUpgrades = this.loadUpgrades();

                this.playerShip = {
                    type: 'default',
                    x: 0, y: 0, z: 0,
                    vx: 0, vy: 0, vz: 0,
                    rotation: 0,
                    pitch: 0, // 3D pitch rotation (up/down)
                    roll: 0,  // 3D roll rotation (barrel roll)
                    speed: 0,
                    maxSpeed: 50 * (1 + (savedUpgrades.speed || 0) * 0.2),
                    acceleration: 0.5 * (1 + (savedUpgrades.speed || 0) * 0.1),
                    rotationSpeed: 0.08,
                    size: 45,
                    color: localStorage.getItem('shipColor') || '#00f3ff', // Customizable color
                    hullHealth: 100 * (1 + (savedUpgrades.armor || 0) * 0.2),
                    maxHull: 100 * (1 + (savedUpgrades.armor || 0) * 0.2),
                    shield: 50 * (1 + (savedUpgrades.shield || 0) * 0.2),
                    maxShield: 50 * (1 + (savedUpgrades.shield || 0) * 0.2),
                    radarRange: 2000 * (1 + (savedUpgrades.radar || 0) * 0.3),
                    upgrades: savedUpgrades
                };
                this.speedLines = [];  // Visual speed indicators
                this.showGemValues = false; // Toggle for showing gem values

                // Mineral system
                this.minerals = [];
                this.mineralTypes = {
                    // ============ INDUSTRIAL ZONE (50% spawn rate in industrial galaxies) ============
                    iron: { name: 'Iron', value: 10, color: '#8B8680', rarity: 'common', size: 15, zone: 'industrial', use: 'Basic construction' },
                    copper: { name: 'Copper', value: 25, color: '#B87333', rarity: 'common', size: 15, zone: 'industrial', use: 'Wiring, conductors' },
                    coal: { name: 'Coal', value: 15, color: '#36454F', rarity: 'common', size: 12, zone: 'industrial', use: 'Fuel source' },
                    titanium: { name: 'Titanium', value: 80, color: '#878681', rarity: 'common', size: 16, zone: 'industrial', use: 'Armor plating' },
                    silicon: { name: 'Silicon', value: 45, color: '#A0A0A0', rarity: 'common', size: 14, zone: 'industrial', use: 'Electronics, circuits' },

                    // ============ PRECIOUS ZONE (25% spawn rate in precious galaxies) ============
                    silver: { name: 'Silver', value: 150, color: '#C0C0C0', rarity: 'uncommon', size: 18, zone: 'precious', use: 'Currency, conductors' },
                    gold: { name: 'Gold', value: 400, color: '#FFD700', rarity: 'uncommon', size: 20, zone: 'precious', use: 'Electronics, currency' },
                    platinum: { name: 'Platinum', value: 500, color: '#E5E4E2', rarity: 'uncommon', size: 20, zone: 'precious', use: 'Catalysts, jewelry' },
                    palladium: { name: 'Palladium', value: 600, color: '#CED0DD', rarity: 'uncommon', size: 19, zone: 'precious', use: 'Fuel cells, catalysts' },

                    // ============ CRYSTAL ZONE (15% spawn rate in crystal galaxies) ============
                    quartz: { name: 'Quartz', value: 800, color: '#F5F5F5', rarity: 'rare', size: 22, zone: 'crystal', use: 'Optics, sensors' },
                    diamond: { name: 'Diamond', value: 2500, color: '#B9F2FF', rarity: 'rare', size: 25, zone: 'crystal', use: 'Cutting tools, lasers' },
                    emerald: { name: 'Emerald', value: 3000, color: '#50C878', rarity: 'rare', size: 25, zone: 'crystal', use: 'Energy focusing' },
                    ruby: { name: 'Ruby', value: 2800, color: '#E0115F', rarity: 'rare', size: 25, zone: 'crystal', use: 'Laser amplification' },
                    sapphire: { name: 'Sapphire', value: 3200, color: '#0F52BA', rarity: 'rare', size: 25, zone: 'crystal', use: 'Shield technology' },

                    // ============ NUCLEAR ZONE (7% spawn rate near black holes) ============
                    uranium: { name: 'Uranium', value: 8000, color: '#4AFF00', rarity: 'epic', size: 28, zone: 'nuclear', use: 'Nuclear reactors' },
                    plutonium: { name: 'Plutonium', value: 12000, color: '#00FF7F', rarity: 'epic', size: 28, zone: 'nuclear', use: 'Advanced power' },
                    helium3: { name: 'Helium-3', value: 15000, color: '#87CEEB', rarity: 'epic', size: 26, zone: 'nuclear', use: 'Fusion reactors' },

                    // ============ EXOTIC ZONE (3% spawn rate - edge of space) ============
                    neodymium: { name: 'Neodymium', value: 25000, color: '#FF6EC7', rarity: 'legendary', size: 30, zone: 'exotic', use: 'Magnet tech' },
                    lanthanum: { name: 'Lanthanum', value: 30000, color: '#9D00FF', rarity: 'legendary', size: 32, zone: 'exotic', use: 'Hybrid engines' },
                    darkmatter: { name: 'Dark Matter', value: 100000, color: '#1a0033', rarity: 'mythic', size: 35, zone: 'exotic', use: 'Warp drives' },
                    antimatter: { name: 'Antimatter', value: 150000, color: '#FF00FF', rarity: 'mythic', size: 35, zone: 'exotic', use: 'Annihilation power' }
                };

                // Galaxy zone configuration - determines element distribution
                this.galaxyZones = {
                    industrial: {
                        name: 'Industrial Sector',
                        color: '#8B8680',
                        glowColor: 'rgba(139, 134, 128, 0.3)',
                        elements: ['iron', 'copper', 'coal', 'titanium', 'silicon'],
                        concentrationBonus: 3.0,
                        defenseLevel: 1,
                        distanceRange: { min: 100, max: 800 }
                    },
                    precious: {
                        name: 'Precious Nebula',
                        color: '#FFD700',
                        glowColor: 'rgba(255, 215, 0, 0.3)',
                        elements: ['silver', 'gold', 'platinum', 'palladium'],
                        concentrationBonus: 2.5,
                        defenseLevel: 2,
                        distanceRange: { min: 800, max: 2000 }
                    },
                    crystal: {
                        name: 'Crystal Fields',
                        color: '#50C878',
                        glowColor: 'rgba(80, 200, 120, 0.3)',
                        elements: ['quartz', 'diamond', 'emerald', 'ruby', 'sapphire'],
                        concentrationBonus: 2.0,
                        defenseLevel: 3,
                        distanceRange: { min: 2000, max: 4000 }
                    },
                    nuclear: {
                        name: 'Radiation Belt',
                        color: '#4AFF00',
                        glowColor: 'rgba(74, 255, 0, 0.4)',
                        elements: ['uranium', 'plutonium', 'helium3'],
                        concentrationBonus: 1.5,
                        defenseLevel: 4,
                        distanceRange: { min: 3500, max: 5000 }
                    },
                    exotic: {
                        name: 'Dark Frontier',
                        color: '#9D00FF',
                        glowColor: 'rgba(157, 0, 255, 0.4)',
                        elements: ['neodymium', 'lanthanum', 'darkmatter', 'antimatter'],
                        concentrationBonus: 1.0,
                        defenseLevel: 5,
                        distanceRange: { min: 5000, max: 8000 }
                    }
                };

                // Resource deposits - persistent locations with finite resources
                this.resourceDeposits = [];

                // Defense entities
                this.sentinels = [];     // AI patrol drones
                this.forcefields = [];   // Energy barriers
                this.turrets = [];       // Stationary guns
                this.guardians = [];     // Boss-level protectors
                this.projectiles = [];   // Active projectiles
                this.playerInventory = this.loadInventory();
                this.collectionNotifications = [];

                // Initialize Matrix theme history (must exist before toggleBgStyle/generateCyberStyle is called)
                try {
                    const savedHistory = localStorage.getItem('matrixThemeHistory');
                    this.themeHistory = savedHistory ? JSON.parse(savedHistory) : [];
                    this.lastMatrixFamily = localStorage.getItem('matrixLastFamily') || '';
                } catch (e) {
                    this.themeHistory = [];
                    this.lastMatrixFamily = '';
                }

                // Initialize background arrays (must exist before toggleBgStyle is called)
                this.staticStars = [];
                this.galaxies = [];
                this.blackHoles = [];
                this.shootingStars = [];
                this.backgroundStars = [];
                this.nebulae = [];
                this.spacecraft = [];
                this.matrixStreams = [];
                this.planets = [];

                // 3D Rotation State (degrees)
                this.rotationX = 0;
                this.rotationY = 0;
                this.rotationZ = 0;

                // Interaction State
                this.pointer = { x: 0, y: 0, startX: 0, startY: 0, isDown: false, dragging: false, lastWorldX: 0, lastWorldY: 0 };
                this.hoveredStar = null;
                this.draggedStar = null;
                this.draggedClusterId = null; // Used only for dragging entire clusters

                // Generators
                this.initNameGenerators();
                // Generators
                this.initNameGenerators();
                this.initTemplates();
                this.generateResourceDeposits();

                // Performance
                this.backgroundStars = [];

                this.init();
            }

            async initTemplates() {
                try {
                    // Use fetch for JSON loading to avoid MIME type issues
                    const [zodiac, animals, mythology] = await Promise.all([
                        fetch('./templates/zodiac.json').then(res => res.json()),
                        fetch('./templates/animals.json?bust=1').then(res => res.json()),
                        fetch('./templates/mythology.json').then(res => res.json())
                    ]);

                    this.templates = { zodiac, animals, mythology };

                    // Render Buttons
                    const createBtn = (category, key, containerId) => {
                        const btn = document.createElement('button');
                        btn.className = 'btn-small';
                        btn.style.margin = '2px';
                        btn.style.textTransform = 'capitalize';
                        btn.innerText = key;
                        btn.onclick = () => this.loadTemplate(category, key);
                        document.getElementById(containerId).appendChild(btn);
                    };

                    // Only render if data loaded
                    if (this.templates.zodiac) Object.keys(this.templates.zodiac).forEach(k => createBtn('zodiac', k, 'zodiacTemplates'));
                    if (this.templates.animals) Object.keys(this.templates.animals).forEach(k => createBtn('animals', k, 'animalTemplates'));
                    if (this.templates.mythology) Object.keys(this.templates.mythology).forEach(k => createBtn('mythology', k, 'mythTemplates'));

                } catch (e) {
                    console.error("Template loading failed:", e);
                    this.showToast("Failed to load templates");
                }
            }

            loadTemplate(category, key) {
                const points = this.templates[category][key];
                if (!points) return;

                this.saveState(); // Save before clearing

                // Center Calculation: Find centroid of the template points
                let totalX = 0, totalY = 0, totalZ = 0;
                points.forEach(p => {
                    totalX += p[0];
                    totalY += p[1];
                    totalZ += (p[2] || 0);
                });
                const count = points.length;
                const centroidX = totalX / count;
                const centroidY = totalY / count;
                const centroidZ = totalZ / count;

                // Reset Camera to ensure visibility (User request: "put in middle of screen")
                this.camera = { x: 0, y: 0, zoom: 1 };

                // Center Position
                const cx = 0;
                const cy = 0;
                const scale = 3;

                // Offset calculation happens inside mapping (p[0] - centroidX)

                // Check Rainbow Mode
                const isRainbow = document.getElementById('templateRainbowMode')?.checked;
                const templateColor = document.getElementById('templateColorPicker')?.value || '#00ffff';

                // Generate Creative Name
                const baseName = key.charAt(0).toUpperCase() + key.slice(1);
                let creativeName = baseName;

                try {
                    if (!this.prefixes) this.initNameGenerators();
                    if (this.prefixes && this.prefixes.length > 0) {
                        if (Math.random() > 0.5) {
                            const prefix = this.prefixes[Math.floor(Math.random() * this.prefixes.length)];
                            creativeName = `${prefix} ${baseName} `;
                        } else {
                            const suffix = this.suffixes[Math.floor(Math.random() * this.suffixes.length)];
                            creativeName = `${baseName} ${suffix} `;
                        }
                    }
                } catch (e) { console.warn("Name gen failed", e); }

                // Create stars with 3D Depth
                const newStars = points.map((p, i) => {
                    let zDepth = 0;
                    let xPos = p[0] - centroidX;
                    let yPos = p[1] - centroidY;
                    let pZ = (p[2] || 0) - centroidZ;

                    if (p.length >= 3) {
                        // Explicit Z from template data
                        zDepth = pZ * scale;
                    } else {
                        // Implicit 3D: Map 2D constellations onto a gentle celestial curve
                        // Calculate distance from center (which is now 0,0 locally)
                        const dist = Math.sqrt(xPos * xPos + yPos * yPos);
                        // Curve edges away
                        zDepth = -(dist * dist) * 0.05 * scale;
                    }

                    return {
                        id: Date.now() + i,
                        x: cx + xPos * scale,
                        y: cy + yPos * scale,
                        z: zDepth,
                        color: isRainbow ? this.getRainbowHex() : templateColor,
                        phase: Math.random() * Math.PI * 2,
                        clusterId: creativeName
                    };
                });

                this.stars = newStars;

                // Close panel
                document.getElementById('templatePanel').style.display = 'none';
                this.showToast(`Loaded ${key} template`);
                this.draw();
            }

            initNameGenerators() {
                this.prefixes = ["Alpha", "Beta", "Gamma", "Delta", "Neo", "Proto", "Hyper", "Cyber", "Dark", "Lost", "Royal", "Azure", "Crimson", "Void", "Solar", "Lunar", "Emerald", "Obsidian"];
                this.roots = ["Orion", "Cygnus", "Draco", "Lyra", "Vela", "Hydra", "Cetus", "Lupus", "Pavo", "Volans", "Aries", "Leo", "Gemini", "Ursa", "Vortex", "Helix", "Prism", "Shard", "Echo", "Serpens", "Phoenix"];
                this.suffixes = ["Major", "Minor", "Prime", "Zero", "Cluster", "Nebula", "Expanse", "Quadrant", "Sector", "Knot", "Web", "Crown", "Trident", "Gate", "Symphony", "Paradox"];
            }

            init() {
                window.addEventListener('resize', () => this.resize());

                // Pointer Events (CORRECT - these functions exist!)
                this.canvas.addEventListener('pointerdown', e => this.onPointerDown(e));
                window.addEventListener('pointermove', e => this.onPointerMove(e));
                window.addEventListener('pointerup', e => this.onPointerUp(e));
                this.canvas.addEventListener('wheel', e => {
                    console.log('[Zoom Event] Wheel event fired');
                    this.onWheel(e);
                }, { passive: false });
                this.canvas.addEventListener('contextmenu', e => this.onRightClick(e)); // Right-click deletion

                // Keyboard
                window.addEventListener('keydown', e => {
                    // Undo shortcut
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                        e.preventDefault();
                        this.undo();
                        return;
                    }

                    // Flight mode controls
                    if (this.flightMode) {
                        const key = e.key.toLowerCase();
                        if (key === 'u') {
                            this.toggleUpgradePanel();
                        } else {
                            this.keysPressed[key] = true;
                        }
                        e.preventDefault();
                    }
                });

                window.addEventListener('keyup', e => {
                    if (this.flightMode) {
                        const key = e.key.toLowerCase();
                        this.keysPressed[key] = false;
                    }
                });
                // Initial mode setup
                this.setMode('draw');
                // Initial color state setup
                this.updateColorModeUI();

                // Cyber speed slider
                this.matrixColorCustomized = false;

                // UI Events
                this.initDraggableWindows();

                // UI Events
                this.initDraggableWindows();

                // UI Events
                this.initDraggableWindows();

                // Make all panels resizable with 2D support
                this.makeResizable('floatingMap');
                this.makeResizable('floatingLeaders');
                this.makeResizable('sectionControls');
                this.makeResizable('sectionRadar');
                this.makeResizable('sectionVelocity');
                this.initGemsSectionResize(); // Special handling for gems

                document.querySelectorAll('.popup-panel').forEach(panel => {
                    if (panel.id) this.makeResizable(panel.id);
                });

                // Matrix (previously Cyber) speed slider
                const matrixSpeedSlider = document.getElementById('matrixSpeedSlider');
                if (matrixSpeedSlider) {
                    matrixSpeedSlider.addEventListener('input', (e) => {
                        this.matrixSpeedMultiplier = parseFloat(e.target.value);
                        document.getElementById('matrixSpeedValue').textContent = this.matrixSpeedMultiplier.toFixed(1) + 'x';
                    });
                }

                // Matrix length slider
                const matrixLengthSlider = document.getElementById('matrixLengthSlider');
                if (matrixLengthSlider) {
                    matrixLengthSlider.addEventListener('input', (e) => {
                        this.matrixLengthMultiplier = parseFloat(e.target.value);
                        document.getElementById('matrixLengthValue').textContent = this.matrixLengthMultiplier.toFixed(1) + 'x';
                    });
                }

                // Matrix angle slider
                const matrixAngleSlider = document.getElementById('matrixAngleSlider');
                if (matrixAngleSlider) {
                    matrixAngleSlider.addEventListener('input', (e) => {
                        this.matrixAngle = parseFloat(e.target.value);
                        document.getElementById('matrixAngleValue').textContent = this.matrixAngle + 'Â°';
                    });
                }

                // Ship color picker
                const shipColorPicker = document.getElementById('shipColorPicker');
                if (shipColorPicker) {
                    shipColorPicker.value = this.playerShip.color;
                    shipColorPicker.addEventListener('input', (e) => {
                        this.setShipColor(e.target.value);
                    });
                }

                // Initialize Camera picker
                const matrixColorPicker = document.getElementById('matrixColorPicker');
                const matrixColorHex = document.getElementById('matrixColorHex');
                if (matrixColorPicker) {
                    matrixColorPicker.addEventListener('input', (e) => {
                        this.matrixColor = e.target.value;
                        this.matrixColorCustomized = true;
                        if (matrixColorHex) matrixColorHex.value = e.target.value;
                        if (this.matrixStreams) this.matrixStreams.forEach(s => s.color = this.matrixColor);
                    });
                }
                if (matrixColorHex) {
                    matrixColorHex.addEventListener('input', (e) => {
                        let val = e.target.value;
                        if (val.match(/^#[0-9A-Fa-f]{6}$/)) {
                            this.matrixColor = val;
                            this.matrixColorCustomized = true;
                            if (matrixColorPicker) matrixColorPicker.value = val;
                            if (this.matrixStreams) this.matrixStreams.forEach(s => s.color = this.matrixColor);
                        }
                    });
                }

                // 3D Rotation sliders
                const rotXSlider = document.getElementById('rotXSlider');
                const rotYSlider = document.getElementById('rotYSlider');
                const rotZSlider = document.getElementById('rotZSlider');

                if (rotXSlider) {
                    rotXSlider.addEventListener('input', (e) => {
                        this.rotationX = parseFloat(e.target.value);
                        document.getElementById('rotXValue').textContent = this.rotationX + 'Â°';
                    });
                }
                if (rotYSlider) {
                    rotYSlider.addEventListener('input', (e) => {
                        this.rotationY = parseFloat(e.target.value);
                        document.getElementById('rotYValue').textContent = this.rotationY + 'Â°';
                    });
                }
                if (rotZSlider) {
                    rotZSlider.addEventListener('input', (e) => {
                        this.rotationZ = parseFloat(e.target.value);
                        document.getElementById('rotZValue').textContent = this.rotationZ + 'Â°';
                    });
                }

                // Init Mobile Controls
                this.initJoystick();

                // Trigger initial background generation
                this.resize();

                // Add Resize Listener
                window.addEventListener('resize', () => this.resize());

                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);
            }

            // Mobile Controls
            toggleMobileControls() {
                const joy = document.getElementById('joystick-container');
                if (joy) {
                    joy.style.display = joy.style.display === 'none' ? 'block' : 'none';
                }
            }

            initJoystick() {
                const base = document.getElementById('joystick-base');
                const stick = document.getElementById('joystick-stick');
                const container = document.getElementById('joystick-container');

                // Show joystick on init if likely mobile
                // We default to hidden in CSS, but check here
                if (window.innerWidth <= 768 && container) {
                    container.style.display = 'block';
                    this.joystickActive = true;
                }

                if (!base || !stick) return;

                let startX = 0, startY = 0;
                let moveX = 0, moveY = 0;
                const maxDist = 35; // Max movement radius

                const handleStart = (e) => {
                    e.preventDefault();
                    const touch = e.touches ? e.touches[0] : e;
                    startX = touch.clientX;
                    startY = touch.clientY;
                    this.joystickActive = true;
                };

                const handleMove = (e) => {
                    if (!this.joystickActive) return;
                    e.preventDefault();
                    const touch = e.touches ? e.touches[0] : e;

                    let dx = touch.clientX - startX;
                    let dy = touch.clientY - startY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > maxDist) {
                        dx = (dx / dist) * maxDist;
                        dy = (dy / dist) * maxDist;
                    }

                    stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

                    // Normalize -1 to 1
                    this.joyInputX = dx / maxDist;
                    this.joyInputY = dy / maxDist;
                };

                const handleEnd = (e) => {
                    e.preventDefault();
                    this.joystickActive = false;
                    this.joyInputX = 0;
                    this.joyInputY = 0;
                    stick.style.transform = `translate(-50%, -50%)`;
                };

                base.addEventListener('touchstart', handleStart, { passive: false });
                base.addEventListener('touchmove', handleMove, { passive: false });
                base.addEventListener('touchend', handleEnd, { passive: false });

                // Also mouse for testing
                base.addEventListener('mousedown', handleStart);
                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleEnd);
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                // Regenerate screen-space background (static stars) to ensure coverage
                this.staticStars = [];
                this.generateStaticStars();

                this.draw();
            }

            /**
             * FIX: Added the missing function to generate static background stars.
             * This method is now positioned explicitly before other methods that rely on it
             * (like resize) to ensure availability in sensitive execution environments.
             */
            generateStaticBackground() {
                const bgStars = [];
                const count = 300; // number of background stars
                for (let i = 0; i < count; i++) {
                    bgStars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: Math.random() * 0.5 + 0.1,
                        alpha: Math.random() * 0.5 + 0.2
                    });
                }
                return bgStars;
            }

            initDraggableWindows() {
                // Reusable drag function
                const makeDraggable = (elementId) => {
                    const element = document.getElementById(elementId);
                    if (!element) return;

                    // Find the header - it could be .window-header or .cockpit-header
                    const header = element.querySelector('.window-header, .cockpit-header');
                    if (!header) return;

                    let isDragging = false;
                    let startX, startY, initialX, initialY;

                    header.style.cursor = 'grab';

                    header.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        header.style.cursor = 'grabbing';
                        element.style.zIndex = '1000'; // Bring to front

                        startX = e.clientX;
                        startY = e.clientY;

                        const rect = element.getBoundingClientRect();
                        initialX = rect.left;
                        initialY = rect.top;

                        e.preventDefault();
                    });

                    window.addEventListener('mousemove', (e) => {
                        if (!isDragging) return;

                        const dx = e.clientX - startX;
                        const dy = e.clientY - startY;

                        element.style.left = (initialX + dx) + 'px';
                        element.style.top = (initialY + dy) + 'px';
                        element.style.bottom = 'auto'; // Remove bottom positioning
                        element.style.right = 'auto'; // Remove right positioning
                    });

                    window.addEventListener('mouseup', () => {
                        isDragging = false;
                        header.style.cursor = 'grab';
                    });
                };

                // Make all windows draggable
                makeDraggable('floatingMap');
                makeDraggable('floatingLeaders');
                makeDraggable('sectionControls');
                makeDraggable('sectionRadar');
                makeDraggable('sectionVelocity');
                makeDraggable('sectionGems');
            }

            setMode(newMode) {
                this.mode = newMode;
                document.getElementById('drawModeBtn').classList.remove('active');
                document.getElementById('selectModeBtn').classList.remove('active');

                if (newMode === 'draw') {
                    document.getElementById('drawModeBtn').classList.add('active');
                    this.canvas.style.cursor = 'crosshair';
                } else if (newMode === 'select') {
                    document.getElementById('selectModeBtn').classList.add('active');
                    this.canvas.style.cursor = 'pointer';
                }
            }

            /* --- NEW COLOR CONTROLS --- */

            getRainbowHex() {
                return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
            }

            setFixedColor(hexColor) {
                this.activeColor = hexColor;
                this.colorMode = 'fixed';
                this.updateColorModeUI();
                this.showToast(`Active color set to ${hexColor} `);
            }

            setRainbowMode() {
                this.colorMode = 'rainbow';
                this.updateColorModeUI();
                this.showToast("Active color set to Rainbow Mode ðŸŒˆ");
            }

            // ===== PROCEDURAL UNIVERSE GENERATION =====

            seededRandom(seed) {
                const x = Math.sin(seed) * 10000;
                return x - Math.floor(x);
            }

            getSectorCoords(worldX, worldY) {
                return {
                    x: Math.floor(worldX / this.sectorSize),
                    y: Math.floor(worldY / this.sectorSize)
                };
            }

            getSectorSeed(sectorX, sectorY) {
                return sectorX * 73856093 ^ sectorY * 19349663;
            }

            checkAndGenerateSectors() {
                if (!this.flightMode) return;

                const sector = this.getSectorCoords(this.playerShip.x, this.playerShip.y);
                this.currentSector = sector;

                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const sx = sector.x + dx;
                        const sy = sector.y + dy;
                        const key = `${sx},${sy} `;
                        if (!this.loadedSectors.has(key)) {
                            this.generateSector(sx, sy);
                        }
                    }
                }

                for (const [key] of this.loadedSectors.entries()) {
                    const [sx, sy] = key.split(',').map(Number);
                    const dist = Math.max(Math.abs(sx - sector.x), Math.abs(sy - sector.y));
                    if (dist > 2) {
                        const sectorData = this.loadedSectors.get(key);
                        if (sectorData) {
                            this.minerals = this.minerals.filter(m => !sectorData.minerals.includes(m));
                            this.resourceDeposits = this.resourceDeposits.filter(d => !sectorData.deposits.includes(d));
                        }
                        this.loadedSectors.delete(key);
                    }
                }
            }

            generateSector(sectorX, sectorY) {
                const key = `${sectorX},${sectorY} `;
                if (this.loadedSectors.has(key)) return;

                console.log(`[Universe] Generating sector(${sectorX}, ${sectorY})`);

                const seed = this.getSectorSeed(sectorX, sectorY);
                const sectorData = { x: sectorX, y: sectorY, minerals: [], deposits: [] };

                const minX = sectorX * this.sectorSize;
                const maxX = (sectorX + 1) * this.sectorSize;
                const minY = sectorY * this.sectorSize;
                const maxY = (sectorY + 1) * this.sectorSize;

                const mineralCount = Math.floor(100 + this.seededRandom(seed + 1) * 200);
                for (let i = 0; i < mineralCount; i++) {
                    const s = seed + i * 1000;
                    const x = minX + this.seededRandom(s) * this.sectorSize;
                    const y = minY + this.seededRandom(s + 1) * this.sectorSize;
                    const dist = Math.hypot(x, y);

                    let type = 'iron';
                    const r = this.seededRandom(s + 2);
                    if (dist < 1000) type = ['iron', 'copper', 'coal', 'titanium', 'silicon'][Math.floor(r * 5)];
                    else if (dist < 3000) type = ['silver', 'gold', 'platinum', 'palladium'][Math.floor(r * 4)];
                    else if (dist < 6000) type = ['quartz', 'diamond', 'emerald', 'ruby', 'sapphire'][Math.floor(r * 5)];
                    else if (dist < 10000) type = ['uranium', 'plutonium', 'helium3'][Math.floor(r * 3)];
                    else type = ['neodymium', 'lanthanum', 'darkmatter', 'antimatter'][Math.floor(r * 4)];

                    const info = this.mineralTypes[type];
                    if (!info) continue;

                    const mineral = { x, y, type, color: info.color, size: info.size, value: info.value };
                    this.minerals.push(mineral);
                    sectorData.minerals.push(mineral);
                }

                const depositCount = Math.floor(3 + this.seededRandom(seed + 500000) * 5);
                for (let i = 0; i < depositCount; i++) {
                    const s = seed + 500000 + i * 2000;
                    const x = minX + this.seededRandom(s) * this.sectorSize;
                    const y = minY + this.seededRandom(s + 1) * this.sectorSize;
                    const dist = Math.hypot(x, y);

                    let zone = 'industrial';
                    if (dist >= 8000) zone = 'exotic';
                    else if (dist >= 5000) zone = 'nuclear';
                    else if (dist >= 2500) zone = 'crystal';
                    else if (dist >= 1000) zone = 'precious';

                    const richness = 0.3 + this.seededRandom(s + 2) * 0.7;
                    const deposit = {
                        x, y, zone,
                        name: `${this.galaxyZones[zone]?.name || zone} Deposit`,
                        richness,
                        tier: Math.floor(richness * 3) + 1
                    };

                    this.resourceDeposits.push(deposit);
                    sectorData.deposits.push(deposit);
                }

                this.loadedSectors.set(key, sectorData);
                console.log(`[Universe] Sector(${sectorX}, ${sectorY}): ${mineralCount} minerals, ${depositCount} deposits`);
            }

            toggleBgStyle(style) {
                console.log(`[BG Toggle] ${style}, currently active: `, this.activeStyles.has(style));
                if (this.activeStyles.has(style)) {
                    // Deselecting - just remove from active, don't regenerate others
                    this.activeStyles.delete(style);
                    // Clear only this style's data
                    this.clearStyleData(style);
                } else {
                    // Enabling - only generate this specific style
                    this.activeStyles.add(style);
                    this.generateSingleStyle(style);
                }

                this.updateBgUI();
                this.generateStaticStars(); // Refresh static stars for color mix
            }

            // Generate only a single style's data
            generateSingleStyle(style) {
                switch (style) {
                    case 'deep-space':
                        this.generateDeepSpaceStyle();
                        break;
                    case 'nebula':
                        this.generateNebulaStyle();
                        break;
                    case 'alien':
                        this.generateAlienStyle();
                        break;
                    case 'cyber':
                        this.generateCyberStyle();
                        break;
                }
            }

            // Clear only a specific style's data
            clearStyleData(style) {
                switch (style) {
                    case 'deep-space':
                        // Deep space uses: galaxies, blackHoles, planets, and contributes to nebulae/backgroundStars
                        this.galaxies = [];
                        this.blackHoles = [];
                        this.planets = [];
                        break;
                    case 'nebula':
                        // Clear nebula clouds
                        this.nebulae = [];
                        break;
                    case 'alien':
                        this.spacecraft = [];
                        break;
                    case 'cyber':
                        this.matrixStreams = [];
                        break;
                }
            }

            updateBgUI() {
                // Update Buttons
                document.querySelectorAll('.bg-toggle').forEach(btn => {
                    const style = btn.getAttribute('data-style');
                    if (this.activeStyles.has(style)) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });

                // Show/hide matrix panel when cyber style is active
                const matrixPanel = document.getElementById('matrixPanel');
                if (matrixPanel) {
                    if (this.activeStyles.has('cyber')) {
                        matrixPanel.classList.remove('hidden');
                    } else {
                        matrixPanel.classList.add('hidden');
                    }
                }
            }

            // Toggle functions for popup panels
            toggleRotationPanel() {
                const panel = document.getElementById('rotationPanel');
                if (panel) panel.classList.toggle('hidden');
            }

            toggleTemplatePanel() {
                const panel = document.getElementById('templatePanel');
                if (panel.style.display === 'block') {
                    panel.style.display = 'none';
                } else {
                    panel.style.display = 'block';
                }
            }

            toggleFlightMode() {
                this.flightMode = !this.flightMode;

                // Toggle HUD overlay
                const hud = document.getElementById('flightHUD');
                const floatingMap = document.getElementById('floatingMap');
                const floatingLeaders = document.getElementById('floatingLeaders');

                if (this.flightMode) {
                    if (hud) hud.classList.remove('hidden');
                    if (floatingMap) floatingMap.classList.remove('hidden');
                    if (floatingLeaders) floatingLeaders.classList.remove('hidden');
                    this.updateFloatingLeaderboard();
                } else {
                    if (hud) hud.classList.add('hidden');
                    if (floatingMap) floatingMap.classList.add('hidden');
                    if (floatingLeaders) floatingLeaders.classList.add('hidden');
                }

                // Ensure a background is active
                if (this.flightMode && this.activeStyles.size === 0) {
                    this.toggleBgStyle('deep-space');
                }

                this.showToast(this.flightMode ? 'Flight Mode: ON - Use WASD/QE/Shift' : 'Flight Mode: OFF');

                // Toggle ship button visibility
                const shipBtn = document.getElementById('selectShipBtn');
                if (shipBtn) shipBtn.style.display = this.flightMode ? 'inline-flex' : 'none';
                this.draw();
            }

            // Toggle cockpit section collapse
            toggleCockpitSection(sectionId) {
                const section = document.getElementById(sectionId);
                if (section) section.classList.toggle('collapsed');
            }

            toggleGemValues() {
                this.showGemValues = !this.showGemValues;
                this.updateFlightHUD(); // Refresh display
                const btn = document.getElementById('btnToggleGemValues');
                if (btn) {
                    btn.style.background = this.showGemValues ? 'rgba(255,215,0,0.3)' : '';
                }
            }

            initGemsSectionResize() {
                const gemsSection = document.getElementById('sectionGems');
                const resizeHandle = gemsSection?.querySelector('.resize-handle');
                if (!gemsSection || !resizeHandle) return;

                let isResizing = false;
                let startX, startY, startWidth, startHeight;

                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startWidth = gemsSection.offsetWidth;
                    startHeight = gemsSection.offsetHeight;
                    e.preventDefault();
                    e.stopPropagation();
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;

                    // Support both horizontal AND vertical resizing
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
                    const newHeight = Math.max(150, Math.min(600, startHeight + deltaY));

                    gemsSection.style.width = newWidth + 'px';
                    gemsSection.style.height = newHeight + 'px';
                });

                window.addEventListener('mouseup', () => {
                    isResizing = false;
                });
            }

            // Universal resize system for ALL panels
            makeResizable(elementId) {
                const element = document.getElementById(elementId);
                if (!element) return;

                // Add resize handle if it doesn't exist
                let resizeHandle = element.querySelector('.resize-handle');
                if (!resizeHandle) {
                    resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    resizeHandle.style.cssText = 'position:absolute; right:0; bottom:0; width:16px; height:16px; cursor:nwse-resize; background: linear-gradient(135deg, transparent 50%, rgba(0,243,255,0.5) 50%); z-index:10;';
                    element.appendChild(resizeHandle);
                }

                let isResizing = false;
                let startX, startY, startWidth, startHeight;

                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startWidth = element.offsetWidth;
                    startHeight = element.offsetHeight;
                    e.preventDefault();
                    e.stopPropagation();
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;

                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    const newWidth = Math.max(200, Math.min(1200, startWidth + deltaX));
                    const newHeight = Math.max(150, Math.min(800, startHeight + deltaY));

                    element.style.width = newWidth + 'px';
                    element.style.height = newHeight + 'px';
                });

                window.addEventListener('mouseup', () => {
                    isResizing = false;
                });
            }

            // Toggle floating window collapse
            toggleFloatingWindow(windowId) {
                const win = document.getElementById(windowId);
                if (win) win.classList.toggle('collapsed');
            }

            // Spacecraft color customization
            setShipColor(color) {
                this.playerShip.color = color;
                localStorage.setItem('playerShipColor', color); // Fixed Key
            }

            resetShipColor() {
                const defaultColor = '#00f3ff';
                this.playerShip.color = defaultColor;
                localStorage.setItem('playerShipColor', defaultColor); // Fixed Key
                document.getElementById('shipColorPicker').value = defaultColor;
                this.showToast('Ship color reset to default');
            }

            // Helper to adjust color brightness
            adjustColor(hex, amount) {
                const num = parseInt(hex.replace('#', ''), 16);
                const r = Math.min(255, Math.max(0, (num >> 16) + amount));
                const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));
                const b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));
                return `#${(r << 16 | g << 8 | b).toString(16).padStart(6, '0')} `;
            }

            // Gem emoji mapping
            getGemEmoji(type) {
                const emojis = {
                    // Industrial
                    iron: 'âš™ï¸',
                    copper: 'ðŸŸ ',
                    coal: 'â¬›',
                    titanium: 'ðŸ”©',
                    silicon: 'ðŸ”²',
                    // Precious
                    silver: 'âšª',
                    gold: 'ðŸ¥‡',
                    platinum: 'ðŸ’¿',
                    palladium: 'ðŸª™',
                    // Crystal
                    quartz: 'ðŸ”®',
                    diamond: 'ðŸ’Ž',
                    emerald: 'ðŸ’š',
                    ruby: 'â¤ï¸',
                    sapphire: 'ðŸ’™',
                    // Nuclear
                    uranium: 'â˜¢ï¸',
                    plutonium: 'âš›ï¸',
                    helium3: 'ðŸ’¨',
                    // Exotic
                    neodymium: 'ðŸ’–',
                    lanthanum: 'ðŸ’œ',
                    darkmatter: 'ðŸŒ‘',
                    antimatter: 'âœ¨'
                };
                // No longer used, replaced by CSS icons
                return '';
            }

            styleGem(type) {
                const info = this.mineralTypes[type];
                if (!info) return '';
                // Create a glowing orb effect matching in-game rendering
                return `background: radial-gradient(circle at 30% 30%, #fff 10%, ${info.color} 60%);
                box-shadow: 0 0 4px ${info.color};
                border-radius: 50%;
                width: 12px;
                height: 12px;
                display: inline-block;`;
            }

            updateFlightHUD() {
                if (!this.flightMode) return;


                // Update speed number
                const speedNumEl = document.getElementById('speedNumber');
                const zoomEl = document.getElementById('zoomDisplay');
                if (speedNumEl) {
                    speedNumEl.textContent = Math.round(this.playerShip.speed);
                }
                if (zoomEl) {
                    zoomEl.textContent = this.camera.zoom.toFixed(1) + 'x';
                }

                // Update radar coordinates
                const coordsEl = document.getElementById('radarCoords');
                if (coordsEl) {
                    coordsEl.textContent = `X: ${Math.round(this.playerShip.x)} Y: ${Math.round(this.playerShip.y)} `;
                }

                // Update gems grid with proper emojis
                this.updateWalletUI();
                this.updateInventoryUI();

                // Update radar
                this.updateRadar();

                // Update map
                this.updateMap();

                // Initialize resize handle for gems section
                if (this.initGemsSectionResize) this.initGemsSectionResize();
            }

            updateRadar() {
                const canvas = document.getElementById('radarCanvas');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width, h = canvas.height;
                const cx = w / 2, cy = h / 2;

                // Clear
                ctx.clearRect(0, 0, w, h);

                // Draw grid lines
                ctx.strokeStyle = 'rgba(0,255,100,0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(cx, 0); ctx.lineTo(cx, h);
                ctx.moveTo(0, cy); ctx.lineTo(w, cy);
                ctx.arc(cx, cy, 20, 0, Math.PI * 2);
                ctx.arc(cx, cy, 35, 0, Math.PI * 2);
                ctx.stroke();

                // Draw player (center)
                ctx.fillStyle = '#0f0';
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fill();

                // Draw nearby minerals as dots
                const radarRange = 2000;
                this.minerals.forEach(m => {
                    const dx = m.x - this.playerShip.x;
                    const dy = m.y - this.playerShip.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < radarRange) {
                        const rx = cx + (dx / radarRange) * 35;
                        const ry = cy + (dy / radarRange) * 35;
                        ctx.fillStyle = m.color || '#f0f';
                        ctx.beginPath();
                        ctx.arc(rx, ry, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }

            generateResourceDeposits() {
                this.resourceDeposits = [];

                // TIER 1: Starting ring (30s-1min travel)
                // Distance: 2000-4000 units (expanded outward)
                // 12 clusters evenly distributed
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2 + Math.random() * 0.2;
                    const dist = 2000 + Math.random() * 2000;
                    this.resourceDeposits.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist,
                        z: (Math.random() - 0.5) * 400,
                        zone: 'industrial',
                        radius: 700,
                        richness: 1.5,
                        tier: 1,
                        value: 'low',
                        name: `Common Field ${i + 1} `
                    });
                }

                // TIER 2: Inner belt (1-2min travel)
                // Distance: 5000-8000 units (wider spread)
                // 10 clusters
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2 + Math.random() * 0.3;
                    const dist = 5000 + Math.random() * 3000;
                    const zone = Math.random() < 0.5 ? 'precious' : 'crystal';
                    this.resourceDeposits.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist,
                        z: (Math.random() - 0.5) * 600,
                        zone: zone,
                        radius: 800,
                        richness: 2.0,
                        tier: 2,
                        value: 'medium',
                        name: `Rich Cluster ${i + 1} `
                    });
                }

                // TIER 3: Mid expanse (2-4min travel)
                // Distance: 10000-15000 units
                // 8 clusters
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + Math.random() * 0.4;
                    const dist = 10000 + Math.random() * 5000;
                    const zone = Math.random() < 0.5 ? 'nuclear' : 'crystal';
                    this.resourceDeposits.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist,
                        z: (Math.random() - 0.5) * 800,
                        zone: zone,
                        radius: 900,
                        richness: 3.0,
                        tier: 3,
                        value: 'high',
                        name: `Epic Cache ${i + 1} `
                    });
                }

                // TIER 4: Outer frontier (4-6min travel)
                // Distance: 18000-25000 units  
                // 6 clusters - Epic/Legendary
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 + Math.random() * 0.5;
                    const dist = 18000 + Math.random() * 7000;
                    this.resourceDeposits.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist,
                        z: (Math.random() - 0.5) * 1000,
                        zone: 'nuclear',
                        radius: 1000,
                        richness: 4.5,
                        tier: 4,
                        value: 'legendary',
                        name: `Legendary Cache ${i + 1} `
                    });
                }

                // TIER 5: Deep void (6-10min travel)
                // Distance: 28000-38000 units
                // 4 clusters - Legendary/Mythic
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 + Math.random() * 0.6;
                    const dist = 28000 + Math.random() * 10000;
                    this.resourceDeposits.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist,
                        z: (Math.random() - 0.5) * 1500,
                        zone: 'exotic',
                        radius: 1200,
                        richness: 6.0,
                        tier: 5,
                        value: 'mythic',
                        name: `Mythic Treasure ${i + 1} `
                    });
                }

                // TIER 6: Distant galaxies (10-15min travel)
                // Distance: 42000-50000 units
                // 3 ultra-rare clusters - Pure mythic
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2 + Math.random() * 0.8;
                    const dist = 42000 + Math.random() * 8000;
                    this.resourceDeposits.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist,
                        z: (Math.random() - 0.5) * 2000,
                        zone: 'exotic',
                        radius: 1500,
                        richness: 8.0, // 8x rarity - INSANE!
                        tier: 6,
                        value: 'ultra-mythic',
                        name: `Galaxy Core ${i + 1} `
                    });
                }

                console.log(`[Universe] Generated ${this.resourceDeposits.length} gem clusters across 50,000 units`);
            }

            updateMap() {
                const canvas = document.getElementById('mapCanvas');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width, h = canvas.height;
                const cx = w / 2, cy = h / 2;

                const mapRadius = 50000; // Increased to show entire universe
                const scale = (Math.min(w, h) / 2) / mapRadius;

                // Clear
                ctx.fillStyle = 'rgba(0,5,20,0.95)';
                ctx.fillRect(0, 0, w, h);

                // Offset to center on player
                const offsetX = -this.playerShip.x;
                const offsetY = -this.playerShip.y;

                // Draw Zones (centered at origin) - REDUCED OPACITY
                Object.values(this.galaxyZones).forEach(zone => {
                    const r = zone.distanceRange.min * scale;
                    ctx.beginPath();
                    ctx.arc(cx + offsetX * scale, cy + offsetY * scale, r, 0, Math.PI * 2);
                    ctx.strokeStyle = zone.color;
                    ctx.globalAlpha = 0.08; // Much more subtle
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });

                // Draw Minerals (gems) - FILTERED
                // Only draw minerals if zoomed in or if they are high value to reduce noise
                this.minerals.forEach(mineral => {
                    const dx = (mineral.x + offsetX) * scale;
                    const dy = (mineral.y + offsetY) * scale;

                    // Skip if off screen
                    if (Math.abs(dx) > w / 2 || Math.abs(dy) > h / 2) return;

                    // Skip low value minerals on zoomed out map
                    if (scale < 0.0005 && ['quartz', 'iron'].includes(mineral.type)) return;

                    ctx.fillStyle = mineral.color;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.arc(cx + dx, cy + dy, 2, 0, Math.PI * 2); // Smaller dots
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                // Draw Deposits LAST - larger, foreground layer (CLUSTERS)
                this.resourceDeposits.forEach(dep => {
                    const dx = (dep.x + offsetX) * scale;
                    const dy = (dep.y + offsetY) * scale;

                    if (Math.abs(dx) > w / 2 || Math.abs(dy) > h / 2) return;

                    // Tier-based colors
                    let color, glowColor, label, labelText;
                    switch (dep.tier) {
                        case 1: color = '#4488ff'; glowColor = '#6699ff'; label = 'C'; labelText = 'Common'; break;
                        case 2: color = '#ff66ff'; glowColor = '#ff88ff'; label = 'R'; labelText = 'Rich'; break;
                        case 3: color = '#ffaa00'; glowColor = '#ffcc44'; label = 'E'; labelText = 'Epic'; break;
                        case 4: color = '#ff4400'; glowColor = '#ff6644'; label = 'L'; labelText = 'Legendary'; break;
                        case 5: color = '#ff00ff'; glowColor = '#ff44ff'; label = 'M'; labelText = 'Mythic'; break;
                        case 6: color = '#00ffff'; glowColor = '#44ffff'; label = 'G'; labelText = 'Galaxy'; break;
                        default: color = '#00f'; glowColor = '#44f'; label = '?'; labelText = 'Unknown'; break;
                    }

                    // Pulsing glow - Subtle now
                    const pulse = 1 + Math.sin(Date.now() * 0.002) * 0.2;

                    // Outer glow
                    ctx.fillStyle = glowColor;
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.arc(cx + dx, cy + dy, (4 + dep.tier) * pulse, 0, Math.PI * 2);
                    ctx.fill();

                    // Solid Core Icon (Diamond)
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = color;
                    const size = 3 + dep.tier; // Scaled by importance
                    ctx.beginPath();
                    ctx.moveTo(cx + dx, cy + dy - size);
                    ctx.lineTo(cx + dx + size, cy + dy);
                    ctx.lineTo(cx + dx, cy + dy + size);
                    ctx.lineTo(cx + dx - size, cy + dy);
                    ctx.closePath();
                    ctx.fill();

                    // Label - Only show text if nearby or high tier
                    // Simplified logic: show full text only on hover-ish distance or high tier
                    // For now, just show single Letter code unless really important
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(label, cx + dx, cy + dy);
                });
                ctx.globalAlpha = 1;

                // Draw Player (now always at center) - PROMINENT
                const px = cx;
                const py = cy;

                // Strong Glow for visibility over everything
                ctx.save();
                ctx.translate(px, py);

                // Pulsing outer ring
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 10 + Math.sin(Date.now() * 0.005) * 2, 0, Math.PI * 2);
                ctx.stroke();

                // Player Arrow
                ctx.rotate(this.playerShip.rotation + Math.PI / 2);
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'white';
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                // Larger size (approx 3x previous size)
                ctx.moveTo(0, -12);
                ctx.lineTo(8, 8);
                ctx.lineTo(0, 4);
                ctx.lineTo(-8, 8);
                ctx.fill();
                ctx.restore();
                ctx.stroke();
            }

            /* --- EXPANDED MAP --- */
            openExpandedMap() {
                console.log('[Expand Map] Button clicked!');
                const modal = document.getElementById('expandedMapModal');
                console.log('[Expand Map] Modal element:', modal);

                if (modal) {
                    modal.classList.remove('hidden');
                    this.expandedMapOpen = true;
                    this.expandedMapZoom = this.expandedMapZoom || 1.0;
                    this.expandedMapOffset = this.expandedMapOffset || { x: 0, y: 0 };

                    // Center on player initially
                    this.expandedMapOffset.x = -this.playerShip.x;
                    this.expandedMapOffset.y = -this.playerShip.y;

                    console.log('[Expand Map] Starting animation, zoom:', this.expandedMapZoom);
                    this.animateExpandedMap();

                    // Add wheel listener for zoom
                    if (!this.mapWheelListener) {
                        this.mapWheelListener = (e) => {
                            e.preventDefault();
                            const zoomSpeed = 0.1;
                            const newZoom = Math.max(0.2, Math.min(10.0, this.expandedMapZoom - Math.sign(e.deltaY) * zoomSpeed));
                            this.expandedMapZoom = newZoom;
                            document.getElementById('mapZoomLevel').textContent = `Zoom: ${this.expandedMapZoom.toFixed(1)} x`;
                        };
                        const canvas = document.getElementById('fullscreenMapCanvas');
                        canvas.addEventListener('wheel', this.mapWheelListener);

                        // Dragging Logic
                        this.isDraggingMap = false;
                        this.lastMapMouse = { x: 0, y: 0 };

                        canvas.addEventListener('mousedown', (e) => {
                            this.isDraggingMap = true;
                            this.lastMapMouse = { x: e.clientX, y: e.clientY };
                            canvas.style.cursor = 'grabbing';
                        });

                        window.addEventListener('mousemove', (e) => {
                            if (!this.isDraggingMap) return;
                            const dx = e.clientX - this.lastMapMouse.x;
                            const dy = e.clientY - this.lastMapMouse.y;
                            this.lastMapMouse = { x: e.clientX, y: e.clientY };

                            // Adjust offset (pan)
                            this.expandedMapOffset.x += dx / this.expandedMapZoom;
                            this.expandedMapOffset.y += dy / this.expandedMapZoom;
                        });

                        window.addEventListener('mouseup', () => {
                            this.isDraggingMap = false;
                            canvas.style.cursor = 'grab';
                        });
                    }
                }
            }

            closeExpandedMap() {
                const modal = document.getElementById('expandedMapModal');
                if (modal) {
                    modal.classList.add('hidden');
                    this.expandedMapOpen = false;
                }
            }

            animateExpandedMap() {
                if (!this.expandedMapOpen) return;

                const canvas = document.getElementById('fullscreenMapCanvas');
                if (!canvas) {
                    console.error('[Map Debug] Canvas not found');
                    return;
                }

                console.log('[Map Debug] Rendering expanded map, zoom:', this.expandedMapZoom);

                // Resize if needed (handle dynamic window resizing)
                if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                }

                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                const cx = w / 2;
                const cy = h / 2;
                const zoom = this.expandedMapZoom;
                const time = Date.now() * 0.001;

                // --- 1. DEEP SPACE BACKGROUND ---
                // Clear with a deep, rich gradient based on player position (subtle shift)
                const bgGradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(w, h));
                bgGradient.addColorStop(0, '#000810');
                bgGradient.addColorStop(0.6, '#000508');
                bgGradient.addColorStop(1, '#000000');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, w, h);

                ctx.save();
                ctx.translate(cx, cy);
                ctx.scale(zoom, zoom);
                ctx.translate(this.expandedMapOffset.x, this.expandedMapOffset.y);

                // --- 2. PARALLAX STARFIELD (Background Layers) ---
                // We generate pseudo-random stars based on world coordinates to create an infinite field
                // Layer 1: Distant, slow moving
                this.renderMapStars(ctx, 0.5, 0.5, 5000, 15000, '#445566');
                // Layer 2: Mid-distance
                this.renderMapStars(ctx, 0.3, 0.8, 3000, 10000, '#6688aa');

                // --- 3. ZONE ATMOSPHERICS ---
                // Draw large, soft radial glows for each zone to give "territory" feel
                Object.values(this.galaxyZones).forEach(zone => {
                    const dist = zone.distanceRange.min;
                    // Skip if way off screen
                    // Simple cull: check distance from center of screen in world space to zone center (0,0)
                    // But zones are concentric rings, so we just draw them.

                    ctx.beginPath();
                    ctx.arc(0, 0, dist, 0, Math.PI * 2);
                    ctx.fillStyle = zone.glowColor || zone.color;
                    ctx.globalAlpha = 0.03; // Very subtle atmosphere
                    ctx.lineWidth = 100; // Wide soft edge
                    ctx.fill();

                    // Zone Boundary Ring
                    ctx.beginPath();
                    ctx.arc(0, 0, dist, 0, Math.PI * 2);
                    ctx.strokeStyle = zone.color;
                    ctx.lineWidth = 2 / zoom; // Keep thin regardless of zoom
                    ctx.globalAlpha = 0.2;
                    ctx.setLineDash([20, 40]); // Dashed border
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Zone Label (Floating in space)
                    // Place label at the top of the ring
                    ctx.fillStyle = zone.color;
                    ctx.font = `bold ${64}px Orbitron`;
                    ctx.textAlign = 'center';
                    ctx.globalAlpha = 0.4;
                    ctx.fillText(zone.name.toUpperCase(), 0, -dist + 200);
                });

                // --- 4. HOLO-GRID ---
                // A perspective grid. Since this is 2D top-down, we draw a rectangular grid that pans.
                ctx.strokeStyle = 'rgba(0, 243, 255, 0.08)';
                ctx.lineWidth = 1 / zoom;
                const gridSize = 1000;

                // Calculate visible range to optimize rendering
                // Visible world center: -this.expandedMapOffset.x, -this.expandedMapOffset.y
                const worldCx = -this.expandedMapOffset.x;
                const worldCy = -this.expandedMapOffset.y;
                const visibleW = w / zoom;
                const visibleH = h / zoom;

                const startX = Math.floor((worldCx - visibleW) / gridSize) * gridSize;
                const endX = Math.floor((worldCx + visibleW) / gridSize) * gridSize;
                const startY = Math.floor((worldCy - visibleH) / gridSize) * gridSize;
                const endY = Math.floor((worldCy + visibleH) / gridSize) * gridSize;

                ctx.beginPath();
                for (let x = startX; x <= endX; x += gridSize) {
                    ctx.moveTo(x, startY);
                    ctx.lineTo(x, endY);
                }
                for (let y = startY; y <= endY; y += gridSize) {
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                }
                ctx.stroke();


                // --- 5. ORBITAL MECHANICS & PLANETS (Cosmetic) ---
                // Procedural planets based on zone
                // We'll use a deterministic random based on index/position
                // (Simplified for now: drawing a few fixed 'planets' per zone would be better but random serves 'world' feel)

                // --- 6. RESOURCE DEPOSITS (Advanced Icons) ---
                this.resourceDeposits.forEach(dep => {
                    // Pulsing effect
                    const pulse = 1 + Math.sin(time * 3 + dep.x * 0.01) * 0.2;

                    // Deposit Glow
                    const zoneColor = this.galaxyZones[dep.zone] ? this.galaxyZones[dep.zone].color : '#fff';
                    const glowColor = this.galaxyZones[dep.zone] ? (this.galaxyZones[dep.zone].glowColor || zoneColor) : '#fff';

                    // Draw outer glow
                    const grad = ctx.createRadialGradient(dep.x, dep.y, 5 * pulse, dep.x, dep.y, 30 * pulse);
                    grad.addColorStop(0, glowColor);
                    grad.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = grad;
                    ctx.globalAlpha = 0.4;
                    ctx.beginPath();
                    ctx.arc(dep.x, dep.y, 40 * pulse, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw core icon (Diamond shape)
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = zoneColor;
                    const size = 12;
                    ctx.beginPath();
                    ctx.moveTo(dep.x, dep.y - size);
                    ctx.lineTo(dep.x + size, dep.y);
                    ctx.lineTo(dep.x, dep.y + size);
                    ctx.lineTo(dep.x - size, dep.y);
                    ctx.closePath();
                    ctx.fill();

                    // Label
                    if (zoom > 0.8) {
                        ctx.fillStyle = '#fff';
                        ctx.font = '14px "Segoe UI", sans-serif'; // Cleaner font
                        ctx.textAlign = 'center';
                        ctx.fillText(dep.name, dep.x, dep.y + 40);

                        ctx.font = '10px "Segoe UI", sans-serif';
                        ctx.fillStyle = '#aaa';
                        ctx.fillText(`Richness: ${(dep.richness * 100).toFixed(0)}% `, dep.x, dep.y + 55);
                    }
                });

                // --- 6.5. MINERALS/GEMS (Navigation Aid) ---
                // Show minerals on the map with proper color coding
                this.minerals.forEach(mineral => {
                    const mineralInfo = this.mineralTypes[mineral.type];
                    if (!mineralInfo) return;

                    // Glow effect for visibility
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle = mineralInfo.color;
                    ctx.beginPath();
                    ctx.arc(mineral.x, mineral.y, 8 / zoom, 0, Math.PI * 2);
                    ctx.fill();

                    // Solid marker
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.arc(mineral.x, mineral.y, 4 / zoom, 0, Math.PI * 2);
                    ctx.fill();

                    // Show gem type label at higher zoom
                    if (zoom > 1.5) {
                        ctx.fillStyle = '#fff';
                        ctx.font = `${10 / zoom}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.fillText(mineralInfo.name, mineral.x, mineral.y - 10 / zoom);
                    }
                });
                ctx.globalAlpha = 1.0;

                // --- 7. PLAYER SHIP (Detailed HUD Marker) ---
                const shipX = this.playerShip.x;
                const shipY = this.playerShip.y;

                ctx.translate(shipX, shipY);

                // View Cone (Field of View)
                const fovRadius = 400;
                ctx.rotate(this.playerShip.rotation + Math.PI / 2); // Align with ship heading

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, fovRadius, -Math.PI / 6, Math.PI / 6); // 60 degree cone
                ctx.fillStyle = 'rgba(0, 255, 100, 0.1)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 255, 100, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Ship Icon (Triangle)
                ctx.beginPath();
                ctx.moveTo(0, -20);
                ctx.lineTo(14, 14);
                ctx.lineTo(0, 8);
                ctx.lineTo(-14, 14);
                ctx.closePath();
                ctx.fillStyle = '#0f0';
                ctx.shadowColor = '#0f0';
                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.shadowBlur = 0; // Reset

                ctx.restore();

                // --- 8. UI OVERLAYS (Screen Space) ---
                // Coordinates Overlay (Fixed to screen corners)
                ctx.font = '14px Consolas, monospace';
                ctx.fillStyle = 'rgba(0, 243, 255, 0.8)';
                ctx.textAlign = 'left';
                ctx.fillText(`SECTOR: [${Math.floor(shipX / 5000)}, ${Math.floor(shipY / 5000)}]`, 20, h - 60);
                ctx.fillText(`COORDS: X ${Math.round(shipX)}  Y ${Math.round(shipY)} `, 20, h - 40);

                // Scale Bar
                const scaleWidth = 200; // pixels
                const scaleDistance = scaleWidth / zoom;
                ctx.beginPath();
                ctx.moveTo(w - 220, h - 40);
                ctx.lineTo(w - 20, h - 40);
                ctx.moveTo(w - 220, h - 45);
                ctx.lineTo(w - 220, h - 35);
                ctx.moveTo(w - 20, h - 45);
                ctx.lineTo(w - 20, h - 35);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.textAlign = 'center';
                ctx.fillStyle = '#fff';
                ctx.fillText(`${Math.round(scaleDistance)} km`, w - 120, h - 50);

                requestAnimationFrame(() => this.animateExpandedMap());
            }

            // Helper for infinite starfield in map
            renderMapStars(ctx, opacity, parallax, spacing, modX, color) {
                const worldCx = -this.expandedMapOffset.x * parallax;
                const worldCy = -this.expandedMapOffset.y * parallax;
                const w = ctx.canvas.width / this.expandedMapZoom;
                const h = ctx.canvas.height / this.expandedMapZoom;

                // Simple deterministic "hash" for visuals without storing millions of stars
                // We assume stars are on a grid with jitter
                const startX = Math.floor((worldCx - w) / spacing);
                const endX = Math.floor((worldCx + w) / spacing);
                const startY = Math.floor((worldCy - h) / spacing);
                const endY = Math.floor((worldCy + h) / spacing);

                ctx.fillStyle = color;

                for (let x = startX; x <= endX; x++) {
                    for (let y = startY; y <= endY; y++) {
                        // Deterministic random
                        const seed = x * 34234 + y * 23123;
                        const rx = Math.sin(seed) * spacing;
                        const ry = Math.cos(seed * 0.5) * spacing;
                        const size = (Math.sin(seed * 1.5) + 1.5);

                        ctx.globalAlpha = opacity * (0.5 + Math.sin(seed * 0.1) * 0.5);
                        ctx.beginPath();
                        ctx.arc(x * spacing + rx, y * spacing + ry, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                ctx.globalAlpha = 1.0;
            }

            updateFloatingLeaderboard() {
                const listEl = document.getElementById('floatingLeadersList');
                if (!listEl) return;

                // Mock leaderboard with fluctuating wealth
                const mockPlayers = [
                    { name: 'StarPilot99', wealth: 125000 + Math.floor(Math.random() * 10000) },
                    { name: 'NebulaHunter', wealth: 98000 + Math.floor(Math.random() * 8000) },
                    { name: 'AstroMiner', wealth: 76000 + Math.floor(Math.random() * 5000) },
                    { name: 'You', wealth: this.calculateTotalWealth() }
                ];

                mockPlayers.sort((a, b) => b.wealth - a.wealth);

                let html = '';
                mockPlayers.forEach((player, i) => {
                    const medal = i === 0 ? 'ðŸ¥‡' : i === 1 ? 'ðŸ¥ˆ' : i === 2 ? 'ðŸ¥‰' : '';
                    const isYou = player.name === 'You';
                    html += `< div class="leader-row${isYou ? ' you' : ''}" >
                        <span class="leader-rank">${medal || (i + 1)}</span>
                        <span class="leader-name">${player.name}</span>
                        <span class="leader-wealth">$${player.wealth.toLocaleString()}</span>
                    </div > `;
                });
                listEl.innerHTML = html;
            }

            updateLeaderboard() {
                // Legacy method - now using updateFloatingLeaderboard
                this.updateFloatingLeaderboard();
            }

            calculateTotalWealth() {
                let total = 0;
                for (const [type, count] of Object.entries(this.playerInventory)) {
                    const mineralInfo = this.mineralTypes[type];
                    if (mineralInfo) total += mineralInfo.value * count;
                }
                return total;
            }

            updatePlayerShip() {
                const ship = this.playerShip;
                const keys = this.keysPressed;

                // Rotation (Yaw - left/right)
                if (keys['a'] || keys['arrowleft']) ship.rotation -= ship.rotationSpeed;
                if (keys['d'] || keys['arrowright']) ship.rotation += ship.rotationSpeed;

                // Joystick Yaw
                if (this.joyInputX) {
                    ship.rotation += this.joyInputX * ship.rotationSpeed;
                }

                // Mouse Steering (Right-Click Drag)
                // We use global mouse tracking for this
                if (this.mouseRightDown && this.mouseLastX !== undefined) {
                    const deltaX = this.mouseX - this.mouseLastX;
                    const deltaY = this.mouseY - this.mouseLastY;

                    // Yaw (Left/Right)
                    ship.rotation += deltaX * 0.005;

                    // Pitch (Up/Down)
                    ship.pitch += deltaY * 0.005;
                    ship.pitch = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, ship.pitch)); // Clamp pitch

                    // Update last pos to avoid continuous spin
                    this.mouseLastX = this.mouseX;
                    this.mouseLastY = this.mouseY;
                }

                // 3D Pitch rotation (R/F keys - up/down)
                if (keys['r']) ship.pitch = Math.min(Math.PI / 3, ship.pitch + 0.02); // Pitch up (max 60 degrees)
                if (keys['f']) ship.pitch = Math.max(-Math.PI / 3, ship.pitch - 0.02); // Pitch down

                // 3D Roll rotation (Z/C keys)
                if (keys['z']) ship.roll = Math.min(Math.PI / 2, ship.roll + 0.03); // Roll left (max 90 degrees)
                if (keys['x']) ship.roll = Math.max(-Math.PI / 2, ship.roll - 0.03); // Roll right

                // Acceleration (forward/backward)
                const cos = Math.cos(ship.rotation);
                const sin = Math.sin(ship.rotation);

                if (keys['w'] || keys['arrowup']) {
                    ship.vx += cos * ship.acceleration;
                    ship.vy += sin * ship.acceleration;
                }
                if (keys['s'] || keys['arrowdown']) {
                    ship.vx -= cos * ship.acceleration * 0.5;
                    ship.vy -= sin * ship.acceleration * 0.5;
                }

                // Joystick Thrust (Y axis is inverted usually: Up is negative Y)
                // But here joyInputY is positive down. So Up (-1) means Forward.
                if (this.joyInputY && Math.abs(this.joyInputY) > 0.1) {
                    // -joyInputY because forward is 'Thrust', backward is 'Brake'
                    // Actually spaceship moves in direction of rotation.
                    // So Up stick -> Thrust Forward
                    const thrust = -this.joyInputY * ship.acceleration;
                    ship.vx += cos * thrust;
                    ship.vy += sin * thrust;
                }

                // 3D movement (Q/E for up/down)
                if (keys['q']) ship.vz += ship.acceleration;  // Move up
                if (keys['e']) ship.vz -= ship.acceleration;  // Move down

                // Boost (Shift or Space for 2x speed)
                const boost = (keys['shift'] || keys[' ']) ? 2.0 : 1.0;

                // Apply velocity with boost
                ship.x += ship.vx * boost;
                ship.y += ship.vy * boost;
                ship.z += ship.vz * boost;

                // Calculate speed (3D)
                ship.speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy + ship.vz * ship.vz);

                // Cap speed
                if (ship.speed > ship.maxSpeed) {
                    const ratio = ship.maxSpeed / ship.speed;
                    ship.vx *= ratio;
                    ship.vy *= ratio;
                    ship.vz *= ratio;
                    ship.speed = ship.maxSpeed;
                }

                // Reduced friction for drifty space feel (Higher = more drift, less slow down)
                const friction = 0.998;
                ship.vx *= friction;
                ship.vy *= friction;
                ship.vz *= friction;

                // Generate speed lines for visual feedback (Roblox-style)
                if (ship.speed > 5) {
                    const lineCount = Math.floor(ship.speed / 2);
                    for (let i = 0; i < lineCount; i++) {
                        this.speedLines.push({
                            x: ship.x + (Math.random() - 0.5) * 300,
                            y: ship.y + (Math.random() - 0.5) * 300,
                            z: ship.z + (Math.random() - 0.5) * 300,
                            vx: -ship.vx * 0.5,
                            vy: -ship.vy * 0.5,
                            life: 1.0
                        });
                    }
                }

                // Update and clean up speed lines
                this.speedLines.forEach(line => {
                    line.x += line.vx;
                    line.y += line.vy;
                    line.life -= 0.05;
                });
                this.speedLines = this.speedLines.filter(line => line.life > 0);

                // Camera follows ship directly (keeps ship perfectly centered)
                // Use zoom level to maintain center regardless of zoom
                this.camera.x = -ship.x * this.camera.zoom;
                this.camera.y = -ship.y * this.camera.zoom;

                // Check and generate new sectors as player explores
                this.checkAndGenerateSectors();
            }

            // Inventory Management
            loadInventory() {
                try {
                    const saved = localStorage.getItem('playerInventory');
                    return saved ? JSON.parse(saved) : {};
                } catch (e) {
                    console.error('Failed to load inventory:', e);
                    return {};
                }
            }

            saveInventory() {
                try {
                    localStorage.setItem('playerInventory', JSON.stringify(this.playerInventory));
                } catch (e) {
                    console.error('Failed to save inventory:', e);
                }
            }

            loadCredits() {
                return parseInt(localStorage.getItem('playerCredits')) || 0;
            }

            saveCredits() {
                localStorage.setItem('playerCredits', this.credits);
            }

            loadUpgrades() {
                try {
                    return JSON.parse(localStorage.getItem('playerUpgrades')) || { speed: 0, armor: 0, weapons: 0, shield: 0, cargo: 0, radar: 0 };
                } catch (e) {
                    return { speed: 0, armor: 0, weapons: 0, shield: 0, cargo: 0, radar: 0 };
                }
            }

            saveUpgrades() {
                localStorage.setItem('playerUpgrades', JSON.stringify(this.playerShip.upgrades));
            }

            sellAllGems() {
                console.log('[Sell All] Button clicked!');
                let totalValue = 0;
                let count = 0;
                for (const [type, qty] of Object.entries(this.playerInventory)) {
                    if (qty > 0) {
                        const val = this.mineralTypes[type].value;
                        totalValue += val * qty;
                        count += qty;
                        this.playerInventory[type] = 0;
                    }
                }

                if (totalValue > 0) {
                    this.credits += totalValue;
                    this.saveCredits();
                    this.saveInventory();
                    this.showToast(`Sold ${count} gems for $${totalValue.toLocaleString()}`);
                    console.log('[Sell All] Success:', count, 'gems for $', totalValue);

                    // Update UI immediately
                    this.updateWalletUI();
                    this.updateInventoryUI();
                } else {
                    this.showToast('No gems to sell');
                    console.log('[Sell All] No gems in inventory');
                }
            }

            updateWalletUI() {
                const creditsEl = document.getElementById('walletValue');
                if (creditsEl) {
                    creditsEl.textContent = this.credits.toLocaleString();
                }
                const creditsDisplay = document.getElementById('creditsDisplay'); // Legacy support
                if (creditsDisplay) {
                    creditsDisplay.textContent = '$' + this.credits.toLocaleString();
                }
            }

            updateInventoryUI() {
                const gemsGrid = document.getElementById('gemsGrid');
                const gemsTotalEl = document.getElementById('gemsTotal');

                if (!gemsGrid) return;

                let totalValue = 0;
                let html = '';

                const inventory = Object.entries(this.playerInventory || {});

                if (inventory.length === 0) {
                    html = '<div style="color:#5c7a8a;font-size:9px;padding:4px;">No gems yet</div>';
                } else {
                    inventory.forEach(([type, count]) => {
                        if (count <= 0) return;
                        const info = this.mineralTypes[type];
                        if (!info) return;

                        totalValue += count * info.value;

                        const itemValue = count * info.value;
                        const valueDisplay = this.showGemValues ? `<span style="color:${info.color}; font-weight:bold; margin-left:6px;">$${Math.round(itemValue).toLocaleString()}</span>` : '';

                        html += `
                            <div class="gem-item" style="border:1px solid ${info.color}44; background: rgba(0,0,0,0.6);">
                                <div style="${this.styleGem(type)}"></div>
                                <span style="color:${info.color}">${info.name}</span>
                                <span class="gem-count">Ã—${count}</span>
                                ${valueDisplay}
                            </div>
                        `;
                    });
                }

                gemsGrid.innerHTML = html;

                if (gemsTotalEl) {
                    gemsTotalEl.textContent = `$${totalValue.toLocaleString()}`;
                }
            }

            upgradeShip(type) {
                const upgradeCosts = [1000, 2500, 5000, 10000, 25000]; // Function of level maybe?
                const currentLevel = this.playerShip.upgrades[type] || 0;

                if (currentLevel >= 5) {
                    this.showToast('Max level reached!');
                    return;
                }

                const cost = upgradeCosts[currentLevel];
                if (this.credits >= cost) {
                    this.credits -= cost;
                    this.playerShip.upgrades[type]++;
                    this.saveCredits();
                    this.saveUpgrades();

                    // Apply effects immediately
                    const lvl = this.playerShip.upgrades[type];
                    if (type === 'speed') {
                        this.playerShip.maxSpeed = 50 * (1 + lvl * 0.2);
                        this.playerShip.acceleration = 0.5 * (1 + lvl * 0.1);
                    } else if (type === 'armor') {
                        this.playerShip.maxHull = 100 * (1 + lvl * 0.2);
                        this.playerShip.hullHealth = this.playerShip.maxHull; // Repair on upgrade
                    } else if (type === 'shield') {
                        this.playerShip.maxShield = 50 * (1 + lvl * 0.2);
                        this.playerShip.shield = this.playerShip.maxShield;
                    } else if (type === 'radar') {
                        this.playerShip.radarRange = 2000 * (1 + lvl * 0.3);
                    }

                    this.showToast(`${type.toUpperCase()} Upgraded to Level ${lvl + 1} !`);
                    this.updateUpgradeUI(); // Assuming we'll create this method
                } else {
                    this.showToast(`Not enough credits! Need $${cost.toLocaleString()} `);
                }
            }

            // Spawn minerals around the player - ADDICTIVE GAMEPLAY DESIGN
            spawnMinerals() {
                const ship = this.playerShip;
                const spawnRadius = 1500; // Medium range - always gems visible
                let targetDensity = 200; // Base: Always 200 gems nearby

                // Check hotspot proximity for MASSIVE density boost
                let hotspotBonus = 1.0;
                let activeHotspot = null;
                let inHotspot = false;

                for (const dep of this.resourceDeposits) {
                    const dx = ship.x - dep.x;
                    const dy = ship.y - dep.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < dep.radius) {
                        hotspotBonus = 3.0; // 3x rarity multiplier
                        targetDensity = 500; // Massive gem field
                        activeHotspot = dep;
                        inHotspot = true;
                        break;
                    }
                }

                // Calculate player's zone
                const playerDistFromOrigin = Math.sqrt(ship.x * ship.x + ship.y * ship.y);

                // Remove only VERY far minerals for performance
                this.minerals = this.minerals.filter(m => {
                    const dx = m.x - ship.x;
                    const dy = m.y - ship.y;
                    const dz = m.z - ship.z;
                    return Math.sqrt(dx * dx + dy * dy + dz * dz) < spawnRadius * 3;
                });

                // INSTANT RESPAWN: Always maintain target density
                while (this.minerals.length < targetDensity) {
                    const currentZone = this.getZoneAtDistance(playerDistFromOrigin);
                    const mineralKey = this.selectElementForZone(currentZone, playerDistFromOrigin, hotspotBonus);
                    const type = this.mineralTypes[mineralKey];
                    if (!type) continue;

                    // Dense, even distribution around player
                    const angle = Math.random() * Math.PI * 2;
                    const distance = spawnRadius * Math.sqrt(Math.random()); // Uniform distribution
                    const zOffset = (Math.random() - 0.5) * 400;

                    // Hotspot clustering: bias toward hotspot center
                    let spawnX, spawnY;
                    if (inHotspot && Math.random() < 0.6) {
                        // 60% of gems cluster around hotspot center
                        const hotAngle = Math.random() * Math.PI * 2;
                        const hotDist = activeHotspot.radius * Math.sqrt(Math.random()) * 0.7;
                        spawnX = activeHotspot.x + Math.cos(hotAngle) * hotDist;
                        spawnY = activeHotspot.y + Math.sin(hotAngle) * hotDist;
                    } else {
                        // Normal spawn around player
                        spawnX = ship.x + Math.cos(angle) * distance;
                        spawnY = ship.y + Math.sin(angle) * distance;
                    }

                    const spawnZ = ship.z + zOffset;

                    this.minerals.push({
                        id: Date.now() + Math.random(),
                        type: mineralKey,
                        ...type,
                        x: spawnX,
                        y: spawnY,
                        z: spawnZ,
                        phase: Math.random() * Math.PI * 2,
                        defended: type.rarity === 'epic' || type.rarity === 'legendary' || type.rarity === 'mythic'
                    });
                }
            }

            // Get the zone type at a given distance from origin
            getZoneAtDistance(distance) {
                for (const [zoneKey, zone] of Object.entries(this.galaxyZones)) {
                    if (distance >= zone.distanceRange.min && distance < zone.distanceRange.max) {
                        return zoneKey;
                    }
                }
                // Beyond all zones = exotic
                if (distance >= 5000) return 'exotic';
                // Default to industrial for very close
                return 'industrial';
            }

            // Select an element to spawn based on current zone and probability
            // ADDICTIVE DESIGN: Clear risk/reward progression
            selectElementForZone(currentZone, distance, bonusMultiplier = 1) {
                const zones = this.galaxyZones;
                const allElements = Object.keys(this.mineralTypes);

                // Build probability weights with ZONE-BASED PROGRESSION
                const weights = [];
                let totalWeight = 0;

                for (const elementKey of allElements) {
                    const element = this.mineralTypes[elementKey];
                    let weight = 1;

                    // ADDICTIVE RARITY DISTRIBUTION BY ZONE
                    // Inner Core (0-1500): Safe, abundant commons
                    if (distance < 1500) {
                        switch (element.rarity) {
                            case 'common': weight = 70; break;      // 70%
                            case 'uncommon': weight = 25; break;    // 25%
                            case 'rare': weight = 5; break;         // 5%
                            default: weight = 0; break;             // No epic+
                        }
                    }
                    // Radiation Belt (1500-3000): Medium risk, good rewards
                    else if (distance < 3000) {
                        switch (element.rarity) {
                            case 'common': weight = 40; break;      // 40%
                            case 'uncommon': weight = 40; break;    // 40%
                            case 'rare': weight = 15; break;        // 15%
                            case 'epic': weight = 5; break;         // 5%
                            default: weight = 0; break;
                        }
                    }
                    // Outer Expanse (3000-5000): High risk, great rewards
                    else if (distance < 5000) {
                        switch (element.rarity) {
                            case 'common': weight = 0; break;       // No commons
                            case 'uncommon': weight = 25; break;    // 25%
                            case 'rare': weight = 35; break;        // 35%
                            case 'epic': weight = 30; break;        // 30%
                            case 'legendary': weight = 10; break;   // 10%
                            default: weight = 0; break;
                        }
                    }
                    // Deep Void (5000+): Extreme risk, legendary rewards
                    else {
                        switch (element.rarity) {
                            case 'common': weight = 0; break;
                            case 'uncommon': weight = 0; break;
                            case 'rare': weight = 20; break;        // 20%
                            case 'epic': weight = 40; break;        // 40%
                            case 'legendary': weight = 30; break;   // 30%
                            case 'mythic': weight = 10; break;      // 10%
                        }
                    }

                    // Hotspot bonus multiplier
                    if (bonusMultiplier > 1) {
                        // Increase rarity in hotspots
                        if (element.rarity !== 'common') {
                            weight *= bonusMultiplier;
                        }
                    }

                    // Zone affinity: elements spawn more in their home zone
                    if (zones[element.zone] && zones[element.zone].elements.includes(elementKey)) {
                        if (element.zone === currentZone) {
                            weight *= 1.5; // 50% bonus in home zone
                        }
                    }

                    weights.push({ key: elementKey, weight });
                    totalWeight += weight;
                }

                // Weighted random selection
                let random = Math.random() * totalWeight;
                for (const { key, weight } of weights) {
                    random -= weight;
                    if (random <= 0) {
                        return key;
                    }
                }

                // Fallback to iron
                return 'iron';
            }

            // Check for mineral collection
            collectMineral(mineral) {
                const ship = this.playerShip;
                const dx = mineral.x - ship.x;
                const dy = mineral.y - ship.y;
                const dz = mineral.z - ship.z;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                const collectionRadius = ship.size + mineral.size;

                if (distance < collectionRadius) {
                    // Add to inventory
                    if (!this.playerInventory[mineral.type]) {
                        this.playerInventory[mineral.type] = 0;
                    }
                    this.playerInventory[mineral.type]++;
                    this.saveInventory();

                    // Show notification
                    this.collectionNotifications.push({
                        text: `+ ${mineral.name} ($${mineral.value})`,
                        color: mineral.color,
                        time: Date.now()
                    });

                    // Remove mineral
                    const index = this.minerals.indexOf(mineral);
                    if (index > -1) this.minerals.splice(index, 1);
                }
            }

            // Update minerals (check collection, spawn new ones)
            updateMinerals() {
                if (!this.flightMode) return;

                // Check for collections
                for (const mineral of [...this.minerals]) {
                    this.collectMineral(mineral);
                }

                // Spawn new minerals
                this.spawnMinerals();

                // Update notifications (fade out after 2 seconds)
                const now = Date.now();
                this.collectionNotifications = this.collectionNotifications.filter(n => now - n.time < 2000);
            }

            toggleMatrixRainbow() {
                this.matrixRainbowMode = !this.matrixRainbowMode;
                const btn = document.getElementById('matrixRainbowBtn');
                if (btn) btn.classList.toggle('active', this.matrixRainbowMode);
            }

            // Update star colors from the 3 color pickers
            updateStarColors() {
                try {
                    const c1 = document.getElementById('starColor1')?.value || '#ffffff';
                    const c2 = document.getElementById('starColor2')?.value || '#aaddff';
                    const c3 = document.getElementById('starColor3')?.value || '#ffddaa';
                    this.starColors = [c1, c2, c3];
                    this.generateStaticStars();
                    this.showToast('Star colors updated');
                } catch (e) {
                    console.error('[BG Error] updateStarColors failed:', e);
                }
            }

            // Toggle slow star drift mode
            toggleBgDrift() {
                try {
                    // Mutex: Turn off warp first if it's on
                    if (this.bgWarpMode) {
                        this.bgWarpMode = false;
                        const warpBtn = document.getElementById('bgWarpBtn');
                        if (warpBtn) warpBtn.classList.remove('active');
                    }

                    this.bgDriftMode = !this.bgDriftMode;
                    const btn = document.getElementById('bgDriftBtn');
                    if (btn) btn.classList.toggle('active', this.bgDriftMode);

                    // Regenerate stars with proper velocities
                    this.generateStaticStars();
                    this.showToast(this.bgDriftMode ? 'Star Drift ON' : 'Star Drift OFF');
                } catch (e) {
                    console.error('[BG Error] toggleBgDrift failed:', e);
                    this.bgDriftMode = false;
                    this.showToast('Drift mode error - please try again');
                }
            }

            toggleUpgradePanel() {
                const panel = document.getElementById('upgradePanel');
                if (panel) {
                    panel.classList.toggle('hidden');
                    if (!panel.classList.contains('hidden')) {
                        this.updateUpgradeUI();
                    }
                }
            }

            updateUpgradeUI() {
                const list = document.getElementById('upgradeList');
                const credits = document.getElementById('dockCredits');
                if (!list || !credits) return;

                credits.textContent = '$' + this.credits.toLocaleString();

                const upgrades = [
                    { id: 'speed', name: 'Engine Overclock', desc: 'Increases max speed & acceleration' },
                    { id: 'armor', name: 'Nanocarbon Hull', desc: 'Increases hull integrity' },
                    { id: 'weapons', name: 'Photon Cannons', desc: 'Increases damage output (Coming Soon)' },
                    { id: 'shield', name: 'Energy Shield', desc: 'Increases shield capacity' },
                    { id: 'cargo', name: 'Quantum Hold', desc: 'Increases gem capacity (Coming Soon)' },
                    { id: 'radar', name: 'Deep Scan Radar', desc: 'Increases detection range' }
                ];

                const costs = [1000, 2500, 5000, 10000, 25000];

                let html = '';
                upgrades.forEach(u => {
                    const level = this.playerShip.upgrades[u.id] || 0;
                    const cost = costs[level];
                    const isMax = level >= 5;
                    const canAfford = this.credits >= cost;

                    let bars = '';
                    for (let i = 0; i < 5; i++) {
                        bars += `< div style = "flex:1; height:4px; background:${i < level ? '#00f3ff' : 'rgba(255,255,255,0.1)'}; margin:0 1px;" ></div > `;
                    }

                    html += `
                    < div style = "background:rgba(255,255,255,0.05); border:1px solid ${canAfford ? 'rgba(0,243,255,0.3)' : 'rgba(255,50,50,0.3)'}; padding:8px; border-radius:6px;" >
                            <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
                                <span style="font-weight:bold; color:#e0faff; font-size:11px;">${u.name}</span>
                                <span style="font-size:10px; color:${isMax ? '#00f3ff' : '#ffd700'}">${isMax ? 'MAX' : '$' + cost.toLocaleString()}</span>
                            </div>
                            <div style="font-size:9px; color:#8ba; margin-bottom:6px;">${u.desc}</div>
                            <div style="display:flex; margin-bottom:6px;">${bars}</div>
                            ${!isMax ? `<button class="btn-small" onclick="app.upgradeShip('${u.id}')" style="width:100%; font-size:10px; padding:4px; ${canAfford ? 'cursor:pointer' : 'opacity:0.5; cursor:not-allowed;'}">UPGRADE</button>` : ''}
                        </div >
                    `;
                });

                list.innerHTML = html;
            }

            // Toggle warp speed mode
            toggleBgWarp() {
                try {
                    // Mutex: Turn off drift first if it's on
                    if (this.bgDriftMode) {
                        this.bgDriftMode = false;
                        const driftBtn = document.getElementById('bgDriftBtn');
                        if (driftBtn) driftBtn.classList.remove('active');
                    }

                    const btn = document.getElementById('bgWarpBtn');

                    // If currently disengaging, ignore button presses
                    if (this.warpDisengaging) {
                        this.showToast('Warp still decelerating...');
                        return;
                    }

                    // DISENGAGE path: When warp is ON, start the disengage animation
                    if (this.bgWarpMode) {
                        this.warpDisengaging = true;
                        this.disengageStartTime = performance.now(); // Track when disengage started
                        this.disengageDuration = 4500; // 4.5 seconds total animation
                        if (btn) btn.classList.remove('active');
                        this.showToast('Warp Disengaged - Decelerating...');

                        // Cancel any existing engage animation
                        if (this.warpSliderAnimation) {
                            cancelAnimationFrame(this.warpSliderAnimation);
                            this.warpSliderAnimation = null;
                        }

                        const slider = document.getElementById('warpSpeedSlider');
                        if (slider) {
                            const startValue = parseFloat(slider.value) || 100;
                            const startTime = performance.now();

                            // MIRRORED timing from acceleration: 
                            // Accel was: 3s slow (1â†’50), then 1.5s fast (50â†’100)
                            // Decel is: 1.5s fast (100â†’50), then 3s slow (50â†’1)
                            const fastSlowdownDuration = 1500;  // Fast initial decel
                            const gradualSlowdownDuration = 3000; // Slow final approach
                            const totalDuration = fastSlowdownDuration + gradualSlowdownDuration;

                            // Animate slider backward (inverse of acceleration)
                            const animateSliderBackward = (currentTime) => {
                                if (!this.warpDisengaging) return;

                                const elapsed = currentTime - startTime;
                                let value;

                                if (elapsed < fastSlowdownDuration) {
                                    // Fast phase: 100 to 50 in 1.5s
                                    const progress = elapsed / fastSlowdownDuration;
                                    const eased = 1 - Math.pow(1 - progress, 2); // ease-out
                                    value = startValue - (startValue * 0.5 * eased);
                                } else if (elapsed < totalDuration) {
                                    // Slow phase: 50 to 0 in 3s (mirrors the 3s 0â†’50)
                                    const gradualElapsed = elapsed - fastSlowdownDuration;
                                    const progress = gradualElapsed / gradualSlowdownDuration;
                                    const eased = 1 - Math.pow(1 - progress, 3); // ease-out cubic
                                    value = (startValue * 0.5) - ((startValue * 0.5) * eased);
                                } else {
                                    // Complete - turn off warp mode
                                    value = 0;
                                    this.warpDisengaging = false;
                                    this.bgWarpMode = false;

                                    // Finalize objects at their current positions and clean up
                                    const finalizePositions = (arr) => {
                                        if (arr) arr.forEach(obj => {
                                            // Snap objects to their final positions - REMOVED to prevent jump
                                            // if (obj.finalX !== undefined) {
                                            //    obj.x = obj.finalX;
                                            //    obj.y = obj.finalY;
                                            // }
                                            // Clear all warp-related data
                                            obj.flownOut = false;
                                            obj.wasFlownOut = false;
                                            obj.disengageInit = false;
                                            obj.returning = false;
                                            obj.arrivalAngle = undefined;
                                            obj.warpScale = undefined;
                                            obj.warpAlpha = undefined;
                                            obj.startWarpSpeed = undefined;
                                            obj.startScreenX = undefined;
                                            obj.startScreenY = undefined;
                                            obj.finalX = undefined;
                                            obj.finalY = undefined;
                                            obj.disengageFinalX = undefined;
                                            obj.disengageFinalY = undefined;
                                            obj.targetX = undefined;
                                            obj.targetY = undefined;
                                            obj.origX = undefined;
                                            obj.origY = undefined;
                                            obj.typeIndex = undefined;
                                        });
                                    };
                                    finalizePositions(this.planets);
                                    finalizePositions(this.galaxies);
                                    finalizePositions(this.blackHoles);
                                    finalizePositions(this.nebulae);
                                    finalizePositions(this.spacecraft);
                                    finalizePositions(this.stars);

                                    slider.value = 0;
                                    this.setWarpSpeedMultiplier(0);

                                    this.showToast('Arrived at new destination');
                                    return;
                                }

                                slider.value = Math.max(0, value);
                                this.setWarpSpeedMultiplier(Math.max(0, value), false);

                                this.warpSliderAnimation = requestAnimationFrame(animateSliderBackward);
                            };

                            this.warpSliderAnimation = requestAnimationFrame(animateSliderBackward);
                        }
                        return; // Exit after starting disengage
                    }

                    // ENGAGE path: Turn on warp mode
                    this.bgWarpMode = true;
                    this.warpDisengaging = false;
                    if (btn) btn.classList.add('active');

                    // Reset warp speed for smooth ramp-up
                    this.warpSpeed = 0;

                    this.showToast('WARP ENGAGED!');

                    // Store original positions for all objects
                    const storeOriginalPosition = (obj) => {
                        if (!obj) return;
                        obj.origX = obj.x;
                        obj.origY = obj.y;
                        obj.flownOut = false;
                        obj.returning = false;
                    };
                    if (this.planets) this.planets.forEach(storeOriginalPosition);
                    if (this.galaxies) this.galaxies.forEach(storeOriginalPosition);
                    if (this.blackHoles) this.blackHoles.forEach(storeOriginalPosition);
                    if (this.nebulae) this.nebulae.forEach(storeOriginalPosition);
                    if (this.spacecraft) this.spacecraft.forEach(storeOriginalPosition);
                    if (this.stars) this.stars.forEach(storeOriginalPosition);

                    // Auto-animate slider from min to max
                    const slider = document.getElementById('warpSpeedSlider');
                    if (slider) {
                        if (this.warpSliderAnimation) {
                            cancelAnimationFrame(this.warpSliderAnimation);
                        }

                        this.warpManualControl = false;

                        const stopAutoAnimation = () => {
                            this.warpManualControl = true;
                            if (this.warpSliderAnimation) {
                                cancelAnimationFrame(this.warpSliderAnimation);
                                this.warpSliderAnimation = null;
                            }
                        };

                        slider.removeEventListener('mousedown', stopAutoAnimation);
                        slider.removeEventListener('touchstart', stopAutoAnimation);
                        slider.removeEventListener('pointerdown', stopAutoAnimation);
                        slider.addEventListener('mousedown', stopAutoAnimation);
                        slider.addEventListener('touchstart', stopAutoAnimation);
                        slider.addEventListener('pointerdown', stopAutoAnimation);

                        slider.value = 1;
                        this.setWarpSpeedMultiplier(1);

                        const startTime = performance.now();
                        const firstHalfDuration = 3000;
                        const secondHalfDuration = 1500;
                        const totalDuration = firstHalfDuration + secondHalfDuration;

                        const animateSlider = (currentTime) => {
                            if (!this.bgWarpMode || this.warpManualControl || this.warpDisengaging) return;

                            const elapsed = currentTime - startTime;
                            let value;

                            if (elapsed < firstHalfDuration) {
                                const firstProgress = elapsed / firstHalfDuration;
                                value = 1 + firstProgress * 49.5;
                            } else if (elapsed < totalDuration) {
                                const secondElapsed = elapsed - firstHalfDuration;
                                const secondProgress = Math.min(1, secondElapsed / secondHalfDuration);
                                value = 50.5 + secondProgress * 49.5;
                            } else {
                                const maintainTime = (elapsed - totalDuration) / 1000;
                                const wave1 = Math.sin(maintainTime * 0.8) * 5;
                                const wave2 = Math.sin(maintainTime * 2.3) * 3;
                                const wave3 = Math.sin(maintainTime * 5.7) * 2;
                                const surge = Math.sin(maintainTime * 0.3) * Math.sin(maintainTime * 1.1) * 4;
                                const turbulence = wave1 + wave2 + wave3 + surge;
                                value = 92 + turbulence;
                                value = Math.max(85, Math.min(100, value));
                            }

                            slider.value = value;
                            this.setWarpSpeedMultiplier(value);
                            this.warpSliderAnimation = requestAnimationFrame(animateSlider);
                        };
                        this.warpSliderAnimation = requestAnimationFrame(animateSlider);
                    }
                } catch (e) {
                    console.error('[BG Error] toggleBgWarp failed:', e);
                    this.bgWarpMode = false;
                    this.warpDisengaging = false;
                    this.showToast('Warp mode error - please try again');
                }
            }

            // Set warp speed multiplier from slider
            // EXPONENTIAL acceleration: slow start, ramps up to lightspeed at midpoint
            setWarpSpeedMultiplier(value, updateState = true) {
                const rawValue = parseFloat(value) || 0;

                if (updateState) {
                    // Handling for "Slow Move" / Traverse vs Warp
                    if (rawValue > 0.5) {
                        // Moving: Enable warp mode (traverse)
                        if (!this.bgWarpMode) this.bgWarpMode = true;
                        this.warpDisengaging = false;

                        const btn = document.getElementById('bgWarpBtn');
                        if (btn) btn.classList.add('active');
                    } else {
                        // Stopped/Arrived (Slider ~0)
                        if (rawValue === 0) {
                            // FULL STOP: Ensure everything is off
                            this.bgWarpMode = false;
                            this.warpDisengaging = false;
                            this.warpSpeed = 0; // Force speed to 0 immediately
                            const btn = document.getElementById('bgWarpBtn');
                            if (btn) btn.classList.remove('active');
                            this.showToast('Engines Stopped');
                        } else if (this.bgWarpMode && !this.warpDisengaging) {
                            // Slowing down but not 0: Trigger disengage visual (stars fading)
                            this.warpDisengaging = true;
                        }
                    }
                }

                // Normalize to 0-1 range (slider is 0-100)
                const normalized = rawValue / 100;

                // Curve: Speed 0 = 0. Speed 1 = Slow. Speed 100 = Fast.
                // Using power curve to give fine control at low speeds
                const curved = Math.pow(normalized, 3);

                // Scale to final range: 0 to ~840
                this.warpSpeedMultiplier = curved * 840;

                // Store raw slider for UI consistency
                this.warpSliderRaw = rawValue;
            }

            updateColorModeUI() {
                const fixedIndicator = document.getElementById('fixedModeIndicator');
                const rainbowBtn = document.getElementById('rainbowBtn');
                const colorText = document.getElementById('currentColorModeText');
                const colorInput = document.getElementById('colorInput');

                // Guard clauses to prevent crashes if elements don't exist
                if (colorInput) colorInput.value = this.activeColor;

                if (this.colorMode === 'fixed') {
                    if (fixedIndicator) {
                        fixedIndicator.classList.add('active');
                        fixedIndicator.style.background = this.activeColor;
                    }
                    if (rainbowBtn) rainbowBtn.classList.remove('active');
                    if (colorText) colorText.innerText = `Color Mode: Fixed(${this.activeColor})`;
                } else {
                    if (fixedIndicator) fixedIndicator.classList.remove('active');
                    if (rainbowBtn) rainbowBtn.classList.add('active');
                    if (colorText) colorText.innerText = "Color Mode: Rainbow (Random per star)";
                }
            }

            /* --- Input Handling --- */

            getWorldPos(e) {
                return {
                    x: (e.clientX - this.canvas.width / 2 - this.camera.x) / this.camera.zoom,
                    y: (e.clientY - this.canvas.height / 2 - this.camera.y) / this.camera.zoom
                };
            }

            onPointerDown(e) {
                // Track which button was pressed (0=left, 1=middle, 2=right)
                this.pointer.button = e.button;

                // Only track canvas interactions
                this.pointer.onCanvas = (e.target === this.canvas);
                this.pointer.isDown = true;
                this.pointer.startX = e.clientX;
                this.pointer.startY = e.clientY;
                this.pointer.camStartX = this.camera.x;
                this.pointer.camStartY = this.camera.y;
                this.pointer.rotStartX = this.rotationX;
                this.pointer.rotStartY = this.rotationY;

                // Middle mouse button OR Alt+Left = Orbit mode (Blender style)
                // Shift+Left = Pan mode
                this.pointer.orbitMode = (e.button === 1) || (e.button === 0 && e.altKey);
                this.pointer.panMode = (e.button === 0 && e.shiftKey);

                // If orbiting or panning, skip star interactions
                if (this.pointer.orbitMode || this.pointer.panMode) {
                    return;
                }

                const world = this.getWorldPos(e);
                const hitDist = (this.config.starBaseRad * 4) / this.camera.zoom;
                const starHit = this.stars.find(s => Math.hypot(s.x - world.x, s.y - world.y) < hitDist);

                // Refresh cluster assignments if we hit a star, in case we drag a group
                if (starHit) {
                    this.refreshClusterAssignments();

                    // In select mode, clicking a star initiates a cluster drag
                    if (this.mode === 'select' && starHit.clusterId) {
                        // Determine the cluster ID to drag (it's either the cluster name string or the star's ID string)
                        this.draggedClusterId = String(starHit.clusterId);
                        this.pointer.lastWorldX = world.x;
                        this.pointer.lastWorldY = world.y;
                        this.saveState();
                        return;
                    }

                    // If not in select mode, allow single star drag
                    if (this.mode === 'draw') {
                        this.draggedStar = starHit;
                        this.saveState();
                    }
                }
            }

            onPointerMove(e) {
                const world = this.getWorldPos(e);

                // Hover Logic
                const hitDist = (this.config.starBaseRad * 4) / this.camera.zoom;
                this.hoveredStar = this.stars.find(s => Math.hypot(s.x - world.x, s.y - world.y) < hitDist);

                // Cursor Feedback based on mode
                let newCursor = 'default';
                if (this.pointer.orbitMode && this.pointer.isDown) {
                    newCursor = 'grab';
                } else if (this.pointer.panMode && this.pointer.isDown) {
                    newCursor = 'move';
                } else if (this.draggedStar || this.draggedClusterId || this.pointer.dragging) {
                    newCursor = 'grabbing';
                } else if (this.hoveredStar) {
                    newCursor = 'move';
                } else if (this.mode === 'draw') {
                    newCursor = 'crosshair';
                }
                this.canvas.style.cursor = newCursor;


                if (!this.pointer.isDown) return;

                const dx = e.clientX - this.pointer.startX;
                const dy = e.clientY - this.pointer.startY;
                const distMoved = Math.hypot(dx, dy);

                if (distMoved > 5) {
                    this.pointer.dragging = true;
                }

                // PRIORITY 1: Orbit mode (Middle mouse or Alt+Left) - ALWAYS rotates in 3D
                if (this.pointer.orbitMode) {
                    this.rotationY = this.pointer.rotStartY + dx * 0.5;
                    this.rotationX = this.pointer.rotStartX + dy * 0.5;
                    this.draw();
                    // Update UI sliders
                    const rotXSliderEl = document.getElementById('rotXSlider');
                    const rotYSliderEl = document.getElementById('rotYSlider');
                    if (rotXSliderEl) {
                        rotXSliderEl.value = this.rotationX % 360;
                        document.getElementById('rotXValue').textContent = Math.round(this.rotationX % 360) + 'Â°';
                    }
                    if (rotYSliderEl) {
                        rotYSliderEl.value = this.rotationY % 360;
                        document.getElementById('rotYValue').textContent = Math.round(this.rotationY % 360) + 'Â°';
                    }
                    return;
                }

                // PRIORITY 2: Pan mode (Shift + Left drag) - ALWAYS pans
                if (this.pointer.panMode) {
                    this.camera.x = this.pointer.camStartX + dx;
                    this.camera.y = this.pointer.camStartY + dy;
                    return;
                }

                // PRIORITY 3: Cluster dragging (in select mode)
                if (this.draggedClusterId) {
                    // Calculate world delta since last move
                    const deltaWorldX = world.x - this.pointer.lastWorldX;
                    const deltaWorldY = world.y - this.pointer.lastWorldY;

                    const draggedIdString = this.draggedClusterId;
                    // Move all stars in the cluster
                    this.stars.forEach(s => {
                        // Use strict comparison on the clusterId string
                        if (String(s.clusterId) === draggedIdString) {
                            s.x += deltaWorldX;
                            s.y += deltaWorldY;
                        }
                    });

                    // Update last position
                    this.pointer.lastWorldX = world.x;
                    this.pointer.lastWorldY = world.y;
                    return;
                }

                // PRIORITY 4: Single star dragging
                if (this.draggedStar) {
                    this.draggedStar.x = world.x;
                    this.draggedStar.y = world.y;
                    return;
                }

                // PRIORITY 5: Empty space drag = rotate by default (Blender-style)
                if (this.pointer.dragging) {
                    this.rotationY = this.pointer.rotStartY + dx * 0.5;
                    this.rotationX = this.pointer.rotStartX + dy * 0.5;
                    this.draw();
                    // Update UI sliders if they exist
                    const rotXSliderEl = document.getElementById('rotXSlider');
                    const rotYSliderEl = document.getElementById('rotYSlider');
                    if (rotXSliderEl) {
                        rotXSliderEl.value = this.rotationX % 360;
                        document.getElementById('rotXValue').textContent = Math.round(this.rotationX % 360) + 'Â°';
                    }
                    if (rotYSliderEl) {
                        rotYSliderEl.value = this.rotationY % 360;
                        document.getElementById('rotYValue').textContent = Math.round(this.rotationY % 360) + 'Â°';
                    }
                }
            }

            onPointerUp(e) {
                // Skip star creation if we were orbiting or panning
                const wasNavigating = this.pointer.orbitMode || this.pointer.panMode;

                // Only process star creation if pointer started on canvas and not navigating
                if (this.pointer.onCanvas && !wasNavigating) {
                    const world = this.getWorldPos(e);
                    const hitDist = (this.config.starBaseRad * 4) / this.camera.zoom;
                    const clickedStar = this.stars.find(s => Math.hypot(s.x - world.x, s.y - world.y) < hitDist);

                    if (!this.pointer.dragging && !clickedStar) {
                        // Empty Space Clicked - Create Star (ONLY in draw mode)
                        if (this.mode === 'draw') {
                            this.saveState(); // Save BEFORE action

                            // Get current rotation center BEFORE adding star
                            // This ensures consistency with how rotate3D renders existing stars
                            const center = this.getConstellationCenter();

                            // Cache the center for rendering stability after star is added
                            // This prevents the visual "jump" when constellation center shifts
                            this._cachedRotationCenter = { x: center.x, y: center.y, z: center.z };

                            // Inverse rotate using the same center that rendering uses
                            const pos3D = this.inverseRotate3D(world.x, world.y, center.x, center.y);

                            this.createStar(pos3D.x, pos3D.y, pos3D.z);

                            // Clear cached center after a brief delay to allow smooth transition
                            setTimeout(() => { this._cachedRotationCenter = null; }, 100);
                        }
                    }
                }

                // Reset interaction state
                this.pointer.isDown = false;
                this.pointer.dragging = false;
                this.pointer.onCanvas = false;
                this.pointer.orbitMode = false;
                this.pointer.panMode = false;
                this.pointer.button = 0;
                this.draggedStar = null;
                this.draggedClusterId = null;
            }

            onRightClick(e) {
                e.preventDefault(); // Prevent context menu
                const world = this.getWorldPos(e);
                const hitDist = (this.config.starBaseRad * 4) / this.camera.zoom;

                // Check if clicking on a star
                const clickedStarIndex = this.stars.findIndex(s => Math.hypot(s.x - world.x, s.y - world.y) < hitDist);

                if (clickedStarIndex !== -1) {
                    // Delete the star
                    this.saveState(); // Save for undo
                    this.stars.splice(clickedStarIndex, 1);
                    this.showToast(`Deleted star`);
                    this.draw();
                    return;
                }

                // Check if clicking on a connection line
                const lineHitDist = 5 / this.camera.zoom; // 5 pixel tolerance
                for (let i = 0; i < this.stars.length; i++) {
                    const s1 = this.stars[i];
                    for (let j = i + 1; j < this.stars.length; j++) {
                        const s2 = this.stars[j];

                        // Only check connected stars
                        if (Math.hypot(s1.x - s2.x, s1.y - s2.y) > this.config.maxConnectDist) continue;

                        // Point-to-line distance formula
                        const lineLen = Math.hypot(s2.x - s1.x, s2.y - s1.y);
                        if (lineLen === 0) continue;

                        const t = Math.max(0, Math.min(1, ((world.x - s1.x) * (s2.x - s1.x) + (world.y - s1.y) * (s2.y - s1.y)) / (lineLen * lineLen)));
                        const projX = s1.x + t * (s2.x - s1.x);
                        const projY = s1.y + t * (s2.y - s1.y);
                        const dist = Math.hypot(world.x - projX, world.y - projY);

                        if (dist < lineHitDist) {
                            // Delete both stars that make up this connection
                            this.saveState(); // Save for undo
                            const indices = [i, j].sort((a, b) => b - a); // Remove in reverse order
                            this.stars.splice(indices[0], 1);
                            this.stars.splice(indices[1], 1);
                            this.showToast(`Deleted connection`);
                            this.draw();
                            return;
                        }
                    }
                }
            }

            onWheel(e) {
                e.preventDefault();

                // Multiplicative/Exponential zoom for smoothness
                const zoomFactor = 1.05;
                if (e.deltaY < 0) {
                    // Zoom IN
                    this.camera.zoom *= zoomFactor;
                } else {
                    // Zoom OUT
                    this.camera.zoom /= zoomFactor;
                }

                // Clamp zoom
                this.camera.zoom = Math.max(0.1, Math.min(6, this.camera.zoom));
            }

            /* --- Star Creation --- */

            createStar(x, y, z = 0) {
                let starColor = this.activeColor;
                if (this.colorMode === 'rainbow') {
                    starColor = this.getRainbowHex();
                }

                this.stars.push({
                    x, y,
                    z: z, // Store Z coordinate
                    id: Math.floor(Date.now() + Math.random() * 1000).toString(),
                    phase: Math.random() * Math.PI * 2,
                    color: starColor,
                    clusterId: null, // Will be calculated in refreshClusterAssignments()
                });
                this.draw();
            }

            /**
             * Re-calculates connections and assigns cluster names/IDs to all star objects.
             * Guarantees that s.clusterId is always a string (either the constellation name or the star's unique string ID).
             */
            refreshClusterAssignments() {
                const { lines, clusters } = this.calculateGeometry();

                // Map to hold assignments: { starId: clusterName/starId }
                const assignmentMap = new Map();

                // 1. Assign deterministic name (string) to all members of large clusters (>= minGroupSize)
                clusters.forEach(c => {
                    if (c.length >= this.config.minGroupSize) {
                        const name = this.getConstellationName(c);
                        c.forEach(star => {
                            assignmentMap.set(star.id, name);
                        });
                    }
                });

                // 2. Apply assignments back to the main stars array
                this.stars.forEach(s => {
                    // If a star is part of a large cluster, use the mapped string name. 
                    // Otherwise, preserve its existing name IF it's a real string (e.g. from template), else fallback to ID.
                    const assigned = assignmentMap.get(s.id);
                    if (assigned) {
                        s.clusterId = assigned;
                    } else if (s.clusterId && isNaN(parseFloat(s.clusterId))) {
                        // Keep existing custom name if it's not just a number
                        // This preserves "Wolf Major" even if connectivity logic doesn't group it yet
                    } else {
                        s.clusterId = s.id;
                    }
                });

                return { lines, clusters };
            }

            /* --- Utility Methods --- */

            getStarColor(s) {
                return s.color || '#e0faff'; // Fallback to default if somehow color is missing
            }

            hexToRgb(hex) {
                const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [
                    parseInt(result[1], 16),
                    parseInt(result[2], 16),
                    parseInt(result[3], 16)
                ] : [224, 240, 255]; // Default blue/white
            }


            /* --- Core Logic (State Management) --- */

            saveState() {
                // Save a deep copy of the stars array before an action that changes it
                const newState = JSON.stringify(this.stars.map(s => ({
                    x: s.x,
                    y: s.y,
                    id: String(s.id),
                    phase: s.phase,
                    color: s.color,
                })));
                if (this.history.length > 25) this.history.shift();
                this.history.push(newState);
                console.log('[UNDO] saveState called, history length:', this.history.length);
            }

            undo() {
                console.log('[UNDO] undo() called, history length:', this.history.length);
                if (this.history.length === 0) {
                    this.showToast("Nothing to undo");
                    return;
                }
                // Pop the last saved state and restore it
                const prevState = this.history.pop();
                if (prevState) {
                    this.stars = JSON.parse(prevState);
                    console.log('[UNDO] Restored state with', this.stars.length, 'stars');
                } else {
                    this.stars = [];
                }

                this.draw();
                this.showToast(`Undone(${this.history.length} remaining)`);
            }

            requestClear() {
                document.getElementById('clearModal').classList.add('active');
            }

            closeModal() {
                document.getElementById('clearModal').classList.remove('active');
            }

            confirmClear() {
                this.saveState();
                this.stars = [];
                this.camera = { x: 0, y: 0, zoom: 1 };
                this.closeModal();
                this.draw();
                this.showToast("Universe Imploded");
            }

            resetView() {
                this.camera = { x: 0, y: 0, zoom: 1 };
            }

            adjustZoom(delta) {
                this.camera.zoom = Math.max(0.1, Math.min(6, this.camera.zoom + delta));
                // Re-center camera on ship in flight mode to prevent drift
                // Re-center camera on ship in flight mode to prevent drift
                if (this.flightMode && this.playerShip) {
                    this.camera.x = -this.playerShip.x * this.camera.zoom;
                    this.camera.y = -this.playerShip.y * this.camera.zoom;
                }
            }

            getConstellationName(group) {
                // Priority: Check if any star already has a assigned name (e.g. from a Template or previous session)
                // We assume a real name is a string that isn't just a number/ID.
                const existing = group.find(s => s.clusterId && isNaN(parseFloat(s.clusterId)));
                if (existing) return existing.clusterId;

                const sortedIds = group.map(s => String(s.id)).sort((a, b) => a.localeCompare(b));
                let seed = 0;
                sortedIds.forEach((id, i) => {
                    for (let j = 0; j < id.length; j++) {
                        seed += id.charCodeAt(j) * (j + 1) * (i + 1);
                    }
                });
                seed = Math.floor(seed);

                const pre = this.prefixes[seed % this.prefixes.length];
                const root = this.roots[(seed * 13) % this.roots.length];
                const suf = this.suffixes[(seed * 7) % this.suffixes.length];

                const type = seed % 3;
                if (type === 0) return `${pre} ${root} `;
                if (type === 1) return `${root} ${suf} `;
                return `The ${pre} ${root} ${suf} `;
            }

            // Duplicate setBgStyle removed

            // ... (updateColorModeUI omitted)

            generateBackground() {
                try {
                    // Allow empty activeStyles for minimal black background with just faint stars
                    this.config.showBackground = true;
                    this.staticStars = [];
                    this.galaxies = [];
                    this.blackHoles = [];
                    this.shootingStars = [];
                    this.backgroundStars = [];
                    this.nebulae = [];
                    this.spacecraft = [];
                    this.matrixStreams = [];

                    // Load ship settings
                    // Load ship settings
                    const savedColor = localStorage.getItem('playerShipColor'); // Consistent Key
                    if (savedColor) this.playerShip.color = savedColor;

                    // FORCE UPDATE STATS (to fix "too slow" issue for existing saves)
                    // We re-apply base stats from the current type definitions
                    const type = this.playerShip.type || 'interceptor';
                    const baseStats = {
                        interceptor: { maxSpeed: 90, acceleration: 0.8 },
                        saucer: { maxSpeed: 110, acceleration: 1.0 },
                        hauler: { maxSpeed: 60, acceleration: 0.5 },
                        orion: { maxSpeed: 100, acceleration: 0.9 },
                        draco: { maxSpeed: 130, acceleration: 0.7 },
                        phoenix: { maxSpeed: 95, acceleration: 1.2 },
                        harvester: { maxSpeed: 140, acceleration: 1.3 } // Starfighter
                    }[type];

                    if (baseStats) {
                        this.playerShip.maxSpeed = baseStats.maxSpeed;
                        this.playerShip.acceleration = baseStats.acceleration;
                    }

                    const savedStruct = localStorage.getItem('customShipStructure');
                    if (savedStruct) {
                        try {
                            this.playerShip.customStructure = JSON.parse(savedStruct);
                        } catch (e) { console.error("Failed to load ship struct", e); }
                    }

                    // Load saved type
                    const savedType = localStorage.getItem('playerShipType');
                    if (savedType) this.playerShip.type = savedType;

                    // State handling for Cyber theme history
                    try {
                        const savedHistory = localStorage.getItem('matrixThemeHistory');
                        this.themeHistory = savedHistory ? JSON.parse(savedHistory) : [];
                        this.lastMatrixFamily = localStorage.getItem('matrixLastFamily') || '';
                    } catch (e) {
                        console.warn('[BG] Theme history load failed:', e);
                        this.themeHistory = [];
                        this.lastMatrixFamily = '';
                    }

                    // 1. Static Stars (Mixed Palette)
                    try {
                        this.generateStaticStars();
                    } catch (e) {
                        console.error('[BG Error] generateStaticStars failed:', e);
                        this.staticStars = [];
                    }

                    // 2. Compose Layers based on active styles
                    // Order matters for layering (Deep Space -> Nebula -> Alien -> Cyber)
                    if (this.activeStyles.has('deep-space')) {
                        try {
                            this.generateDeepSpaceStyle();
                        } catch (e) {
                            console.error('[BG Error] generateDeepSpaceStyle failed:', e);
                        }
                    }
                    if (this.activeStyles.has('nebula')) {
                        try {
                            this.generateNebulaStyle();
                        } catch (e) {
                            console.error('[BG Error] generateNebulaStyle failed:', e);
                        }
                    }
                    if (this.activeStyles.has('alien')) {
                        try {
                            this.generateAlienStyle();
                        } catch (e) {
                            console.error('[BG Error] generateAlienStyle failed:', e);
                        }
                    }
                    if (this.activeStyles.has('cyber')) {
                        try {
                            this.generateCyberStyle();
                        } catch (e) {
                            console.error('[BG Error] generateCyberStyle failed:', e);
                        }
                    }
                } catch (e) {
                    console.error('[BG Error] generateBackground failed critically:', e);
                    this.showToast('Background generation failed - using minimal mode');
                    // Ensure arrays exist to prevent cascade failures
                    this.staticStars = this.staticStars || [];
                    this.galaxies = this.galaxies || [];
                    this.blackHoles = this.blackHoles || [];
                    this.shootingStars = this.shootingStars || [];
                    this.backgroundStars = this.backgroundStars || [];
                    this.nebulae = this.nebulae || [];
                    this.spacecraft = this.spacecraft || [];
                    this.matrixStreams = this.matrixStreams || [];
                }
            }

            generateStaticStars() {
                // CLEAR existing stars first so color changes take effect
                this.staticStars = [];

                // Use more stars for warp mode for a denser hyperspace field
                const count = this.bgWarpMode ? 600 : 400;

                // ALWAYS read star colors directly from the DOM pickers
                const c1 = document.getElementById('starColor1')?.value || '#ffffff';
                const c2 = document.getElementById('starColor2')?.value || '#aaddff';
                const c3 = document.getElementById('starColor3')?.value || '#ffddaa';
                const activeColors = [c1, c2, c3];
                // Also update the stored starColors array
                this.starColors = activeColors;

                // Generate stars across a much wider area using uniform distribution
                const w = this.canvas.width;
                const h = this.canvas.height;
                const centerX = w / 2;
                const centerY = h / 2;
                const spreadX = w * 20;
                const spreadY = h * 20;

                for (let i = 0; i < count; i++) {
                    let x, y, vx = 0, vy = 0;

                    if (this.bgWarpMode) {
                        // Warp mode: Stars originate from center and move outward radially
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * Math.max(w, h) * 0.8;
                        x = centerX + Math.cos(angle) * dist;
                        y = centerY + Math.sin(angle) * dist;
                        // Faster radial velocity for dramatic hyperspace effect
                        const speed = 4 + Math.random() * 16;
                        vx = Math.cos(angle) * speed;
                        vy = Math.sin(angle) * speed;
                    } else {
                        // Normal / Drift mode: Uniform distribution
                        x = Math.random() * spreadX - spreadX / 2 + centerX;
                        y = Math.random() * spreadY - spreadY / 2 + centerY;

                        if (this.bgDriftMode) {
                            // Slow gentle drift in random direction
                            const angle = Math.random() * Math.PI * 2;
                            const speed = 0.1 + Math.random() * 0.3;
                            vx = Math.cos(angle) * speed;
                            vy = Math.sin(angle) * speed;
                        }
                    }

                    // Depth layer affects speed - creates parallax at high warp
                    const depthLayer = 0.3 + Math.random() * 0.7; // 0.3 to 1.0
                    this.staticStars.push({
                        x: x,
                        y: y,
                        vx: vx,
                        vy: vy,
                        size: (Math.random() * 1.5 + 0.5) * depthLayer, // Farther = smaller
                        alpha: Math.random() * 0.5 + 0.1,
                        baseAlpha: Math.random() * 0.5 + 0.1,
                        color: activeColors[Math.floor(Math.random() * activeColors.length)],
                        depth: depthLayer // Used for speed variation
                    });
                }
            }

            // Helper: Get hue from hex color
            getHueFromHex(hex) {
                const rgb = this.hexToRgb(hex);
                const r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h = 0;
                if (max !== min) {
                    const d = max - min;
                    if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                    else if (max === g) h = ((b - r) / d + 2) / 6;
                    else h = ((r - g) / d + 4) / 6;
                }
                return Math.round(h * 360);
            }

            // Helper: HSL to Hex
            hslToHex(h, s, l) {
                s /= 100; l /= 100;
                const k = n => (n + h / 30) % 12;
                const a = s * Math.min(l, 1 - l);
                const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
                const toHex = x => Math.round(x * 255).toString(16).padStart(2, '0');
                return `#${toHex(f(0))}${toHex(f(8))}${toHex(f(4))} `;
            }

            generateDeepSpaceStyle() {
                const range = this.worldSize;
                const half = range / 2;
                const zRange = 3000; // Increased Z-axis depth range

                // Define zoom tiers: close, medium, far
                // Close tier: objects within 400px of center (visible at max zoom ~5x)
                // Medium tier: objects 400-2000px from center (visible at default zoom ~1x)
                // Far tier: objects 2000-6000px from center (visible when zoomed out ~0.1x)

                // 1. Background Stars - distributed across all tiers
                const starCount = 600; // +20%
                for (let i = 0; i < starCount; i++) {
                    const tier = Math.random();
                    let dist, size;
                    if (tier < 0.2) { // Close tier - 20%
                        dist = Math.random() * 400;
                        size = 0.5 + Math.random() * 1.0;
                    } else if (tier < 0.5) { // Medium tier - 30%
                        dist = 400 + Math.random() * 1600;
                        size = 1.0 + Math.random() * 1.5;
                    } else { // Far tier - 50%
                        dist = 2000 + Math.random() * 4000;
                        size = 1.5 + Math.random() * 2.0;
                    }
                    const angle = Math.random() * Math.PI * 2;
                    this.backgroundStars.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist,
                        z: (Math.random() * zRange) - zRange / 2,
                        r: size,
                        alpha: 0.15 + Math.random() * 0.5
                    });
                }

                // 2. Galaxies - distributed across tiers (12 total, +50%)
                const galaxyConfigs = [
                    { count: 2, minDist: 100, maxDist: 400, minSize: 60, maxSize: 120 },   // Close
                    { count: 4, minDist: 400, maxDist: 2000, minSize: 100, maxSize: 250 }, // Medium
                    { count: 6, minDist: 2000, maxDist: 6000, minSize: 200, maxSize: 450 } // Far
                ];
                galaxyConfigs.forEach(cfg => {
                    for (let i = 0; i < cfg.count; i++) {
                        const dist = cfg.minDist + Math.random() * (cfg.maxDist - cfg.minDist);
                        const angle = Math.random() * Math.PI * 2;
                        this.galaxies.push({
                            x: Math.cos(angle) * dist,
                            y: Math.sin(angle) * dist,
                            z: (Math.random() * zRange) - zRange / 2,
                            // Expanded color palette
                            color: ['#ff0055', '#5500ff', '#00aaff', '#ff00aa', '#00ff88', '#ffaa00', '#aa00ff', '#ffffff'][Math.floor(Math.random() * 8)],
                            angle: Math.random() * Math.PI * 2,
                            size: cfg.minSize + Math.random() * (cfg.maxSize - cfg.minSize)
                        });
                    }
                });

                // 3. Black Holes - 3 total (+50%), one per tier
                const blackHoleConfigs = [
                    { minDist: 200, maxDist: 500, minSize: 20, maxSize: 40 },
                    { minDist: 800, maxDist: 2000, minSize: 40, maxSize: 80 },
                    { minDist: 2500, maxDist: 5000, minSize: 80, maxSize: 150 }
                ];
                blackHoleConfigs.forEach(cfg => {
                    const dist = cfg.minDist + Math.random() * (cfg.maxDist - cfg.minDist);
                    const angle = Math.random() * Math.PI * 2;
                    this.blackHoles.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist,
                        z: (Math.random() * zRange) - zRange / 2,
                        size: cfg.minSize + Math.random() * (cfg.maxSize - cfg.minSize)
                    });
                });

                // 4. Nebulae - 18 total (+50%), distributed across tiers
                const nebulaConfigs = [
                    { count: 4, minDist: 50, maxDist: 500, minSize: 150, maxSize: 350 },
                    { count: 6, minDist: 500, maxDist: 2500, minSize: 350, maxSize: 700 },
                    { count: 8, minDist: 2500, maxDist: 6000, minSize: 600, maxSize: 1200 }
                ];
                nebulaConfigs.forEach(cfg => {
                    for (let i = 0; i < cfg.count; i++) {
                        const dist = cfg.minDist + Math.random() * (cfg.maxDist - cfg.minDist);
                        const angle = Math.random() * Math.PI * 2;
                        this.nebulae.push({
                            x: Math.cos(angle) * dist,
                            y: Math.sin(angle) * dist,
                            z: (Math.random() * zRange) - zRange / 2,
                            size: cfg.minSize + Math.random() * (cfg.maxSize - cfg.minSize),
                            color: ['#4400cc', '#0033aa', '#cc0066', '#330066', '#003366', '#660033'][Math.floor(Math.random() * 6)],
                            alpha: 0.15 + Math.random() * 0.3
                        });
                    }
                });

                // 5. Planets - 15 total, distributed across tiers with spacing
                this.planets = [];
                const planetTypes = [
                    { name: 'gas-giant', colors: ['#E8C273', '#C17B3A', '#8B5A2B'], hasAtmosphere: true },
                    { name: 'ice-giant', colors: ['#87CEEB', '#4682B4', '#5F9EA0'], hasAtmosphere: true },
                    { name: 'terrestrial', colors: ['#228B22', '#8B4513', '#2E8B57'], hasAtmosphere: true },
                    { name: 'desert', colors: ['#EDC9AF', '#D2691E', '#CD853F'], hasAtmosphere: false },
                    { name: 'volcanic', colors: ['#8B0000', '#FF4500', '#DC143C'], hasAtmosphere: true },
                    { name: 'ocean', colors: ['#0077BE', '#005A87', '#003F5C'], hasAtmosphere: true }
                ];
                const planetConfigs = [
                    { count: 3, minDist: 100, maxDist: 500, minRadius: 20, maxRadius: 50 },
                    { count: 5, minDist: 500, maxDist: 2500, minRadius: 40, maxRadius: 100 },
                    { count: 7, minDist: 2500, maxDist: 6000, minRadius: 80, maxRadius: 180 }
                ];

                // Helper to perturb colors for variety
                const perturbColor = (hex, amount = 30) => {
                    if (!hex || !hex.startsWith('#')) return hex;
                    let r = parseInt(hex.slice(1, 3), 16);
                    let g = parseInt(hex.slice(3, 5), 16);
                    let b = parseInt(hex.slice(5, 7), 16);

                    r = Math.min(255, Math.max(0, r + (Math.random() - 0.5) * amount * 2));
                    g = Math.min(255, Math.max(0, g + (Math.random() - 0.5) * amount * 2));
                    b = Math.min(255, Math.max(0, b + (Math.random() - 0.5) * amount * 2));

                    return `#${(r | 0).toString(16).padStart(2, '0')}${(g | 0).toString(16).padStart(2, '0')}${(b | 0).toString(16).padStart(2, '0')} `;
                };

                // Helper to check if a new planet overlaps with existing ones
                const checkPlanetSpacing = (x, y, z, radius) => {
                    const minSpacing = 800; // Increased spacing for "X, Y" separation (Visual Clutter reduction)
                    const minZSpacing = 1000; // Z-axis separation

                    for (const existing of this.planets) {
                        const dx = x - existing.x;
                        const dy = y - existing.y;
                        const dz = z - existing.z;

                        // 2D Distance Check (Screen Space Prevention)
                        const dist2D = Math.sqrt(dx * dx + dy * dy);
                        const required2D = radius + existing.radius + minSpacing;

                        // 3D Distance Check (Physical Collision)
                        const dist3D = Math.sqrt(dx * dx + dy * dy + dz * dz);

                        // If they are too close on screen, ensure they are FAR apart in Z
                        if (dist2D < required2D) {
                            if (Math.abs(dz) < minZSpacing) return false;
                        }
                    }
                    return true;
                };

                // Planet tier-specific z-depth ranges for visual separation
                const zDepthTiers = [
                    { minZ: -1000, maxZ: -400 },  // Close tier: in front
                    { minZ: -400, maxZ: 400 },     // Medium tier: middle
                    { minZ: 400, maxZ: 1200 }       // Far tier: behind
                ];

                planetConfigs.forEach((cfg, tierIndex) => {
                    const zTier = zDepthTiers[tierIndex];

                    for (let i = 0; i < cfg.count; i++) {
                        const type = planetTypes[Math.floor(Math.random() * planetTypes.length)];
                        const hasRings = Math.random() > 0.5;
                        const radius = cfg.minRadius + Math.random() * (cfg.maxRadius - cfg.minRadius);

                        // Try to find a non-overlapping position (max 50 attempts)
                        let x, y, z, attempts = 0;
                        do {
                            const dist = cfg.minDist + Math.random() * (cfg.maxDist - cfg.minDist);
                            const angle = Math.random() * Math.PI * 2;
                            x = Math.cos(angle) * dist;
                            y = Math.sin(angle) * dist;
                            // Assign z-depth based on tier for visual depth separation
                            z = zTier.minZ + Math.random() * (zTier.maxZ - zTier.minZ);
                            attempts++;
                        } while (!checkPlanetSpacing(x, y, z, radius) && attempts < 50);

                        this.planets.push({
                            x: x,
                            y: y,
                            z: z, // Use the Z we calculated
                            radius: radius,
                            type: type.name,
                            // Randomize colors slightly for variety
                            baseColor: perturbColor(type.colors[0], 40),
                            secondaryColor: perturbColor(type.colors[1], 40),
                            tertiaryColor: perturbColor(type.colors[2], 40),
                            hasAtmosphere: type.hasAtmosphere,
                            atmosphereColor: type.name === 'ice-giant' ? '#ADD8E6' : (type.name === 'volcanic' ? '#FF6347' : '#87CEEB'),
                            hasRings: hasRings,
                            ringColor: hasRings ? `hsl(${Math.random() * 360}, ${40 + Math.random() * 40} %, ${50 + Math.random() * 30} %)` : null, // Full HSL/RGB variety
                            ringInnerRadius: radius * 1.3,
                            ringOuterRadius: radius * 2.2,
                            textureSeed: Math.random() * 1000,
                            rotation: Math.random() * Math.PI * 2,
                            axialTilt: (Math.random() - 0.5) * 0.6
                        });
                    }
                });

                // 6. Moving Cosmic Stars (shooting stars / drifting stars)
                this.shootingStars = [];
                const shootingStarCount = 15;
                for (let i = 0; i < shootingStarCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 500 + Math.random() * 5000;
                    this.shootingStars.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist,
                        z: (Math.random() * zRange) - zRange / 2,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        size: 1 + Math.random() * 2,
                        tailLength: 20 + Math.random() * 40,
                        color: ['#ffffff', '#ffffaa', '#aaffff', '#ffaaff'][Math.floor(Math.random() * 4)],
                        alpha: 0.4 + Math.random() * 0.4
                    });
                }
            }

            generateNebulaStyle() {
                const zRange = 3000;

                // Nebulae distributed across zoom tiers (30 total, +50%)
                const nebulaConfigs = [
                    { count: 6, minDist: 50, maxDist: 500, minSize: 100, maxSize: 300 },    // Close
                    { count: 10, minDist: 500, maxDist: 2500, minSize: 300, maxSize: 800 }, // Medium
                    { count: 14, minDist: 2500, maxDist: 6000, minSize: 700, maxSize: 1500 } // Far
                ];
                const colors = ['#ff0055', '#ffaa00', '#00ffaa', '#0055ff', '#ff00ff', '#00ffff', '#ff5500', '#55ff00'];

                nebulaConfigs.forEach(cfg => {
                    for (let i = 0; i < cfg.count; i++) {
                        const dist = cfg.minDist + Math.random() * (cfg.maxDist - cfg.minDist);
                        const angle = Math.random() * Math.PI * 2;
                        this.nebulae.push({
                            x: Math.cos(angle) * dist,
                            y: Math.sin(angle) * dist,
                            z: (Math.random() * zRange) - zRange / 2,
                            size: cfg.minSize + Math.random() * (cfg.maxSize - cfg.minSize),
                            color: colors[Math.floor(Math.random() * colors.length)],
                            alpha: 0.25 + Math.random() * 0.35
                        });
                    }
                });

                // Background stars distributed across tiers (1000 total, +25%)
                const starCount = 1000;
                for (let i = 0; i < starCount; i++) {
                    const tier = Math.random();
                    let dist, size;
                    if (tier < 0.2) {
                        dist = Math.random() * 500;
                        size = 0.5 + Math.random() * 1.0;
                    } else if (tier < 0.5) {
                        dist = 500 + Math.random() * 2000;
                        size = 1.0 + Math.random() * 1.5;
                    } else {
                        dist = 2500 + Math.random() * 3500;
                        size = 1.5 + Math.random() * 2.5;
                    }
                    const angle = Math.random() * Math.PI * 2;
                    this.backgroundStars.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist,
                        z: (Math.random() * zRange) - zRange / 2,
                        r: size,
                        alpha: 0.2 + Math.random() * 0.5
                    });
                }
            }

            generateAlienStyle() {
                const zRange = 3000;

                // Green/Purple Theme (Randomized Mix)
                const theme = Math.random();
                let color1, color2;
                if (theme < 0.33) { color1 = '#00ff00'; color2 = '#ccff00'; }
                else if (theme < 0.66) { color1 = '#aa00ff'; color2 = '#ff00aa'; }
                else { color1 = '#00ffff'; color2 = '#0000ff'; }

                // Background stars distributed across zoom tiers (1800 total, +20%)
                const starCount = 1800;
                for (let i = 0; i < starCount; i++) {
                    const tier = Math.random();
                    let dist, size;
                    if (tier < 0.2) {
                        dist = Math.random() * 500;
                        size = 0.3 + Math.random() * 0.6;
                    } else if (tier < 0.5) {
                        dist = 500 + Math.random() * 2000;
                        size = 0.5 + Math.random() * 0.8;
                    } else {
                        dist = 2500 + Math.random() * 3500;
                        size = 0.7 + Math.random() * 1.2;
                    }
                    const angle = Math.random() * Math.PI * 2;
                    this.backgroundStars.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist,
                        z: (Math.random() * zRange) - zRange / 2,
                        r: size,
                        alpha: 0.1 + Math.random() * 0.4,
                        color: Math.random() > 0.5 ? color1 : color2
                    });
                }

                // Alien Spacecraft Fleet - distributed across zoom tiers (30 total, +50%)
                const shipClasses = [
                    { name: 'saucer', baseSize: 50, complexity: 'high', weight: 4 },
                    { name: 'star-dreadnought', baseSize: 120, complexity: 'high', weight: 1 },
                    { name: 'quantum-scout', baseSize: 40, complexity: 'high', weight: 3 },
                    { name: 'void-fighter', baseSize: 30, complexity: 'medium', weight: 4 },
                    { name: 'nebula-cruiser', baseSize: 90, complexity: 'high', weight: 2 },
                    { name: 'bio-corvette', baseSize: 60, complexity: 'high', weight: 2 },
                    { name: 'warp-strider', baseSize: 100, complexity: 'medium', weight: 1 },
                    { name: 'prism-destroyer', baseSize: 80, complexity: 'low', weight: 2 },
                    { name: 'stellar-barge', baseSize: 110, complexity: 'medium', weight: 2 },
                    { name: 'cyber-sentry', baseSize: 35, complexity: 'high', weight: 3 },
                    { name: 'aether-wing', baseSize: 50, complexity: 'high', weight: 2 },
                    { name: 'death-sphere', baseSize: 150, complexity: 'high', weight: 1 },
                    { name: 'tie-fighter', baseSize: 45, complexity: 'high', weight: 3 }
                ];

                // Build weighted selection pool
                const pool = [];
                shipClasses.forEach(sc => {
                    for (let w = 0; w < sc.weight; w++) pool.push(sc);
                });

                // Spacecraft configs per tier
                const craftConfigs = [
                    { count: 6, minDist: 50, maxDist: 500, sizeScale: 0.4 },    // Close - small ships
                    { count: 10, minDist: 500, maxDist: 2500, sizeScale: 0.7 }, // Medium
                    { count: 14, minDist: 2500, maxDist: 6000, sizeScale: 1.2 } // Far - larger ships
                ];

                craftConfigs.forEach(cfg => {
                    for (let i = 0; i < cfg.count; i++) {
                        const shipClass = pool[Math.floor(Math.random() * pool.length)];
                        const hue = Math.random() * 360;
                        const size = shipClass.baseSize * cfg.sizeScale * (0.7 + Math.random() * 0.6);
                        const isSaucer = shipClass.name === 'saucer';
                        const dist = cfg.minDist + Math.random() * (cfg.maxDist - cfg.minDist);
                        const angle = Math.random() * Math.PI * 2;

                        this.spacecraft.push({
                            x: Math.cos(angle) * dist,
                            y: Math.sin(angle) * dist,
                            z: (Math.random() * zRange) - zRange / 2,
                            vx: (Math.random() - 0.5) * (isSaucer ? 2 : 3),
                            vy: (Math.random() - 0.5) * (isSaucer ? 2 : 3),
                            size: size,
                            shipClass: shipClass.name,
                            complexity: shipClass.complexity,
                            hullColor: isSaucer ? `hsl(${hue}, 10 %, 50 %)` : `hsl(${hue}, 30 %, 40 %)`,
                            hullHighlight: isSaucer ? `hsl(${hue}, 5 %, 85 %)` : `hsl(${hue}, 20 %, 70 %)`,
                            hullShadow: isSaucer ? `hsl(${hue}, 15 %, 25 %)` : `hsl(${hue}, 40 %, 20 %)`,
                            engineColor: `hsl(${(hue + 180) % 360}, 100%, 60 %)`,
                            engineGlow: `hsl(${(hue + 180) % 360}, 100 %, 85 %)`,
                            lightColor: `hsl(${Math.random() * 60 + 300}, 100 %, 55 %)`,
                            lightColor2: `hsl(${Math.random() * 60}, 100 %, 50 %)`,
                            lightPhase: Math.random() * Math.PI * 2,
                            detailSeed: Math.random() * 1000,
                            wingAngle: 0.3 + Math.random() * 0.4,
                            engineCount: shipClass.name === 'mothership' ? 6 : (shipClass.name === 'destroyer' ? 4 : (shipClass.name === 'cruiser' ? 3 : 2)),
                            domeColor: `hsl(${Math.random() * 180 + 160}, 80 %, 70 %)`,
                            beamActive: Math.random() > 0.7,
                            beamColor: `hsl(${Math.random() * 60 + 80}, 100 %, 70 %)`,
                            ringCount: isSaucer ? Math.floor(Math.random() * 3) + 2 : 0,
                            rotationSpeed: (Math.random() - 0.5) * 0.02,
                            rotation: Math.random() * Math.PI * 2,
                            hasShield: Math.random() > 0.8,
                            shieldColor: `hsl(${Math.random() * 60 + 180}, 70 %, 60 %)`,
                            shieldPhase: Math.random() * Math.PI * 2
                        });
                    }
                });
            }

            generateCyberStyle() {
                // Reset custom color flag so new generation allows random themes again
                this.matrixColorCustomized = false;

                // Matrix Rain Setup (Screen Space)
                this.matrixStreams = [];
                const fontSize = 14;
                const columns = Math.ceil(this.canvas.width / fontSize);

                // Base Themes
                // Top 20 Curated Cyber Colors + Rainbow Surge
                const themes = [
                    { name: 'System Yellow', color: '#FFFF00', family: 'yellow' },
                    { name: 'Neon Pink', color: '#FF1493', family: 'pink' },
                    { name: 'Chrome Static', color: '#C0C0C0', family: 'mono' }, // Silver
                    { name: 'Royal Data', color: '#4169E1', family: 'blue' }, // Royal Blue
                    { name: 'Navy Blue', color: '#000080', family: 'blue' },
                    { name: 'White Noise', color: '#FFFFFF', family: 'mono' },
                    { name: 'Golden Key', color: '#FFD700', family: 'yellow' }, // Gold
                    { name: 'Firewall Orange', color: '#FF4500', family: 'pink' },
                    { name: 'Cyan Future', color: '#00FFFF', family: 'blue' },
                    { name: 'Lime Access', color: '#32CD32', family: 'green' },
                    { name: 'Purple Haze', color: '#800080', family: 'purple' },
                    { name: 'Crimson Error', color: '#DC143C', family: 'pink' },
                    { name: 'Teal Glitch', color: '#008080', family: 'green' },
                    { name: 'Magenta Core', color: '#FF00FF', family: 'pink' },
                    { name: 'Violet Mainframe', color: '#EE82EE', family: 'purple' },
                    { name: 'Emerald Link', color: '#50C878', family: 'green' },
                    { name: 'Sapphire Stream', color: '#0F52BA', family: 'blue' },
                    { name: 'Ruby Firewall', color: '#E0115F', family: 'pink' },
                    { name: 'Amber Alert', color: '#FFBF00', family: 'yellow' },
                    { name: 'Ice Blue', color: '#A5F2F3', family: 'blue' },
                    { name: 'sentAIent Blue', color: '#60A9FF', family: 'blue' },
                    { name: 'Rainbow Surge', color: 'rainbow', family: 'rainbow' }
                ];

                // History Buffer Logic (Last 5 themes) + Family Check
                // Filter out ANY theme that is in the history buffer OR matches the last family
                const lastFamily = this.lastMatrixFamily || '';

                let availableThemes = themes.filter(t => !this.themeHistory.includes(t.name));

                // Try to filter by family too, but ensure we don't empty the pool
                const familyFiltered = availableThemes.filter(t => t.family !== lastFamily);
                if (familyFiltered.length > 0) {
                    availableThemes = familyFiltered;
                }

                // Fallback: If we ran out of themes (unlikely), just avoid the very last one
                let pool = availableThemes;
                if (pool.length === 0) {
                    const lastTheme = this.themeHistory[this.themeHistory.length - 1];
                    pool = themes.filter(t => t.name !== lastTheme);
                }

                const themeIndex = Math.floor(Math.random() * pool.length);
                const theme = pool[themeIndex];

                // Update History
                this.themeHistory.push(theme.name);
                if (this.themeHistory.length > 5) {
                    this.themeHistory.shift(); // Keep only last 5
                }
                this.lastMatrixFamily = theme.family; // Track family

                // Persist to LocalStorage
                try {
                    localStorage.setItem('matrixThemeHistory', JSON.stringify(this.themeHistory));
                    localStorage.setItem('matrixLastFamily', this.lastMatrixFamily);
                } catch (e) {
                    console.warn('LocalStorage failed', e);
                }

                console.log(`[Matrix] Selected: ${theme.name} (${theme.family}), History: ${JSON.stringify(this.themeHistory)}, Pool Size: ${pool.length} `);

                this.matrixTheme = theme;

                // Discrete Speed Levels: Crawl, Slow, Normal, Fast, Hyper, Ludicrous
                const speedLevels = [
                    { name: 'Crawl', value: 0.2 },
                    { name: 'Slow', value: 0.5 },
                    { name: 'Normal', value: 1.0 },
                    { name: 'Fast', value: 2.0 },
                    { name: 'Hyper', value: 4.0 },
                    { name: 'Ludicrous', value: 8.0 }
                ];
                const selectedSpeed = speedLevels[Math.floor(Math.random() * speedLevels.length)];
                this.matrixSpeedMultiplier = selectedSpeed.value;

                this.showToast(`Cyber Theme: ${theme.name} (Speed: ${selectedSpeed.name}) [v14]`);

                // Update UI Display
                const displayEl = document.getElementById('matrixThemeDisplay');
                if (displayEl) {
                    displayEl.innerText = `Theme: ${theme.name} | Family: ${theme.family.charAt(0).toUpperCase() + theme.family.slice(1)} `;
                }

                // Sync speed slider with current value
                const slider = document.getElementById('matrixSpeedSlider');
                const sliderValue = document.getElementById('matrixSpeedValue');
                if (slider) slider.value = this.matrixSpeedMultiplier;
                if (sliderValue) sliderValue.textContent = this.matrixSpeedMultiplier.toFixed(1) + 'x';

                for (let i = 0; i < columns; i++) {
                    const depth = Math.random(); // 0 to 1
                    const size = Math.floor(10 + depth * 14); // 10px to 24px
                    // Apply speed multiplier with per-stream variance
                    const speed = (2 + depth * 8 + Math.random() * 2) * this.matrixSpeedMultiplier;

                    // Massive Trails: 600 to 1500 characters (3x longer)
                    const len = 600 + Math.floor(Math.random() * 9000);
                    const chars = [];
                    for (let j = 0; j < len; j++) {
                        chars.push(String.fromCharCode(0x30A0 + Math.random() * 96));
                    }

                    // Handle Rainbow Theme
                    let streamColor = theme.color;
                    if (this.matrixColorCustomized) {
                        streamColor = this.matrixColor;
                    } else if (theme.name === 'Rainbow Surge') {
                        // Calculate hue based on column index (i) to cycle through the spectrum
                        const hue = (i * 360 / columns) % 360;
                        streamColor = `hsl(${hue}, 100 %, 50 %)`; // Full saturation, mid lightness
                    }

                    this.matrixStreams.push({
                        x: i * fontSize, // Fixed columns
                        y: Math.random() * this.canvas.height, // Start FULLY VISIBLE across entire screen
                        size: fontSize,
                        baseSpeed: (2 + depth * 8 + Math.random() * 2) * (Math.random() * 0.5 + 0.75), // Vary speed
                        chars: chars,
                        color: streamColor,
                        opacity: 0.9
                    });
                }

                console.log(`[Matrix] Generated ${this.matrixStreams.length} streams, columns: ${columns}, theme: ${theme.name} `);
            }

            /* --- Rendering --- */

            animate(time) {
                // Update flight game physics
                if (this.flightMode) {
                    this.updatePlayerShip();
                    this.updateMinerals();
                    this.updateFlightHUD();
                }

                // Update spacecraft positions
                if (this.spacecraft && this.spacecraft.length > 0) {
                    const range = this.worldSize;
                    const half = range / 2;
                    this.spacecraft.forEach(s => {
                        s.x += s.vx;
                        s.y += s.vy;
                        // Wrap around world bounds
                        if (s.x > half) s.x = -half;
                        if (s.x < -half) s.x = half;
                        if (s.y > half) s.y = -half;
                        if (s.y < -half) s.y = half;
                    });
                }

                // Update shooting/moving stars positions
                if (this.shootingStars && this.shootingStars.length > 0) {
                    const range = this.worldSize;
                    const half = range / 2;
                    this.shootingStars.forEach(s => {
                        s.x += s.vx;
                        s.y += s.vy;
                        // Wrap around world bounds
                        if (s.x > half) s.x = -half;
                        if (s.x < -half) s.x = half;
                        if (s.y > half) s.y = -half;
                        if (s.y < -half) s.y = half;
                    });
                }

                // Update static stars for Drift/Warp modes (with error handling)
                try {
                    if ((this.bgDriftMode || this.bgWarpMode) && this.staticStars && this.staticStars.length > 0) {
                        const w = this.canvas.width;
                        const h = this.canvas.height;
                        const centerX = w / 2;
                        const centerY = h / 2;

                        // Ramp warp speed - works during both engage (bgWarpMode) and disengage (warpDisengaging)
                        if (this.bgWarpMode || this.warpDisengaging) {
                            // warpSpeedMultiplier is now linear (0.1 to 840)
                            const linearSlider = this.warpSpeedMultiplier || 1;
                            // Normalize to warp range (0 to 25.2) - TRIPLED max speed
                            const targetWarp = Math.min(25.2, linearSlider / 33);

                            const rampSpeed = 0.02; // Slightly faster ramp for responsiveness
                            this.warpSpeed = this.warpSpeed || 0;
                            this.warpSpeed += (targetWarp - this.warpSpeed) * rampSpeed;
                            // Cap to prevent runaway - TRIPLED max
                            this.warpSpeed = Math.min(this.warpSpeed, 25.2);
                            // Also cap minimum during disengage
                            if (this.warpSpeed < 0.01) this.warpSpeed = 0;
                        }

                        this.staticStars.forEach(s => {
                            // Safety: Ensure velocity properties exist
                            if (typeof s.vx !== 'number') s.vx = 0;
                            if (typeof s.vy !== 'number') s.vy = 0;
                            if (typeof s.baseAlpha !== 'number') s.baseAlpha = s.alpha || 0.5;

                            // Store original position if not yet stored (for warp start)
                            if (typeof s.origX !== 'number') s.origX = s.x;
                            if (typeof s.origY !== 'number') s.origY = s.y;

                            // Stars move during BOTH engage and disengage
                            if ((this.bgWarpMode || this.warpDisengaging) && !this.bgDriftMode) {
                                // LIGHTSPEED: Stars fly OUTWARD from center, accelerating
                                const dx = s.x - centerX;
                                const dy = s.y - centerY;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                // Direction outward from center with slight jitter at high speeds
                                const warpIntensity = (this.warpSpeed || 0);
                                // Add subtle angular wobble at high speeds for organic look
                                const jitterAmount = Math.min(0.08, warpIntensity * 0.003);
                                const jitterAngle = (Math.random() - 0.5) * jitterAmount;
                                const baseDirX = dist > 1 ? dx / dist : 0;
                                const baseDirY = dist > 1 ? dy / dist : 0;
                                // Apply rotation for jitter
                                const cosJ = Math.cos(jitterAngle);
                                const sinJ = Math.sin(jitterAngle);
                                const dirX = baseDirX * cosJ - baseDirY * sinJ;
                                const dirY = baseDirX * sinJ + baseDirY * cosJ;

                                // Speed varies by depth layer - creates parallax/3D feel
                                const depthFactor = s.depth || 0.5;
                                const perspectiveAccel = 1 + (dist / Math.max(w, h)) * 1.2;
                                // Deeper stars move faster, creates sense of passing through field
                                const speed = warpIntensity * perspectiveAccel * 10.5 * depthFactor;

                                // Move star outward
                                s.x += dirX * speed;
                                s.y += dirY * speed;

                                // Respawn from center when star goes off screen
                                const maxDist = Math.max(w, h) * 0.9;
                                if (dist > maxDist || s.x < -50 || s.x > w + 50 || s.y < -50 || s.y > h + 50) {
                                    // Respawn with wider random distance spread
                                    const angle = Math.random() * Math.PI * 2;
                                    // More variation in spawn distance for staggered arrivals
                                    const startDist = 3 + Math.random() * Math.random() * 80;
                                    s.x = centerX + Math.cos(angle) * startDist;
                                    s.y = centerY + Math.sin(angle) * startDist;
                                    s.alpha = 0.05; // Start very faint
                                    // Randomize depth on respawn for variety
                                    s.depth = 0.3 + Math.random() * 0.7;
                                    s.size = (Math.random() * 1.5 + 0.5) * s.depth;
                                } else {
                                    // Fade in as star moves outward, faster fade for deeper stars
                                    const fadeRate = 0.6 + depthFactor * 0.4;
                                    s.alpha = Math.min(1, 0.15 + (dist / maxDist) * 0.85 * fadeRate);
                                }
                            } else if (this.bgDriftMode && !this.bgWarpMode) {
                                // Drift: Subtle but noticeable movement
                                s.x += s.vx * 0.03;
                                s.y += s.vy * 0.03;

                                // Wrap around screen
                                if (s.x < -w * 5) s.x += w * 10;
                                if (s.x > w * 5) s.x -= w * 10;
                                if (s.y < -h * 5) s.y += h * 10;
                                if (s.y > h * 5) s.y -= h * 10;
                            }
                        });
                    }
                } catch (e) {
                    console.error('[BG Error] Static star animation failed:', e);
                    // Fail silently to prevent crash loop
                }

                // === WARP FLYOUT/FLYIN: Move background objects ===
                // IMPORTANT: Objects use WORLD coordinates with (0,0) at world center
                // Camera transform places world (0,0) at screen center
                if (this.bgWarpMode || this.warpDisengaging) {
                    try {
                        const w = this.canvas.width;
                        const h = this.canvas.height;
                        // SCREEN CENTER in WORLD coordinates - this is where light rays emanate from
                        // Safety: ensure camera exists
                        const camera = this.camera || { x: 0, y: 0, zoom: 1 };
                        const zoom = camera.zoom || 1;
                        const screenCenterWorldX = -(camera.x || 0) / zoom;
                        const screenCenterWorldY = -(camera.y || 0) / zoom;
                        // Max distance before object is "off screen" in world coords
                        const maxWorldDist = this.worldSize * 2;
                        // Use the SAME warpIntensity as static stars for synchronized motion
                        const warpIntensity = this.warpSpeed || 0;
                        const isDisengaging = this.warpDisengaging;

                        // Helper to fly an object using WORLD coordinates
                        const flyObject = (obj, speedMultiplier = 1, maxSpread = 2000) => {
                            if (!obj) return;

                            if (isDisengaging) {
                                // === DISENGAGE: Objects appear at random positions and gradually decelerate ===
                                // Matches light ray deceleration - gradual slowdown as we exit lightspeed

                                // CRITICAL: Reset flownOut so object renders during disengage
                                obj.flownOut = false;

                                // Initialize on first frame of disengage
                                if (!obj.disengageInit) {
                                    // Assign random final position around screen
                                    // Some close (fly by), some in distance
                                    const angle = Math.random() * Math.PI * 2;
                                    const distance = 200 + Math.random() * maxSpread;
                                    const depth = 0.3 + Math.random() * 1.4; // 0.3 to 1.7 depth factor

                                    obj.finalX = screenCenterWorldX + Math.cos(angle) * distance;
                                    obj.finalY = screenCenterWorldY + Math.sin(angle) * distance;
                                    obj.depth = depth; // Closer objects move faster

                                    // Start position: exact center (simulating vanishing point)
                                    // This creates the effect of objects spawning from a single point
                                    obj.startX = screenCenterWorldX;
                                    obj.startY = screenCenterWorldY;

                                    // Reset scale/alpha for emergence
                                    obj.warpScale = 0.01;
                                    obj.warpAlpha = 0;

                                    obj.disengageInit = true;
                                }

                                // Use SAME progress calculation as light ray deceleration (warpSpeed-based)
                                // This synchronizes object movement with light ray shortening
                                const maxWarp = 25;
                                const currentWarp = warpIntensity || 0;
                                // Progress: 0 = full warp, 1 = stopped
                                const progress = 1 - Math.min(1, currentWarp / maxWarp);

                                // Position: LINEAR interpolation synced with warp
                                // Objects move at same rate as stars slow down
                                obj.x = obj.startX + (obj.finalX - obj.startX) * progress;
                                obj.y = obj.startY + (obj.finalY - obj.startY) * progress;

                                // Scale: EXPONENTIAL (Perspective-like)
                                // Objects stay small in distance, then loom large on arrival
                                // Cubic easing (t*t*t) simulates Z-axis approach better than linear
                                const ease = progress * progress * progress;
                                obj.warpScale = 0.01 + ease * 0.99; // Target 1.0 strictly (Depth handled by size)
                                obj.warpScale = Math.min(1, Math.max(0.01, obj.warpScale));

                                // Alpha: Stay INVISIBLE behind light for first 35% of animation
                                // Then fade in gradually, reaching full opacity when warp stops
                                const alphaDelay = 0.35; // 35% - stay behind light longer
                                const alphaProgress = Math.max(0, (progress - alphaDelay) / (1 - alphaDelay));
                                obj.warpAlpha = alphaProgress; // Linear fade to 1.0 (draw loop handles base alpha)

                                return; // Don't continue to engage logic

                            } else {
                                // === ENGAGE: Fly RADIALLY OUTWARD from SCREEN center ===
                                // Account for zoom level - objects at higher zoom should fly faster
                                if (obj.flownOut) return;

                                // Direction is from SCREEN CENTER outward (not world center)
                                const dx = obj.x - screenCenterWorldX;
                                const dy = obj.y - screenCenterWorldY;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                // If exactly at center, give random direction
                                if (dist < 5) {
                                    const angle = Math.random() * Math.PI * 2;
                                    obj.x += Math.cos(angle) * 20;
                                    obj.y += Math.sin(angle) * 20;
                                    return;
                                }

                                // Normalize for radial outward direction
                                const dirX = dx / dist;
                                const dirY = dy / dist;

                                // ZOOM COMPENSATION: Objects at higher zoom need to move faster
                                // to appear to leave the screen at the same visual rate
                                const zoomFactor = 1 / (this.camera.zoom || 1);

                                const perspectiveAccel = 1 + (dist / this.worldSize) * 1.2;
                                const depth = obj.depth || 0.5;
                                const engageSpeedFactor = 4.0;
                                const speed = warpIntensity * perspectiveAccel * 10.5 * depth * speedMultiplier * engageSpeedFactor * zoomFactor;

                                // Move radially outward from world center
                                obj.x += dirX * speed;
                                obj.y += dirY * speed;

                                // Mark as flown out when far from world center
                                if (dist > maxWorldDist) {
                                    obj.flownOut = true;
                                    obj.wasFlownOut = true; // Track for disengage reset
                                }
                            }
                        };

                        // Apply to all object types - different depths create parallax
                        // Assign typeIndex for golden ratio distribution (avoids ring patterns)
                        let globalIndex = 0;
                        if (this.planets) this.planets.forEach((p, i) => {
                            p.depth = p.depth || 0.6;
                            p.typeIndex = globalIndex++;
                            flyObject(p, 0.8, 3000);
                        });
                        if (this.galaxies) this.galaxies.forEach((g, i) => {
                            g.depth = g.depth || 0.4;
                            g.typeIndex = globalIndex++;
                            flyObject(g, 0.5, 5000);
                        });
                        if (this.blackHoles) this.blackHoles.forEach((bh, i) => {
                            bh.depth = bh.depth || 0.3;
                            bh.typeIndex = globalIndex++;
                            flyObject(bh, 0.4, 4000);
                        });
                        if (this.nebulae) this.nebulae.forEach((n, i) => {
                            n.depth = n.depth || 0.5;
                            n.typeIndex = globalIndex++;
                            flyObject(n, 0.6, 4000);
                        });
                        if (this.spacecraft) this.spacecraft.forEach((s, i) => {
                            s.depth = s.depth || 0.8;
                            s.typeIndex = globalIndex++;
                            flyObject(s, 1.2, 2000);
                        });
                        // User-placed stars
                        if (this.stars && this.stars.length > 0) {
                            this.stars.forEach((star, i) => {
                                star.depth = star.depth || 0.7;
                                star.typeIndex = globalIndex++;
                                flyObject(star, 0.9, 2500);
                            });
                        }
                    } catch (e) {
                        console.error('[WARP] Animation error:', e);
                    }
                }

                this.draw(time);
                requestAnimationFrame(this.animate);
            }

            draw(time) {
                const { ctx, canvas } = this;

                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.fillStyle = this.config.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Static Background Stars (Screen Space)
                if (this.config.showBackground) {
                    const paraX = this.camera.x * 0.05;
                    const paraY = this.camera.y * 0.05;

                    try {
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;
                        const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);
                        const time = performance.now() / 1000;

                        this.staticStars.forEach(s => {
                            // Safety check for required properties
                            if (typeof s.x !== 'number' || typeof s.y !== 'number') return;

                            let sx = (s.x + paraX) % canvas.width;
                            let sy = (s.y + paraY) % canvas.height;
                            if (sx < 0) sx += canvas.width;
                            if (sy < 0) sy += canvas.height;

                            // Ensure we have valid values
                            const vx = typeof s.vx === 'number' ? s.vx : 0;
                            const vy = typeof s.vy === 'number' ? s.vy : 0;
                            const size = s.r || s.size || 1; // Use 'r' if available (matches generation)
                            const starColor = s.color || '#ffffff';

                            // Parse star color for gradient manipulation
                            let r = 255, g = 255, b = 255;
                            try {
                                if (starColor.startsWith('#')) {
                                    const hex = starColor.slice(1);
                                    // Use ?? instead of || to preserve 0 values (0 is valid for RGB!)
                                    const parsedR = parseInt(hex.substr(0, 2), 16);
                                    const parsedG = parseInt(hex.substr(2, 2), 16);
                                    const parsedB = parseInt(hex.substr(4, 2), 16);
                                    r = isNaN(parsedR) ? 255 : parsedR;
                                    g = isNaN(parsedG) ? 255 : parsedG;
                                    b = isNaN(parsedB) ? 255 : parsedB;
                                }
                            } catch (e) { /* use defaults */ }

                            if (this.bgWarpMode && !this.bgDriftMode) {
                                // ====== LIGHTSPEED: Moving stars with trailing streaks ======
                                const dx = sx - centerX;
                                const dy = sy - centerY;
                                const distFromCenter = Math.sqrt(dx * dx + dy * dy);

                                if (distFromCenter < 3) return; // Skip center stars

                                // Warp intensity - already curved via setWarpSpeedMultiplier
                                const warpIntensity = this.warpSpeed || 0;
                                const sliderValue = this.warpSpeedMultiplier || 1;

                                // Streak length varies by depth - deeper stars = longer streaks
                                // Low slider = short rays, high slider = dramatic but not overwhelming
                                const perspFactor = distFromCenter / maxDist;
                                const depthFactor = s.depth || 0.5;
                                // Use sqrt for diminishing returns, depth multiplier for parallax
                                const lengthFactor = Math.sqrt(sliderValue) * 14 * depthFactor;
                                const streakLength = 5 + lengthFactor * (2 + perspFactor * 12);
                                // Cap max streak length - varies by depth
                                const cappedStreak = Math.min(streakLength, 1680 * depthFactor);

                                // Direction OUTWARD from center (streak trails BEHIND moving star)
                                const dirOutX = dx / distFromCenter;
                                const dirOutY = dy / distFromCenter;

                                // HEAD is at current position (leading edge, flying outward)
                                // TAIL is behind (toward center, where star came from)
                                const headX = sx;
                                const headY = sy;
                                const tailX = sx - dirOutX * cappedStreak;
                                const tailY = sy - dirOutY * cappedStreak;

                                // Alpha: cap to prevent white-out, scale with intensity
                                // Lower alpha at high speeds = more visible individual rays
                                const baseAlpha = s.alpha || 0.2;
                                const intensityBoost = Math.min(0.4, warpIntensity * 0.15);
                                const alpha = Math.min(0.65, baseAlpha + intensityBoost);
                                ctx.globalAlpha = alpha;

                                if (cappedStreak > 2) {
                                    try {
                                        // === GRADIENT: Use star's actual color throughout ===
                                        const grad = ctx.createLinearGradient(tailX, tailY, headX, headY);
                                        grad.addColorStop(0, 'transparent'); // Tail fades
                                        grad.addColorStop(0.3, `rgba(${r}, ${g}, ${b}, 0.2)`);
                                        grad.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.6)`);
                                        // Bright head - boost luminosity but keep the hue
                                        const brightR = Math.min(255, r + 40);
                                        const brightG = Math.min(255, g + 40);
                                        const brightB = Math.min(255, b + 40);
                                        grad.addColorStop(1, `rgba(${brightR}, ${brightG}, ${brightB}, 1)`);

                                        // Main streak - line width matches star diameter (size * 2)
                                        ctx.strokeStyle = grad;
                                        // Base width should be diameter (size * 2). add intensity.
                                        const lineW = Math.max(0.6, Math.min(6, size * 2.0 + warpIntensity * 0.06));
                                        ctx.lineWidth = lineW;
                                        ctx.lineCap = 'round';
                                        ctx.beginPath();
                                        ctx.moveTo(tailX, tailY);
                                        ctx.lineTo(headX, headY);
                                        ctx.stroke();

                                        // Bright core at head - USE STAR COLOR, not white!
                                        if (cappedStreak > 15) {
                                            // Brighter version of star's color for the core
                                            const coreR = Math.min(255, r + 80);
                                            const coreG = Math.min(255, g + 80);
                                            const coreB = Math.min(255, b + 80);
                                            ctx.strokeStyle = `rgba(${coreR}, ${coreG}, ${coreB}, 0.85)`;
                                            ctx.lineWidth = Math.max(0.4, size * 0.3);
                                            ctx.globalAlpha = alpha * 0.9;
                                            ctx.beginPath();
                                            const coreLen = Math.min(cappedStreak * 0.12, 30);
                                            const coreX = headX - dirOutX * coreLen;
                                            const coreY = headY - dirOutY * coreLen;
                                            ctx.moveTo(coreX, coreY);
                                            ctx.lineTo(headX, headY);
                                            ctx.stroke();
                                        }
                                    } catch (e) {
                                        ctx.strokeStyle = starColor;
                                        ctx.lineWidth = size;
                                        ctx.beginPath();
                                        ctx.moveTo(tailX, tailY);
                                        ctx.lineTo(headX, headY);
                                        ctx.stroke();
                                    }
                                }

                                // Bright head point - smaller at high speeds - USE STAR COLOR
                                ctx.globalAlpha = Math.min(0.9, alpha + 0.2);
                                // Use bright version of star's color instead of white
                                const headR = Math.min(255, r + 100);
                                const headG = Math.min(255, g + 100);
                                const headB = Math.min(255, b + 100);
                                ctx.fillStyle = `rgb(${headR}, ${headG}, ${headB})`;
                                ctx.beginPath();
                                const headSize = Math.max(0.5, Math.min(1.2, size * 0.4));
                                ctx.arc(headX, headY, headSize, 0, Math.PI * 2);
                                ctx.fill();


                            } else if (this.bgDriftMode && !this.bgWarpMode) {
                                // ====== SIMPLE DRIFT - Stars just float gently ======
                                ctx.globalAlpha = s.alpha || 0.5;
                                ctx.fillStyle = starColor;
                                ctx.beginPath();
                                ctx.arc(sx, sy, size, 0, Math.PI * 2);
                                ctx.fill();

                            } else {
                                // === NORMAL MODE: Simple colored dot ===
                                ctx.globalAlpha = s.alpha || 0.5;
                                ctx.fillStyle = starColor;
                                ctx.beginPath();
                                ctx.arc(sx, sy, size, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        });
                    } catch (renderError) {
                        console.error('[BG Error] Star rendering failed:', renderError);
                    }

                    // ====== SHOOTING STARS (Normal mode only) ======
                    if (!this.bgWarpMode && !this.bgDriftMode) {
                        const now = performance.now();

                        // Spawn new shooting star every 2-6 seconds
                        if (now - this.lastShootingStarTime > 2000 + Math.random() * 4000) {
                            this.lastShootingStarTime = now;
                            const colors = this.starColors || ['#ffffff', '#aaddff', '#ffddaa'];

                            // Start from random edge
                            const edge = Math.floor(Math.random() * 4);
                            let startX, startY, angle;

                            if (edge === 0) { // Top
                                startX = Math.random() * canvas.width;
                                startY = -10;
                                angle = Math.PI * 0.25 + Math.random() * Math.PI * 0.5;
                            } else if (edge === 1) { // Right
                                startX = canvas.width + 10;
                                startY = Math.random() * canvas.height;
                                angle = Math.PI * 0.75 + Math.random() * Math.PI * 0.5;
                            } else if (edge === 2) { // Bottom
                                startX = Math.random() * canvas.width;
                                startY = canvas.height + 10;
                                angle = -Math.PI * 0.25 - Math.random() * Math.PI * 0.5;
                            } else { // Left
                                startX = -10;
                                startY = Math.random() * canvas.height;
                                angle = -Math.PI * 0.25 + Math.random() * Math.PI * 0.5;
                            }

                            this.shootingStarsActive.push({
                                x: startX,
                                y: startY,
                                vx: Math.cos(angle) * (8 + Math.random() * 12),
                                vy: Math.sin(angle) * (8 + Math.random() * 12),
                                size: 1.5 + Math.random() * 1.5,
                                tailLength: 30 + Math.random() * 50,
                                color: colors[Math.floor(Math.random() * colors.length)],
                                life: 1.0
                            });
                        }

                        // Update and draw shooting stars
                        this.shootingStarsActive = this.shootingStarsActive.filter(star => {
                            star.x += star.vx;
                            star.y += star.vy;
                            star.life -= 0.01;

                            if (star.life <= 0 || star.x < -100 || star.x > canvas.width + 100 ||
                                star.y < -100 || star.y > canvas.height + 100) {
                                return false; // Remove
                            }

                            // Draw shooting star with tail
                            const speed = Math.sqrt(star.vx * star.vx + star.vy * star.vy);
                            const dirX = -star.vx / speed;
                            const dirY = -star.vy / speed;
                            const tailX = star.x + dirX * star.tailLength;
                            const tailY = star.y + dirY * star.tailLength;

                            ctx.globalAlpha = star.life * 0.8;
                            ctx.strokeStyle = star.color;
                            ctx.lineWidth = star.size;
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            ctx.moveTo(tailX, tailY);
                            ctx.lineTo(star.x, star.y);
                            ctx.stroke();

                            // Bright head
                            ctx.fillStyle = '#ffffff';
                            ctx.beginPath();
                            ctx.arc(star.x, star.y, star.size * 1.2, 0, Math.PI * 2);
                            ctx.fill();

                            return true; // Keep
                        });
                    }

                    ctx.globalAlpha = 1.0;

                    // Cyber Matrix Rain (Screen Space)
                    // Only draw if cyber style is active
                    if (this.activeStyles.has('cyber') && this.matrixStreams) {
                        ctx.textAlign = 'center';
                        const speedMult = this.matrixSpeedMultiplier || 1.0;
                        const lengthMult = this.matrixLengthMultiplier || 1.0;

                        // Apply angle transform
                        if (this.matrixAngle !== 0) {
                            ctx.save();
                            ctx.translate(canvas.width / 2, canvas.height / 2);
                            ctx.rotate((this.matrixAngle * Math.PI) / 180);
                            ctx.translate(-canvas.width / 2, -canvas.height / 2);
                        }

                        // Base visible length: 20 chars at 1x, slider scales from ~4 to ~60 chars
                        const baseVisibleLength = 20;
                        const rainbowHueOffset = Date.now() * 0.1; // Animate rainbow hue

                        this.matrixStreams.forEach((stream, streamIndex) => {
                            // Update with real-time speed multiplier
                            stream.y += stream.baseSpeed * speedMult;

                            // Calculate visible length based on slider (independent of array size)
                            const visibleLength = Math.max(3, Math.floor(baseVisibleLength * lengthMult));

                            if (stream.y - (visibleLength * stream.size) > canvas.height * 1.5) {
                                stream.y = -stream.size * visibleLength; // Reset
                            }

                            // Draw
                            ctx.font = `${stream.size}px monospace, 'Courier New', monospace`;
                            ctx.textBaseline = 'middle';

                            // Only draw visible characters based on length multiplier
                            for (let i = 0; i < visibleLength && i < stream.chars.length; i++) {
                                const char = stream.chars[i];
                                const charY = stream.y - (i * stream.size);
                                if (charY < -stream.size * 2 || charY > canvas.height * 1.5) continue;

                                // Improved visibility: Fade out only near the end of the tail
                                const relativePos = 1 - (i / visibleLength);
                                const alpha = Math.pow(relativePos, 0.5) * stream.opacity;

                                ctx.globalAlpha = alpha;

                                // Rainbow mode: cycle through HSL colors
                                if (this.matrixRainbowMode) {
                                    const hue = (rainbowHueOffset + streamIndex * 15 + i * 5) % 360;
                                    ctx.fillStyle = `hsl(${hue}, 100 %, 60 %)`;
                                } else {
                                    ctx.fillStyle = stream.color;
                                }
                                ctx.shadowBlur = 4;
                                ctx.shadowColor = stream.color;

                                ctx.fillText(char, stream.x, charY);
                            }
                        });

                        // Restore from angle transform
                        if (this.matrixAngle !== 0) {
                            ctx.restore();
                        }

                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1.0;
                    }
                }

                // World Transform
                ctx.translate(canvas.width / 2 + this.camera.x, canvas.height / 2 + this.camera.y);
                ctx.scale(this.camera.zoom, this.camera.zoom);

                // Calculations & Cluster ID Assignment
                const { lines, clusters } = this.refreshClusterAssignments();

                // 0. Draw Background Layers
                // Always draw background stars and nebulae if they exist
                this.drawBackgroundElements();

                // Draw deep space specific elements (galaxies, black holes, planets)
                if (this.activeStyles.has('deep-space')) this.drawDeepSpaceSpecific();

                // 1. Draw Grid Lines (Glow Pass + Core Pass) with 3D rotation
                if (lines.length > 0) {
                    ctx.lineCap = 'round';
                    ctx.shadowBlur = 10;

                    // Rotation center - use cached if available (during star placement)
                    const center = this._cachedRotationCenter || this.getConstellationCenter();
                    const rotCenterX = center.x;
                    const rotCenterY = center.y;
                    const rotCenterZ = center.z || 0;

                    lines.forEach(l => {
                        const alpha = Math.max(0, 1 - (l.dist / this.config.maxConnectDist));
                        const starColor = this.getStarColor(l.s1);
                        const [r, g, b] = this.hexToRgb(starColor);

                        // Apply 3D rotation
                        const s1z = l.s1.z || 0;
                        const s2z = l.s2.z || 0;
                        const p1 = this.rotate3D(l.s1.x, l.s1.y, s1z, rotCenterX, rotCenterY);
                        const p2 = this.rotate3D(l.s2.x, l.s2.y, s2z, rotCenterX, rotCenterY);

                        ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.8)`;
                        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha * 0.3})`;
                        ctx.lineWidth = 3 / this.camera.zoom;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    });
                    ctx.shadowBlur = 0;

                    lines.forEach(l => {
                        const alpha = Math.max(0, 1 - (l.dist / this.config.maxConnectDist));
                        const starColor = this.getStarColor(l.s1);

                        // Apply 3D rotation
                        const s1z = l.s1.z || 0;
                        const s2z = l.s2.z || 0;
                        const p1 = this.rotate3D(l.s1.x, l.s1.y, s1z, rotCenterX, rotCenterY);
                        const p2 = this.rotate3D(l.s2.x, l.s2.y, s2z, rotCenterX, rotCenterY);

                        ctx.strokeStyle = starColor;
                        ctx.globalAlpha = alpha * 0.8;
                        ctx.lineWidth = 1 / this.camera.zoom;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    });
                    ctx.globalAlpha = 1.0;
                }

                // 6. Draw Text Labels
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.font = `600 ${14 / this.camera.zoom}px 'Exo 2'`;

                clusters.forEach(c => {
                    // Only draw names for clusters that meet the minimum size threshold AND have a generated name
                    const name = String(c[0].clusterId);
                    if (c.length < this.config.minGroupSize || name === String(c[0].id)) return;

                    // Centroid Calculation
                    let cx = 0, cy = 0;
                    c.forEach(s => { cx += s.x; cy += s.y; });
                    cx /= c.length; cy /= c.length;

                    const avgColor = this.getStarColor(c[0]);

                    // Draw Text Label
                    ctx.fillStyle = avgColor;
                    ctx.shadowColor = "black";
                    ctx.shadowBlur = 4;
                    ctx.fillText(name, cx, cy + (30 / this.camera.zoom));
                    ctx.shadowBlur = 0;
                });

                // 7. Draw Stars with 3D rotation
                const timeNow = performance.now();
                // Use cached rotation center if available (during star placement), otherwise calculate
                const center = this._cachedRotationCenter || this.getConstellationCenter();
                const rotCenterX = center.x;
                const rotCenterY = center.y;
                // Note: we just pass centerX/Y as pivot, Z pivot is implicitly handled by rotate3D logic relative to 0? 
                // Wait, rotate3D logic (let pz = z) rotates AROUND (centerX, centerY, 0).
                // If the constellation center has Z != 0, we should translate Z too?
                // rotate3D implementation: let px = x - centerX; let py = y - centerY; let pz = z; 
                // So it assumes pivot Z is 0. If center.z is not 0, we should subtract it.
                // But let's stick to previous logical structure where we just updated rotate3D signature.
                // Ideally: let pz = z - (center.z || 0);
                // Let's rely on the definition where we pass Z.

                this.stars.forEach(s => {
                    if (s.flownOut) return; // Skip if flown out during warp

                    ctx.save();

                    // Apply disengage warp values
                    let wScale = 1.0;
                    let wAlpha = 1.0;
                    if (this.warpDisengaging && s.warpScale !== undefined) {
                        wScale = s.warpScale;
                        wAlpha = s.warpAlpha !== undefined ? s.warpAlpha : 1.0;
                    }

                    const isHover = (s === this.hoveredStar);

                    // Apply 3D rotation
                    const sz = s.z || 0;
                    const rotated = this.rotate3D(s.x, s.y, sz, rotCenterX, rotCenterY);
                    const rx = rotated.x;
                    const ry = rotated.y;
                    const rScale = rotated.scale;

                    const twinkle = Math.sin(timeNow * 0.003 + s.phase) * 0.2 + 0.8;
                    const scale = isHover ? 1.5 : 1.0;
                    const radius = this.config.starBaseRad * twinkle * scale * rScale * wScale / this.camera.zoom;
                    const starColor = this.getStarColor(s);
                    const [r, g, b] = this.hexToRgb(starColor);

                    // Apply transparency
                    ctx.globalAlpha = wAlpha;

                    // Draw Glow
                    const glowRad = Math.max(0.1, radius * 6); // Ensure positive radius
                    const grad = ctx.createRadialGradient(rx, ry, 0, rx, ry, glowRad);
                    grad.addColorStop(0, `rgba(255, 255, 255, ${isHover ? 0.9 : 0.6})`);
                    grad.addColorStop(0.2, `rgba(${r}, ${g}, ${b}, 0.3)`);
                    grad.addColorStop(1, "rgba(0,0,0,0)");

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(rx, ry, glowRad, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw Core (Star Shape)
                    ctx.fillStyle = starColor;
                    this.drawStarShape(ctx, rx, ry, radius);

                    ctx.restore();
                });

                // Update HUD
                const statEl = document.getElementById('stats');
                const constellationCount = clusters.filter(c => c.length >= this.config.minGroupSize).length;
                if (statEl) statEl.innerText = `Mode: ${this.mode.charAt(0).toUpperCase() + this.mode.slice(1)} | Stars: ${this.stars.length} | Constellations: ${constellationCount} | Zoom: ${this.camera.zoom.toFixed(2)} x`;

                // Draw player ship if in flight mode
                if (this.flightMode && this.playerShip) {
                    if (this.flightMode && this.playerShip) {
                        // console.log('[Spacecraft Debug] Rendering player ship at', this.playerShip.x, this.playerShip.y);
                        this.renderSpeedLines(ctx);
                        this.renderMinerals(ctx, time);
                        this.renderPlayerShip(ctx, time);
                        this.renderCollectionNotifications(ctx);
                    } else {
                        // console.log('[Spacecraft Debug] NOT rendering - flightMode:', this.flightMode, 'playerShip:', !!this.playerShip);
                    }
                }

                renderSpeedLines(ctx) {
                    this.speedLines.forEach(line => {
                        ctx.save();
                        ctx.translate(line.x, line.y);

                        ctx.globalAlpha = line.life * 0.5;
                        ctx.strokeStyle = '#88ccff';
                        ctx.lineWidth = 2 / this.camera.zoom;

                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-line.vx * 3, -line.vy * 3);
                        ctx.stroke();

                        ctx.globalAlpha = 1;
                        ctx.restore();
                    });
                }

                renderPlayerShip(ctx, time) {
                    const ship = this.playerShip;
                    if (!ship) return;

                    ctx.save();
                    ctx.translate(ship.x, ship.y);

                    // Base rotation (yaw - turning left/right)
                    ctx.rotate(ship.rotation);

                    // 3D roll rotation (barrel roll) - rotate around the forward axis
                    const roll = ship.roll || 0;
                    ctx.rotate(roll);

                    // 3D pitch rotation (up/down tilt) - simulated visually
                    const pitch = ship.pitch || 0;
                    const pitchScale = Math.cos(pitch); // Squash vertically when pitched

                    const size = 40 / this.camera.zoom;
                    const shipType = ship.type || 'interceptor';

                    // Draw ship based on type
                    switch (shipType) {
                        case 'saucer':
                            // Classic flying saucer
                            // Base
                            const shipColor = ship.color || '#ffcc00'; // Default color if not specified
                            ctx.strokeStyle = this.adjustColor(shipColor, -30);
                            ctx.lineWidth = 2 / this.camera.zoom;
                            ctx.fillStyle = shipColor;
                            ctx.beginPath();
                            ctx.ellipse(0, 0, size, size * 0.4, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                            // Dome
                            ctx.fillStyle = this.adjustColor(shipColor, 50); // Lighter for dome
                            ctx.beginPath();
                            ctx.ellipse(0, -size * 0.15, size * 0.5, size * 0.35, 0, Math.PI, 0);
                            ctx.fill();
                            // Lights around edge
                            for (let i = 0; i < 6; i++) {
                                const angle = (i / 6) * Math.PI * 2 + time * 0.005;
                                ctx.fillStyle = i % 2 === 0 ? '#ff0000' : '#00ff00';
                                ctx.beginPath();
                                ctx.arc(Math.cos(angle) * size * 0.8, Math.sin(angle) * size * 0.3, size * 0.08, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            break;

                        case 'hauler':
                            // Heavy cargo ship - rectangular with containers
                            ctx.rotate(roll); // Apply roll rotation
                            ctx.fillStyle = this.adjustColor(shipColor, -50); // Darker body
                            ctx.strokeStyle = shipColor;
                            ctx.lineWidth = 2 / this.camera.zoom;
                            ctx.fillRect(-size * 0.8, -size * 0.5, size * 1.6, size);
                            ctx.strokeRect(-size * 0.8, -size * 0.5, size * 1.6, size);
                            // Cargo containers
                            ctx.fillStyle = '#884400';
                            ctx.fillRect(-size * 0.5, -size * 0.35, size * 0.4, size * 0.7);
                            ctx.fillRect(0, -size * 0.35, size * 0.4, size * 0.7);
                            // Cockpit
                            ctx.fillStyle = this.adjustColor(shipColor, 30);
                            ctx.beginPath();
                            ctx.moveTo(size * 0.8, 0);
                            ctx.lineTo(size * 0.5, -size * 0.3);
                            ctx.lineTo(size * 0.5, size * 0.3);
                            ctx.closePath();
                            ctx.fill();
                            // Engines
                            ctx.fillStyle = '#ff4400';
                            ctx.fillRect(-size * 0.9, -size * 0.4, size * 0.15, size * 0.25);
                            ctx.fillRect(-size * 0.9, size * 0.15, size * 0.15, size * 0.25);
                            break;

                        case 'orion':
                            // Check for Custom Constellation Structure
                            if (this.playerShip.customStructure && this.playerShip.customStructure.stars) {
                                const struct = this.playerShip.customStructure;
                                const stars = struct.stars;
                                const lines = struct.lines;

                                // 3D Rotation Transform
                                // Apply Roll (Z-axis) - was missing!
                                ctx.rotate(roll);

                                // Pitch is handled by projecting Y/Z
                                const pitch = this.playerShip.pitch || 0;
                                const cosX = Math.cos(pitch);
                                const sinX = Math.sin(pitch);

                                // Project Points
                                const projected = stars.map(s => {
                                    // Rotate around X (Pitch)
                                    let y = s.y * cosX - s.z * sinX;
                                    let z = s.y * sinX + s.z * cosX;
                                    let x = s.x;

                                    // Simple perspective projection
                                    const fov = 300;
                                    const scale = fov / (fov + z); // Perspective scale

                                    return {
                                        x: x * scale,
                                        y: y * scale,
                                        visible: z < 200 // Clip behind
                                    };
                                });

                                // Draw Lines
                                ctx.beginPath();
                                ctx.strokeStyle = this.adjustColor(shipColor, 20);
                                ctx.lineWidth = 2 / this.camera.zoom;
                                if (lines) {
                                    lines.forEach(l => {
                                        const p1 = projected[l.fromIndex];
                                        const p2 = projected[l.toIndex];
                                        if (p1 && p2 && p1.visible && p2.visible) {
                                            ctx.moveTo(p1.x, p1.y);
                                            ctx.lineTo(p2.x, p2.y);
                                        }
                                    });
                                }
                                ctx.stroke();

                                // Draw Stars
                                projected.forEach((p, i) => {
                                    if (!p.visible) return;
                                    ctx.fillStyle = stars[i].color || shipColor;
                                    ctx.beginPath();
                                    ctx.arc(p.x, p.y, Math.max(1, size * 0.15), 0, Math.PI * 2);
                                    ctx.fill();
                                });

                                // Removed Core Glow to avoid confusion with "star"

                            } else {
                                // Default Fallback (Star Shape)
                                ctx.rotate(roll);
                                ctx.fillStyle = shipColor;
                                ctx.strokeStyle = '#aaddff';
                                ctx.lineWidth = 2 / this.camera.zoom;
                                // Main star shape
                                ctx.beginPath();
                                for (let i = 0; i < 5; i++) {
                                    const outerAngle = (i * Math.PI * 2 / 5) - Math.PI / 2;
                                    const innerAngle = outerAngle + Math.PI / 5;
                                    const outerX = Math.cos(outerAngle) * size;
                                    const outerY = Math.sin(outerAngle) * size;
                                    const innerX = Math.cos(innerAngle) * size * 0.4;
                                    const innerY = Math.sin(innerAngle) * size * 0.4;
                                    if (i === 0) ctx.moveTo(outerX, outerY);
                                    else ctx.lineTo(outerX, outerY);
                                    ctx.lineTo(innerX, innerY);
                                }
                                ctx.closePath();
                                ctx.fill();
                                ctx.stroke();
                                // Glowing core
                                ctx.fillStyle = '#00ccff';
                                ctx.beginPath();
                                ctx.arc(0, 0, size * 0.25, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            break;

                        case 'draco':
                            // Dragon constellation - serpentine shape
                            ctx.rotate(roll); // Apply roll rotation
                            ctx.fillStyle = '#22aa44';
                            ctx.strokeStyle = '#00ff66';
                            ctx.lineWidth = 3 / this.camera.zoom;
                            // Dragon head
                            ctx.beginPath();
                            ctx.moveTo(size, 0);
                            ctx.lineTo(size * 0.7, -size * 0.4);
                            ctx.lineTo(size * 0.5, -size * 0.2);
                            ctx.lineTo(0, -size * 0.5);
                            ctx.lineTo(-size * 0.5, -size * 0.3);
                            ctx.lineTo(-size, 0);
                            ctx.lineTo(-size * 0.5, size * 0.3);
                            ctx.lineTo(0, size * 0.5);
                            ctx.lineTo(size * 0.5, size * 0.2);
                            ctx.lineTo(size * 0.7, size * 0.4);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            // Dragon eye
                            ctx.fillStyle = '#ff0000';
                            ctx.beginPath();
                            ctx.arc(size * 0.6, -size * 0.1, size * 0.1, 0, Math.PI * 2);
                            ctx.fill();
                            // Fire breath
                            ctx.fillStyle = `rgba(255, ${100 + Math.sin(time * 0.01) * 50}, 0, 0.7)`;
                            ctx.beginPath();
                            ctx.moveTo(size, 0);
                            ctx.lineTo(size * 1.5, -size * 0.2);
                            ctx.lineTo(size * 1.3, 0);
                            // Dragon-like jagged ship
                            ctx.rotate(roll); // Apply roll rotation
                            ctx.fillStyle = this.adjustColor(shipColor, -60);
                            ctx.strokeStyle = shipColor;
                            ctx.lineWidth = 2 / this.camera.zoom;
                            ctx.beginPath();
                            ctx.moveTo(size, 0);
                            ctx.lineTo(-size * 0.5, size * 0.5);
                            ctx.lineTo(-size * 0.2, 0);
                            ctx.lineTo(-size * 0.5, -size * 0.5);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            // Wings
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(-size * 0.5, size);
                            ctx.lineTo(size * 0.2, 0);
                            ctx.lineTo(-size * 0.5, -size);
                            ctx.closePath();
                            ctx.fillStyle = this.adjustColor(shipColor, -20);
                            ctx.fill();
                            ctx.stroke();
                            break;

                        case 'phoenix':
                            // Bird-like ship
                            ctx.rotate(roll); // Apply roll rotation
                            ctx.fillStyle = shipColor;
                            ctx.strokeStyle = this.adjustColor(shipColor, 60);
                            ctx.lineWidth = 2 / this.camera.zoom;
                            // Body
                            ctx.beginPath();
                            ctx.moveTo(size * 0.8, 0);
                            ctx.lineTo(-size * 0.6, 0);
                            ctx.stroke();
                            // Wings
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.quadraticCurveTo(size * 0.5, size * 0.5, -size * 0.2, size * 0.8);
                            ctx.moveTo(0, 0);
                            ctx.quadraticCurveTo(size * 0.5, -size * 0.5, -size * 0.2, -size * 0.8);
                            ctx.stroke();
                            break;

                        case 'harvester':
                            // STELLAR HARVESTER - Tie-fighter inspired design
                            // Rotate 90 degrees to face forward, then apply roll for barrel roll effect
                            ctx.rotate(Math.PI / 2 + roll);
                            ctx.scale(1, pitchScale || 1); // Apply pitch scaling
                            // Left hexagonal panel
                            ctx.fillStyle = '#00ddff';
                            ctx.strokeStyle = '#0088ff';
                            ctx.lineWidth = 2 / this.camera.zoom;
                            ctx.beginPath();
                            for (let i = 0; i < 6; i++) {
                                const angle = (Math.PI / 3) * i;
                                const x = -size * 1.2 + Math.cos(angle) * size * 0.4;
                                const y = Math.sin(angle) * size * 0.6;
                                if (i === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();

                            // Right hexagonal panel
                            ctx.beginPath();
                            for (let i = 0; i < 6; i++) {
                                const angle = (Math.PI / 3) * i;
                                const x = size * 1.2 + Math.cos(angle) * size * 0.4;
                                const y = Math.sin(angle) * size * 0.6;
                                if (i === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();

                            // Central cockpit pod
                            ctx.fillStyle = '#888888';
                            ctx.strokeStyle = '#00ffff';
                            ctx.lineWidth = 2 / this.camera.zoom;
                            ctx.beginPath();
                            ctx.ellipse(0, 0, size * 0.3, size * 0.25, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();

                            // Cockpit window
                            ctx.fillStyle = '#00ffff';
                            ctx.beginPath();
                            ctx.arc(0, 0, size * 0.12, 0, Math.PI * 2);
                            ctx.fill();

                            // Connecting struts
                            ctx.strokeStyle = '#666666';
                            ctx.lineWidth = 3 / this.camera.zoom;
                            ctx.beginPath();
                            ctx.moveTo(-size * 0.3, 0);
                            ctx.lineTo(-size * 0.8, 0);
                            ctx.moveTo(size * 0.3, 0);
                            ctx.lineTo(size * 0.8, 0);
                            ctx.stroke();

                            // Engine glow on panels
                            const pulseGlow = 0.3 + Math.sin(time * 0.005) * 0.2;
                            ctx.fillStyle = `rgba(0, 255, 100, ${pulseGlow})`;
                            ctx.beginPath();
                            ctx.arc(-size * 1.2, 0, size * 0.15, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.arc(size * 1.2, 0, size * 0.15, 0, Math.PI * 2);
                            ctx.fill();
                            break;

                        case 'interceptor':
                        default:
                            // STELLAR HARVESTER - Advanced gem collection vessel
                            ctx.rotate(roll); // Apply roll rotation
                            ctx.fillStyle = '#00ffff';
                            ctx.strokeStyle = '#0088ff';
                            ctx.lineWidth = 3 / this.camera.zoom;
                            ctx.beginPath();
                            ctx.moveTo(size, 0);
                            ctx.lineTo(-size * 0.6, -size * 0.6);
                            ctx.lineTo(-size * 0.4, 0);
                            ctx.lineTo(-size * 0.6, size * 0.6);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            // Engine glow
                            ctx.fillStyle = '#ff6600';
                            ctx.beginPath();
                            ctx.arc(-size * 0.5, 0, size * 0.2, 0, Math.PI * 2);
                            ctx.fill();
                            break;
                    }

                    ctx.restore();
                }

                renderMinerals(ctx, time) {
                    this.minerals.forEach(mineral => {
                        ctx.save();
                        // Use world coordinates (ctx already transformed)
                        ctx.translate(mineral.x, mineral.y);

                        // Safeguard against invalid zoom
                        const safeZoom = Math.max(0.01, this.camera.zoom || 1);

                        // Pulsing glow animation
                        const pulse = Math.sin(time * 0.003 + mineral.phase) * 0.3 + 0.7;
                        const size = mineral.size * pulse / safeZoom;

                        // Ensure size is valid
                        if (!isFinite(size) || size <= 0) {
                            ctx.restore();
                            return;
                        }

                        // Glow effect
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 2);
                        gradient.addColorStop(0, mineral.color);
                        gradient.addColorStop(0.5, mineral.color + '88');
                        gradient.addColorStop(1, mineral.color + '00');

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, size * 2, 0, Math.PI * 2);
                        ctx.fill();

                        // Core
                        ctx.fillStyle = mineral.color;
                        ctx.beginPath();
                        ctx.arc(0, 0, size, 0, Math.PI * 2);
                        ctx.fill();

                        // Bright center
                        ctx.fillStyle = '#ffffff';
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;

                        ctx.restore();
                    });
                }

                renderCollectionNotifications(ctx) {
                    const canvas = this.canvas;
                    const now = Date.now();

                    this.collectionNotifications.forEach(notification => {
                        const age = now - notification.time;
                        const opacity = Math.max(0, 1 - age / 2000);
                        const yOffset = age * 0.05;

                        ctx.save();
                        ctx.setTransform(1, 0, 0, 1, 0, 0);

                        ctx.globalAlpha = opacity;
                        ctx.font = 'bold 20px Arial';
                        ctx.fillStyle = notification.color;
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 3;
                        ctx.textAlign = 'center';

                        const x = canvas.width / 2;
                        const y = canvas.height / 2 - 100 - yOffset;

                        ctx.strokeText(notification.text, x, y);
                        ctx.fillText(notification.text, x, y);
                        ctx.globalAlpha = 1;

                        ctx.restore();
                    });
                }

                drawBackgroundElements() {
                    if (!this.config.showBackground) return;

                    const ctx = this.ctx;

                    // 1. Background Stars (from all active styles)
                    if (this.backgroundStars && this.backgroundStars.length > 0) {
                        this.backgroundStars.forEach(s => {
                            ctx.fillStyle = s.color || "white";
                            ctx.globalAlpha = s.alpha;
                            ctx.beginPath();
                            ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                            ctx.fill();
                        });
                        ctx.globalAlpha = 1;
                    }

                    // 2. Nebulae (from nebula + deep-space styles)
                    if (this.nebulae && this.nebulae.length > 0) {
                        ctx.globalCompositeOperation = 'screen';
                        this.nebulae.forEach(n => {
                            if (n.flownOut) return; // Skip if flown out during warp

                            // During disengage: use scale and alpha from flyObject
                            let scale = 1.0;
                            let alpha = 1.0;
                            if (this.warpDisengaging && n.warpScale !== undefined) {
                                scale = n.warpScale || 0.01;
                                alpha = n.warpAlpha || 0;
                            }

                            const scaledSize = Math.max(0.1, n.size * scale);
                            const scaledAlpha = n.alpha * alpha;

                            const grad = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, scaledSize);
                            grad.addColorStop(0, n.color);
                            grad.addColorStop(1, 'transparent');

                            ctx.globalAlpha = scaledAlpha;
                            ctx.fillStyle = grad;
                            ctx.beginPath();
                            ctx.arc(n.x, n.y, scaledSize, 0, Math.PI * 2);
                            ctx.fill();
                        });
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.globalAlpha = 1;
                    }

                    // 2.5 Moving Cosmic Stars (shooting stars with tails)
                    if (this.activeStyles.has('deep-space') && this.shootingStars && this.shootingStars.length > 0) {
                        this.shootingStars.forEach(s => {
                            ctx.save();

                            // Draw tail (gradient line in opposite direction of movement)
                            const tailX = s.x - s.vx * s.tailLength;
                            const tailY = s.y - s.vy * s.tailLength;

                            const tailGrad = ctx.createLinearGradient(tailX, tailY, s.x, s.y);
                            tailGrad.addColorStop(0, 'transparent');
                            tailGrad.addColorStop(0.7, s.color + '40');
                            tailGrad.addColorStop(1, s.color);

                            ctx.strokeStyle = tailGrad;
                            ctx.lineWidth = s.size * 0.8;
                            ctx.lineCap = 'round';
                            ctx.globalAlpha = s.alpha;

                            ctx.beginPath();
                            ctx.moveTo(tailX, tailY);
                            ctx.lineTo(s.x, s.y);
                            ctx.stroke();

                            // Draw star head (bright point)
                            ctx.fillStyle = s.color;
                            ctx.globalAlpha = s.alpha + 0.3;
                            ctx.beginPath();
                            ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.restore();
                        });
                        ctx.globalAlpha = 1;
                    }

                    // 3. Spacecraft (from alien style) - ENHANCED RENDERING
                    if (this.activeStyles.has('alien') && this.spacecraft && this.spacecraft.length > 0) {
                        const time = performance.now() * 0.001;
                        this.spacecraft.forEach(s => {
                            if (s.flownOut) return; // Skip if flown out during warp
                            ctx.save();

                            // Position comes from flyObject during disengage
                            ctx.translate(s.x, s.y);

                            // During disengage: use scale and alpha from flyObject
                            if (this.warpDisengaging && s.warpScale !== undefined) {
                                ctx.scale(s.warpScale, s.warpScale);
                                ctx.globalAlpha = s.warpAlpha || 0;
                            }

                            // Update rotation for saucers
                            if (s.rotationSpeed) s.rotation += s.rotationSpeed;

                            const size = s.size;
                            const zoom = this.camera.zoom;
                            const angle = Math.atan2(s.vy, s.vx);

                            // Shield effect (drawn first, behind ship)
                            if (s.hasShield) {
                                const shieldPulse = Math.sin(time * 2 + s.shieldPhase) * 0.3 + 0.4;
                                ctx.globalAlpha = shieldPulse * 0.4;
                                const shieldGrad = ctx.createRadialGradient(0, 0, size * 0.5, 0, 0, size * 1.5);
                                shieldGrad.addColorStop(0, 'transparent');
                                shieldGrad.addColorStop(0.7, s.shieldColor || 'rgba(100,200,255,0.3)');
                                shieldGrad.addColorStop(1, 'transparent');
                                ctx.fillStyle = shieldGrad;
                                ctx.beginPath();
                                ctx.arc(0, 0, size * 1.5, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.globalAlpha = 1;
                            }

                            // Tractor beam (for saucers)
                            if (s.beamActive && s.shipClass === 'saucer') {
                                const beamPulse = Math.sin(time * 5) * 0.2 + 0.6;
                                ctx.globalAlpha = beamPulse * 0.5;
                                const beamGrad = ctx.createLinearGradient(0, size * 0.2, 0, size * 3);
                                beamGrad.addColorStop(0, s.beamColor || '#88ff88');
                                beamGrad.addColorStop(1, 'transparent');
                                ctx.fillStyle = beamGrad;
                                ctx.beginPath();
                                ctx.moveTo(-size * 0.3, size * 0.2);
                                ctx.lineTo(-size * 0.8, size * 3);
                                ctx.lineTo(size * 0.8, size * 3);
                                ctx.lineTo(size * 0.3, size * 0.2);
                                ctx.closePath();
                                ctx.fill();
                                ctx.globalAlpha = 1;
                            }

                            // Rotate for directional ships (not saucers)
                            if (s.shipClass !== 'saucer') {
                                ctx.rotate(angle);
                            }

                            // Engine trails (for non-saucers)
                            if (s.shipClass !== 'saucer' && s.shipClass !== 'probe') {
                                ctx.globalAlpha = 0.7;
                                const trailLength = size * 2;
                                const engineSpacing = size * 0.25;
                                const engineCount = s.engineCount || 2;

                                for (let i = 0; i < engineCount; i++) {
                                    const offsetY = (i - (engineCount - 1) / 2) * engineSpacing;
                                    const flicker = 0.7 + Math.sin(time * 15 + s.detailSeed + i) * 0.3;
                                    const trailGrad = ctx.createLinearGradient(-size * 0.7, offsetY, -size * 0.7 - trailLength * flicker, offsetY);
                                    trailGrad.addColorStop(0, s.engineGlow || '#ffffff');
                                    trailGrad.addColorStop(0.15, s.engineColor || '#00aaff');
                                    trailGrad.addColorStop(1, 'transparent');

                                    ctx.fillStyle = trailGrad;
                                    ctx.beginPath();
                                    ctx.moveTo(-size * 0.65, offsetY - 4);
                                    ctx.quadraticCurveTo(-size * 0.7 - trailLength * 0.5 * flicker, offsetY, -size * 0.7 - trailLength * flicker, offsetY);
                                    ctx.quadraticCurveTo(-size * 0.7 - trailLength * 0.5 * flicker, offsetY, -size * 0.65, offsetY + 4);
                                    ctx.closePath();
                                    ctx.fill();
                                }
                                ctx.globalAlpha = 1;
                            }

                            // Hull gradient
                            const hullGrad = ctx.createLinearGradient(0, -size * 0.5, 0, size * 0.5);
                            hullGrad.addColorStop(0, s.hullHighlight || '#ccc');
                            hullGrad.addColorStop(0.3, s.hullColor || '#888');
                            hullGrad.addColorStop(1, s.hullShadow || '#333');
                            ctx.fillStyle = hullGrad;
                            ctx.strokeStyle = s.hullHighlight || '#ddd';
                            ctx.lineWidth = 1.5 / zoom;

                            // === SHIP RENDERING: 13 Star Wars-Quality Spacecraft ===
                            if (s.shipClass === 'saucer') {
                                ctx.beginPath();
                                ctx.ellipse(0, 0, size, size * 0.25, 0, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.stroke();
                                const domeGrad = ctx.createRadialGradient(-size * 0.1, -size * 0.15, 0, 0, -size * 0.05, size * 0.4);
                                domeGrad.addColorStop(0, '#ffffff');
                                domeGrad.addColorStop(0.3, s.domeColor || '#88ffff');
                                domeGrad.addColorStop(1, 'rgba(0,50,50,0.8)');
                                ctx.fillStyle = domeGrad;
                                ctx.beginPath();
                                ctx.ellipse(0, -size * 0.08, size * 0.35, size * 0.25, 0, Math.PI, 0);
                                ctx.fill();
                            } else if (s.shipClass === 'star-dreadnought') {
                                ctx.beginPath();
                                ctx.moveTo(size * 1.2, 0);
                                for (let i = 0; i < 6; i++) {
                                    const angle = (i / 6) * Math.PI * 2;
                                    ctx.lineTo(Math.cos(angle) * size * 0.8, Math.sin(angle) * size * 0.8);
                                }
                                ctx.closePath();
                                ctx.fill();
                                ctx.stroke();
                            } else if (s.shipClass === 'quantum-scout') {
                                for (let i = 0; i < 3; i++) {
                                    ctx.save();
                                    ctx.rotate(time * (2 + i) + i);
                                    ctx.strokeStyle = '#00aaff';
                                    ctx.lineWidth = 2;
                                    ctx.beginPath();
                                    ctx.ellipse(0, 0, size * (0.6 + i * 0.3), size * 0.2, 0, 0, Math.PI * 2);
                                    ctx.stroke();
                                    ctx.restore();
                                }
                            } else if (s.shipClass === 'void-fighter') {
                                ctx.beginPath();
                                ctx.moveTo(size * 0.9, 0);
                                ctx.lineTo(size * 0.2, -size * 0.5);
                                ctx.lineTo(-size * 0.6, -size * 0.3);
                                ctx.lineTo(-size * 0.6, size * 0.3);
                                ctx.lineTo(size * 0.2, size * 0.5);
                                ctx.closePath();
                                ctx.fill();
                                ctx.stroke();
                            } else if (s.shipClass === 'nebula-cruiser') {
                                // Concorde-style supersonic jet
                                const hullGrad = ctx.createLinearGradient(-size, 0, size, 0);
                                hullGrad.addColorStop(0, '#606080');
                                hullGrad.addColorStop(0.5, '#8080a0');
                                hullGrad.addColorStop(1, '#505070');
                                ctx.fillStyle = hullGrad;
                                // Sleek fuselage with pointed nose
                                ctx.beginPath();
                                ctx.moveTo(size * 1.2, 0);
                                ctx.lineTo(size * 0.7, -size * 0.08);
                                ctx.lineTo(-size * 0.5, -size * 0.12);
                                ctx.lineTo(-size * 0.8, 0);
                                ctx.lineTo(-size * 0.5, size * 0.12);
                                ctx.lineTo(size * 0.7, size * 0.08);
                                ctx.closePath();
                                ctx.fill();
                                ctx.stroke();
                                // Delta wings
                                ctx.fillStyle = '#7070a0';
                                ctx.beginPath();
                                ctx.moveTo(size * 0.2, 0);
                                ctx.lineTo(-size * 0.3, -size * 0.6);
                                ctx.lineTo(-size * 0.6, -size * 0.4);
                                ctx.closePath();
                                ctx.fill();
                                ctx.beginPath();
                                ctx.moveTo(size * 0.2, 0);
                                ctx.lineTo(-size * 0.3, size * 0.6);
                                ctx.lineTo(-size * 0.6, size * 0.4);
                                ctx.closePath();
                                ctx.fill();
                            } else if (s.shipClass === 'bio-corvette') {
                                const bioGrad = ctx.createLinearGradient(-size, 0, size, 0);
                                bioGrad.addColorStop(0, '#4a0066');
                                bioGrad.addColorStop(0.5, '#9900cc');
                                bioGrad.addColorStop(1, '#660099');
                                ctx.fillStyle = bioGrad;
                                ctx.beginPath();
                                ctx.moveTo(size * 0.8, 0);
                                ctx.bezierCurveTo(size * 0.6, -size * 0.4, size * 0.2, -size * 0.5, -size * 0.3, -size * 0.3);
                                ctx.bezierCurveTo(-size * 0.7, 0, -size * 0.3, size * 0.3, size * 0.2, size * 0.5);
                                ctx.bezierCurveTo(size * 0.6, size * 0.4, size * 0.8, 0, size * 0.8, 0);
                                ctx.fill();
                            } else if (s.shipClass === 'warp-strider') {
                                const hullGrad = ctx.createLinearGradient(-size, 0, size, 0);
                                hullGrad.addColorStop(0, '#606060');
                                hullGrad.addColorStop(0.5, '#a0a0a0');
                                hullGrad.addColorStop(1, '#505050');
                                ctx.fillStyle = hullGrad;
                                ctx.beginPath();
                                ctx.moveTo(size * 0.8, 0);
                                ctx.lineTo(size * 0.3, -size * 0.15);
                                ctx.lineTo(-size * 0.6, -size * 0.15);
                                ctx.lineTo(-size * 0.8, 0);
                                ctx.lineTo(-size * 0.6, size * 0.15);
                                ctx.lineTo(size * 0.3, size * 0.15);
                                ctx.closePath();
                                ctx.fill();
                                ctx.fillStyle = '#707070';
                                ctx.fillRect(-size * 0.7, -size * 0.5, size * 0.4, size * 0.08);
                                ctx.fillRect(-size * 0.7, size * 0.42, size * 0.4, size * 0.08);
                            } else if (s.shipClass === 'prism-destroyer') {
                                const hullGrad = ctx.createLinearGradient(-size, -size, size, size);
                                hullGrad.addColorStop(0, '#c0c0c0');
                                hullGrad.addColorStop(0.5, '#e8e8e8');
                                hullGrad.addColorStop(1, '#707070');
                                ctx.fillStyle = hullGrad;
                                ctx.beginPath();
                                ctx.moveTo(size, 0);
                                ctx.lineTo(size * 0.3, -size * 0.6);
                                ctx.lineTo(-size * 0.5, -size * 0.5);
                                ctx.lineTo(-size * 0.8, 0);
                                ctx.lineTo(-size * 0.5, size * 0.5);
                                ctx.lineTo(size * 0.3, size * 0.6);
                                ctx.closePath();
                                ctx.fill();
                                ctx.stroke();
                            } else if (s.shipClass === 'stellar-barge') {
                                const hullGrad = ctx.createLinearGradient(-size, 0, size, 0);
                                hullGrad.addColorStop(0, '#4a3820');
                                hullGrad.addColorStop(0.5, '#8B6F47');
                                hullGrad.addColorStop(1, '#3a2810');
                                ctx.fillStyle = hullGrad;
                                ctx.fillRect(-size * 0.7, -size * 0.35, size * 1.3, size * 0.7);
                                ctx.fillStyle = '#5a4830';
                                ctx.beginPath();
                                ctx.moveTo(size * 0.7, -size * 0.25);
                                ctx.lineTo(size, 0);
                                ctx.lineTo(size * 0.7, size * 0.25);
                                ctx.closePath();
                                ctx.fill();
                            } else if (s.shipClass === 'cyber-sentry') {
                                const eyeGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.4);
                                eyeGrad.addColorStop(0, '#ff0000');
                                eyeGrad.addColorStop(0.5, '#880000');
                                eyeGrad.addColorStop(1, '#220000');
                                ctx.fillStyle = eyeGrad;
                                ctx.beginPath();
                                ctx.arc(0, 0, size * 0.35, 0, Math.PI * 2);
                                ctx.fill();
                                for (let i = 0; i < 8; i++) {
                                    const angle = (i / 8) * Math.PI * 2 + time;
                                    ctx.strokeStyle = '#ff0000';
                                    ctx.lineWidth = 2;
                                    ctx.beginPath();
                                    ctx.moveTo(Math.cos(angle) * size * 0.4, Math.sin(angle) * size * 0.4);
                                    ctx.lineTo(Math.cos(angle) * size * 0.8, Math.sin(angle) * size * 0.8);
                                    ctx.stroke();
                                }
                            } else if (s.shipClass === 'aether-wing') {
                                const grad = ctx.createLinearGradient(-size, 0, size, 0);
                                grad.addColorStop(0, 'rgba(0,100,255,0)');
                                grad.addColorStop(0.5, 'rgba(100,200,255,0.6)');
                                grad.addColorStop(1, 'rgba(0,100,255,0)');
                                ctx.fillStyle = grad;
                                ctx.beginPath();
                                ctx.moveTo(-size * 0.8, -size * 0.6);
                                ctx.lineTo(size * 0.8, 0);
                                ctx.lineTo(-size * 0.8, size * 0.6);
                                ctx.closePath();
                                ctx.fill();
                            } else if (s.shipClass === 'death-sphere') {
                                const sphereGrad = ctx.createRadialGradient(-size * 0.2, -size * 0.2, 0, 0, 0, size);
                                sphereGrad.addColorStop(0, '#505050');
                                sphereGrad.addColorStop(0.5, '#303030');
                                sphereGrad.addColorStop(1, '#101010');
                                ctx.fillStyle = sphereGrad;
                                ctx.beginPath();
                                ctx.arc(0, 0, size, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.stroke();
                                const laserGrad = ctx.createRadialGradient(size * 0.4, -size * 0.4, 0, size * 0.4, -size * 0.4, size * 0.12);
                                laserGrad.addColorStop(0, '#00ff00');
                                laserGrad.addColorStop(0.5, '#00aa00');
                                laserGrad.addColorStop(1, 'rgba(0,170,0,0)');
                                ctx.fillStyle = laserGrad;
                                ctx.beginPath();
                                ctx.arc(size * 0.4, -size * 0.4, size * 0.1, 0, Math.PI * 2);
                                ctx.fill();
                            } else if (s.shipClass === 'tie-fighter') {
                                const cockpitGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.3);
                                cockpitGrad.addColorStop(0, '#606060');
                                cockpitGrad.addColorStop(0.7, '#303030');
                                cockpitGrad.addColorStop(1, '#101010');
                                ctx.fillStyle = cockpitGrad;
                                ctx.beginPath();
                                for (let i = 0; i < 6; i++) {
                                    const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                                    const x = Math.cos(angle) * size * 0.25;
                                    const y = Math.sin(angle) * size * 0.25;
                                    if (i === 0) ctx.moveTo(x, y);
                                    else ctx.lineTo(x, y);
                                }
                                ctx.closePath();
                                ctx.fill();
                                ctx.stroke();
                                const panelGrad = ctx.createLinearGradient(-size, -size, size, size);
                                panelGrad.addColorStop(0, '#404040');
                                panelGrad.addColorStop(0.5, '#505050');
                                panelGrad.addColorStop(1, '#303030');
                                ctx.fillStyle = panelGrad;
                                ctx.fillRect(-size * 1.2, -size * 0.8, size * 0.8, size * 1.6);
                                ctx.strokeRect(-size * 1.2, -size * 0.8, size * 0.8, size * 1.6);
                                ctx.fillRect(size * 0.4, -size * 0.8, size * 0.8, size * 1.6);
                                ctx.strokeRect(size * 0.4, -size * 0.8, size * 0.8, size * 1.6);
                            } else {
                                // Default fallback for any unrecognized ships
                                ctx.beginPath();
                                ctx.arc(0, 0, size * 0.5, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.stroke();
                            }

                            // Navigation lights (for non-probes, non-saucers)
                            if (s.shipClass !== 'probe' && s.shipClass !== 'saucer') {
                                const lightPulse = Math.sin(time * 3 + (s.lightPhase || 0)) * 0.5 + 0.5;
                                ctx.fillStyle = s.lightColor || '#ff00ff';
                                ctx.globalAlpha = lightPulse;
                                ctx.beginPath();
                                ctx.arc(size * 0.85, 0, 3 / zoom, 0, Math.PI * 2);
                                ctx.fill();

                                // Wing tip lights
                                ctx.fillStyle = '#00ff00';
                                ctx.beginPath();
                                ctx.arc(-size * 0.5, -size * 0.6, 2 / zoom, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.fillStyle = '#ff0000';
                                ctx.beginPath();
                                ctx.arc(-size * 0.5, size * 0.6, 2 / zoom, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.globalAlpha = 1;
                            }

                            ctx.restore();
                        });
                    }
                }

                drawDeepSpaceSpecific() {
                    if (!this.config.showBackground) return;

                    const ctx = this.ctx;
                    const time = performance.now() * 0.0005;

                    // 1. Galaxies
                    if (this.galaxies && this.galaxies.length > 0) {
                        this.galaxies.forEach(g => {
                            if (g.flownOut) return; // Skip if flown out during warp
                            ctx.save();
                            // Position comes from flyObject during disengage
                            ctx.translate(g.x, g.y);

                            // During disengage: use scale and alpha from flyObject
                            if (this.warpDisengaging && g.warpScale !== undefined) {
                                ctx.scale(g.warpScale, g.warpScale);
                                ctx.globalAlpha = g.warpAlpha || 0;
                            }

                            ctx.rotate(g.angle + time * 0.1);

                            const spiralGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, g.size);
                            spiralGradient.addColorStop(0, 'rgba(255,255,255,0.8)');
                            spiralGradient.addColorStop(0.2, g.color);
                            spiralGradient.addColorStop(1, 'transparent');

                            ctx.fillStyle = spiralGradient;
                            ctx.beginPath();
                            for (let i = 0; i < 3; i++) {
                                ctx.rotate(Math.PI * 2 / 3);
                                ctx.ellipse(0, 0, g.size, g.size / 4, 0, 0, Math.PI * 2); // Corrected ellipse center
                            }
                            ctx.fill();
                            ctx.restore();
                        });
                    }

                    // 2. Black Holes
                    if (this.blackHoles && this.blackHoles.length > 0) {
                        this.blackHoles.forEach(bh => {
                            if (bh.flownOut) return; // Skip if flown out during warp
                            ctx.save();

                            // Position comes from flyObject during disengage
                            ctx.translate(bh.x, bh.y);

                            // During disengage: use scale and alpha from flyObject
                            if (this.warpDisengaging && bh.warpScale !== undefined) {
                                ctx.scale(bh.warpScale, bh.warpScale);
                                ctx.globalAlpha = bh.warpAlpha || 0;
                            }

                            // Accretion disk
                            ctx.beginPath();
                            ctx.strokeStyle = 'orange';
                            ctx.lineWidth = 2;
                            ctx.arc(0, 0, bh.size * 1.5, 0, Math.PI * 2);
                            ctx.stroke();

                            // Event Horizon
                            ctx.beginPath();
                            ctx.fillStyle = 'black';
                            ctx.arc(0, 0, bh.size, 0, Math.PI * 2);
                            ctx.fill();

                            // Glow
                            ctx.shadowColor = 'purple';
                            ctx.shadowBlur = 20;
                            ctx.stroke();
                            ctx.shadowBlur = 0;

                            ctx.restore();
                        });
                    }

                    // 3. Planets (with zoom-based detail and proper Saturn-style rings)
                    if (this.planets && this.planets.length > 0) {
                        const zoom = this.camera.zoom;
                        this.planets.forEach(p => {
                            if (p.flownOut) return; // Skip if flown out during warp
                            ctx.save();

                            // Position comes from flyObject during disengage
                            ctx.translate(p.x, p.y);

                            // During disengage: use scale and alpha from flyObject
                            if (this.warpDisengaging && p.warpScale !== undefined) {
                                ctx.scale(p.warpScale, p.warpScale);
                                ctx.globalAlpha = p.warpAlpha || 0;
                            }

                            ctx.rotate(p.axialTilt);

                            const screenRadius = p.radius * zoom;
                            const detailLevel = Math.min(3, Math.floor(screenRadius / 30)); // 0-3 detail levels

                            // === SATURN-STYLE RINGS: Draw back half first ===
                            if (p.hasRings) {
                                this.drawPlanetRingsHalf(ctx, p, 'back');
                            }

                            // Atmospheric glow (outer)
                            if (p.hasAtmosphere) {
                                const atmosGrad = ctx.createRadialGradient(0, 0, p.radius * 0.95, 0, 0, p.radius * 1.15);
                                atmosGrad.addColorStop(0, 'transparent');
                                atmosGrad.addColorStop(0.5, p.atmosphereColor + '40');
                                atmosGrad.addColorStop(1, 'transparent');
                                ctx.fillStyle = atmosGrad;
                                ctx.beginPath();
                                ctx.arc(0, 0, p.radius * 1.15, 0, Math.PI * 2);
                                ctx.fill();
                            }

                            // Planet body with 3D gradient
                            const bodyGrad = ctx.createRadialGradient(
                                -p.radius * 0.3, -p.radius * 0.3, 0,
                                0, 0, p.radius
                            );
                            bodyGrad.addColorStop(0, p.secondaryColor);
                            bodyGrad.addColorStop(0.4, p.baseColor);
                            bodyGrad.addColorStop(0.8, p.tertiaryColor);
                            bodyGrad.addColorStop(1, '#000000');

                            ctx.fillStyle = bodyGrad;
                            ctx.beginPath();
                            ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
                            ctx.fill();

                            // Surface texture (procedural bands/patterns based on zoom)
                            if (detailLevel >= 1) {
                                ctx.globalAlpha = 0.3;
                                ctx.strokeStyle = p.tertiaryColor;
                                ctx.lineWidth = 2 / zoom;

                                // Draw bands for gas giants
                                if (p.type === 'gas-giant' || p.type === 'ice-giant') {
                                    for (let i = -4; i <= 4; i++) {
                                        const bandY = p.radius * (i * 0.15);
                                        const bandWidth = Math.sqrt(p.radius * p.radius - bandY * bandY);
                                        if (bandWidth > 0) {
                                            ctx.beginPath();
                                            ctx.ellipse(0, bandY, bandWidth, 3, 0, 0, Math.PI * 2);
                                            ctx.stroke();
                                        }
                                    }
                                }

                                // Draw continents for terrestrial/ocean
                                if ((p.type === 'terrestrial' || p.type === 'ocean') && detailLevel >= 2) {
                                    ctx.fillStyle = p.type === 'ocean' ? p.baseColor : p.secondaryColor;
                                    const seed = p.textureSeed;
                                    for (let j = 0; j < 5; j++) {
                                        const cx = Math.cos(seed + j * 1.2) * p.radius * 0.5;
                                        const cy = Math.sin(seed * 0.7 + j) * p.radius * 0.4;
                                        const cr = p.radius * (0.15 + Math.sin(seed + j) * 0.1);
                                        ctx.beginPath();
                                        ctx.arc(cx, cy, cr, 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                }
                                ctx.globalAlpha = 1;
                            }

                            // Shadow side
                            const shadowGrad = ctx.createLinearGradient(-p.radius, 0, p.radius, 0);
                            shadowGrad.addColorStop(0, 'transparent');
                            shadowGrad.addColorStop(0.6, 'transparent');
                            shadowGrad.addColorStop(1, 'rgba(0,0,0,0.6)');
                            ctx.fillStyle = shadowGrad;
                            ctx.beginPath();
                            ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
                            ctx.fill();

                            // === SATURN-STYLE RINGS: Draw front half on top ===
                            if (p.hasRings) {
                                this.drawPlanetRingsHalf(ctx, p, 'front');
                            }

                            ctx.restore();
                        });
                    }
                }

                // Helper method for drawing Saturn-style planet rings (half at a time)
                drawPlanetRingsHalf(ctx, planet, half) {
                    const p = planet;
                    ctx.save();

                    // Create clipping region for front or back half
                    ctx.beginPath();
                    if (half === 'back') {
                        // Back half: top portion of ellipse (behind planet)
                        ctx.rect(-p.ringOuterRadius * 1.5, -p.ringOuterRadius, p.ringOuterRadius * 3, p.ringOuterRadius);
                    } else {
                        // Front half: bottom portion of ellipse (in front of planet)
                        ctx.rect(-p.ringOuterRadius * 1.5, 0, p.ringOuterRadius * 3, p.ringOuterRadius);
                    }
                    ctx.clip();

                    // Draw the ring bands
                    ctx.globalAlpha = half === 'back' ? 0.4 : 0.7; // Back rings dimmer

                    // Multiple ring bands with gradient colors
                    for (let i = 0; i < 5; i++) {
                        const ringR = p.ringInnerRadius + (p.ringOuterRadius - p.ringInnerRadius) * (i / 5 + 0.1);
                        const ringThickness = (p.ringOuterRadius - p.ringInnerRadius) * 0.12;

                        // Slight color variation per band
                        const hueShift = i * 5;
                        ctx.strokeStyle = p.ringColor;
                        ctx.lineWidth = ringThickness;

                        ctx.beginPath();
                        ctx.ellipse(0, 0, ringR, ringR * 0.25, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    ctx.restore();
                }

                drawStarShape(ctx, x, y, r) {
                    ctx.beginPath();
                    const pr = r * 0.5;
                    ctx.moveTo(x, y - r);
                    ctx.lineTo(x + pr, y - pr);
                    ctx.lineTo(x + r, y);
                    ctx.lineTo(x + pr, y + pr);
                    ctx.lineTo(x, y + r);
                    ctx.lineTo(x - pr, y + pr);
                    ctx.lineTo(x - r, y);
                    ctx.lineTo(x - pr, y - pr);
                    ctx.closePath();
                    ctx.fill();
                }

                // Get the center point of all stars (constellation center)
                getConstellationCenter() {
                    if (this.stars.length === 0) {
                        return { x: this.canvas.width / 2, y: this.canvas.height / 2, z: 0 };
                    }
                    let sumX = 0, sumY = 0, sumZ = 0;
                    this.stars.forEach(s => {
                        sumX += s.x;
                        sumY += s.y;
                        sumZ += (s.z || 0);
                    });
                    return {
                        x: sumX / this.stars.length,
                        y: sumY / this.stars.length,
                        z: sumZ / this.stars.length
                    };
                }

                // 3D Rotation: Rotate a point around a given center
                rotate3D(x, y, z, centerX, centerY) {
                    // Convert degrees to radians
                    const radX = this.rotationX * Math.PI / 180;
                    const radY = this.rotationY * Math.PI / 180;
                    const radZ = this.rotationZ * Math.PI / 180;

                    // Translate to origin (center of view)
                    let px = x - centerX;
                    let py = y - centerY;
                    let pz = z;

                    // Rotation around X axis
                    let y1 = py * Math.cos(radX) - pz * Math.sin(radX);
                    let z1 = py * Math.sin(radX) + pz * Math.cos(radX);
                    py = y1;
                    pz = z1;

                    // Rotation around Y axis
                    let x1 = px * Math.cos(radY) + pz * Math.sin(radY);
                    z1 = -px * Math.sin(radY) + pz * Math.cos(radY);
                    px = x1;
                    pz = z1;

                    // Rotation around Z axis
                    x1 = px * Math.cos(radZ) - py * Math.sin(radZ);
                    y1 = px * Math.sin(radZ) + py * Math.cos(radZ);
                    px = x1;
                    py = y1;

                    // Simple perspective projection (optional depth effect)
                    const fov = 800;
                    const scale = fov / (fov + pz);

                    // Translate back
                    return {
                        x: px * scale + centerX,
                        y: py * scale + centerY,
                        scale: scale
                    };
                }

                // Inverse 3D Rotation: Project screen point back to 3D world (at Z=0 plane relative to rotation)
                inverseRotate3D(x, y, centerX, centerY) {
                    // Negate angles for inverse rotation
                    const radX = -this.rotationX * Math.PI / 180;
                    const radY = -this.rotationY * Math.PI / 180;
                    const radZ = -this.rotationZ * Math.PI / 180;

                    // Translate to origin
                    let px = x - centerX;
                    let py = y - centerY;
                    let pz = 0; // Assume we are clicking on the plane passing through center

                    // Inverse Order: X^-1( Y^-1( Z^-1( P ) ) )
                    // Note: Forward was RotZ(RotY(RotX(P))). Inverse is RotXinv(RotYinv(RotZinv(P))).

                    // 1. Inverse Z Rotation
                    let x1 = px * Math.cos(radZ) - py * Math.sin(radZ);
                    let y1 = px * Math.sin(radZ) + py * Math.cos(radZ);
                    px = x1;
                    py = y1;

                    // 2. Inverse Y Rotation
                    x1 = px * Math.cos(radY) + pz * Math.sin(radY);
                    let z1 = -px * Math.sin(radY) + pz * Math.cos(radY);
                    px = x1;
                    pz = z1;

                    // 3. Inverse X Rotation
                    y1 = py * Math.cos(radX) - pz * Math.sin(radX);
                    z1 = py * Math.sin(radX) + pz * Math.cos(radX);
                    py = y1;
                    pz = z1;

                    // Translate back
                    return {
                        x: px + centerX,
                        y: py + centerY,
                        z: pz
                    };
                }

                // Reset rotation sliders and values
                resetRotation() {
                    this.rotationX = 0;
                    this.rotationY = 0;
                    this.rotationZ = 0;

                    const xSlider = document.getElementById('rotXSlider');
                    const ySlider = document.getElementById('rotYSlider');
                    const zSlider = document.getElementById('rotZSlider');

                    if (xSlider) { xSlider.value = 0; document.getElementById('rotXValue').textContent = '0Â°'; }
                    if (ySlider) { ySlider.value = 0; document.getElementById('rotYValue').textContent = '0Â°'; }
                    if (zSlider) { zSlider.value = 0; document.getElementById('rotZValue').textContent = '0Â°'; }
                }

                calculateGeometry() {
                    const lines = [];
                    const adj = {};
                    // Performance fix: use Map for O(1) star lookups
                    const starMap = new Map();
                    this.stars.forEach(s => {
                        adj[s.id] = [];
                        starMap.set(s.id, s);
                    });

                    for (let i = 0; i < this.stars.length; i++) {
                        for (let j = i + 1; j < this.stars.length; j++) {
                            const s1 = this.stars[i];
                            const s2 = this.stars[j];
                            const dist = Math.hypot(s1.x - s2.x, s1.y - s2.y);

                            if (dist < this.config.maxConnectDist) {
                                lines.push({ s1, s2, dist });
                                adj[s1.id].push(s2.id);
                                adj[s2.id].push(s1.id);
                            }
                        }
                    }

                    // BFS for clusters
                    const clusters = [];
                    const visited = new Set();
                    this.stars.forEach(star => {
                        if (!visited.has(star.id)) {
                            const cluster = [];
                            const queue = [star.id];
                            visited.add(star.id);
                            while (queue.length) {
                                const id = queue.shift();
                                const s = starMap.get(id); // O(1) lookup
                                if (s) cluster.push(s);
                                adj[id].forEach(nid => {
                                    if (!visited.has(nid)) {
                                        visited.add(nid);
                                        queue.push(nid);
                                    }
                                });
                            }
                            if (cluster.length > 0) clusters.push(cluster);
                        }
                    });

                    return { lines, clusters };
                }

                showToast(msg) {
                    console.log('[Toast]', msg);
                    // Create a toast element if needed
                    let toast = document.getElementById('toast');
                    if (!toast) {
                        toast = document.createElement('div');
                        toast.id = 'toast';
                        toast.style.cssText = 'position:fixed;bottom:80px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.8);color:white;padding:10px 20px;border-radius:8px;z-index:9999;transition:opacity 0.3s';
                        document.body.appendChild(toast);
                    }
                    toast.textContent = msg;
                    toast.style.opacity = '1';
                    clearTimeout(this._toastTimeout);
                    this._toastTimeout = setTimeout(() => { toast.style.opacity = '0'; }, 2000);
                }

                // Ship Selection Methods
                showShipModal() {
                    const modal = document.getElementById('shipModal');
                    if (modal) modal.classList.add('active');
                }

                hideShipModal() {
                    const modal = document.getElementById('shipModal');
                    if (modal) modal.classList.remove('active');
                }

                captureConstellation() {
                    if (this.stars.length < 3) {
                        this.showToast("Draw at least 3 stars first!");
                        return;
                    }

                    // 1. Calculate Centroid
                    let sumX = 0, sumY = 0, sumZ = 0;
                    this.stars.forEach(s => {
                        sumX += s.x;
                        sumY += s.y;
                        sumZ += (s.z || 0);
                    });
                    const centerX = sumX / this.stars.length;
                    const centerY = sumY / this.stars.length;
                    const centerZ = sumZ / this.stars.length;

                    // 2. Normalize Stars (Center at 0,0,0) and Scale down
                    const scale = 0.5; // Scale down for ship size
                    const validStars = this.stars.map(s => ({
                        x: (s.x - centerX) * scale,
                        y: (s.y - centerY) * scale,
                        z: ((s.z || 0) - centerZ) * scale,
                        color: s.color
                    }));

                    // 3. Capture Connections (Lines)
                    // We need to map original IDs to indices or new IDs
                    const starIdToIndex = {};
                    this.stars.forEach((s, i) => starIdToIndex[s.id] = i);

                    const validLines = [];
                    const lines = this.calculateGeometry().lines; // Get current lines
                    lines.forEach(l => {
                        const idx1 = starIdToIndex[l.from];
                        const idx2 = starIdToIndex[l.to];
                        if (idx1 !== undefined && idx2 !== undefined) {
                            validLines.push({ fromIndex: idx1, toIndex: idx2 });
                        }
                    });

                    // 4. Save to PlayerShip
                    this.playerShip.customStructure = {
                        stars: validStars,
                        lines: validLines
                    };

                    // Save to LocalStorage
                    localStorage.setItem('customShipStructure', JSON.stringify(this.playerShip.customStructure));

                    // Auto-select "Orion" type (which we'll use for custom)
                    this.playerShip.type = 'orion';
                    localStorage.setItem('playerShipType', 'orion');

                    this.showToast("Constellation SAVED as Spacecraft!");
                }

                selectShip(shipType) {
                    const ships = {
                        interceptor: { name: 'Interceptor', maxSpeed: 90, acceleration: 0.8 },
                        saucer: { name: 'Saucer', maxSpeed: 110, acceleration: 1.0 },
                        hauler: { name: 'Hauler', maxSpeed: 60, acceleration: 0.5 },
                        orion: { name: 'Orion', maxSpeed: 100, acceleration: 0.9 },
                        draco: { name: 'Draco', maxSpeed: 130, acceleration: 0.7 },
                        phoenix: { name: 'Phoenix', maxSpeed: 95, acceleration: 1.2 },
                        harvester: { name: 'Starfighter', maxSpeed: 140, acceleration: 1.3 }
                    };
                    const ship = ships[shipType];
                    if (ship && this.playerShip) {
                        this.playerShip.type = shipType;
                        this.playerShip.maxSpeed = ship.maxSpeed;
                        this.playerShip.acceleration = ship.acceleration;
                        this.showToast(`Selected ${ship.name} `);
                    }
                    this.hideShipModal();
                }

                toggleAutopilot() {
                    this.autopilot = !this.autopilot;
                    const btn = document.querySelector('button[onclick="app.toggleAutopilot()"]');
                    if (btn) {
                        btn.classList.toggle('active', this.autopilot);
                        btn.style.color = this.autopilot ? '#00f3ff' : '#5c7a8a';
                    }
                    this.showToast(this.autopilot ? "Autopilot ENGAGED" : "Autopilot DISENGAGED");
                }

                // Legacy support for gems resize if needed
                initGemsResize() {
                    if (this.initGemsSectionResize) {
                        this.initGemsSectionResize();
                    }
                }

                flightZoom(amount) {
                    // Simple zoom for flight mode buttons
                    const newZoom = Math.max(0.1, Math.min(6.0, this.camera.zoom + amount));
                    this.camera.zoom = newZoom;

                    // Update display if it exists
                    const zoomDisplay = document.getElementById('zoomDisplay');
                    if (zoomDisplay) {
                        zoomDisplay.textContent = this.camera.zoom.toFixed(1) + 'x';
                    }

                    // If in expanded map mode, also update that
                    if (this.expandedMapMode) {
                        this.expandedMapZoom = Math.max(0.2, Math.min(10.0, this.expandedMapZoom + amount));
                    }
                }

                downloadSVG() {
                    if (this.stars.length === 0) {
                        this.showToast("Universe is empty!");
                        return;
                    }

                    // Ensure cluster IDs are assigned for naming in SVG
                    this.refreshClusterAssignments();

                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    this.stars.forEach(s => {
                        minX = Math.min(minX, s.x); minY = Math.min(minY, s.y);
                        maxX = Math.max(maxX, s.x); maxY = Math.max(maxY, s.y);
                    });

                    const pad = 100;
                    const w = (maxX - minX) + pad * 2;
                    const h = (maxY - minY) + pad * 2;
                    const vbX = minX - pad;
                    const vbY = minY - pad;

                    const { lines, clusters } = this.calculateGeometry();

                    let svg = `< svg xmlns = "http://www.w3.org/2000/svg" viewBox = "${vbX} ${vbY} ${w} ${h}" style = "background:#020205" >
            <rect x="${vbX}" y="${vbY}" width="${w}" height="${h}" fill="#020205" />`;

                    // Lines
                    lines.forEach(l => {
                        const op = (1 - (l.dist / this.config.maxConnectDist)).toFixed(2);
                        const [r, g, b] = this.hexToRgb(this.getStarColor(l.s1));
                        svg += `< line x1 = "${l.s1.x}" y1 = "${l.s1.y}" x2 = "${l.s2.x}" y2 = "${l.s2.y}" stroke = "rgb(${r}, ${g}, ${b})" stroke - width="1.5" stroke - linecap="round" opacity = "${op * 0.8}" /> `;
                    });

                    // Labels
                    clusters.forEach(c => {
                        const name = String(c[0].clusterId);
                        if (c.length < this.config.minGroupSize || name === String(c[0].id)) return;

                        let cx = 0, cy = 0; c.forEach(s => { cx += s.x; cy += s.y }); cx /= c.length; cy /= c.length;
                        const color = this.getStarColor(c[0]);
                        svg += `< text x = "${cx}" y = "${cy + 30}" font - family="sans-serif" font - size="14" fill = "${color}" text - anchor="middle" font - weight="600" > ${name}</text > `;
                    });

                    // Stars
                    this.stars.forEach(s => {
                        const color = this.getStarColor(s);
                        const r = this.config.starBaseRad * 1.5;

                        // Star Shape
                        const pr = r * 0.5;
                        const pathData = `M${s.x} ${s.y - r} L${s.x + pr} ${s.y - pr} L${s.x + r} ${s.y} L${s.x + pr} ${s.y + pr} L${s.x} ${s.y + r} L${s.x - pr} ${s.y + pr} L${s.x - r} ${s.y} L${s.x - pr} ${s.y - pr} Z`;
                        svg += `< path d = "${pathData}" fill = "${color}" opacity = "0.8" /> `;

                        // Core dot
                        svg += `< circle cx = "${s.x}" cy = "${s.y}" r = "1.5" fill = "white" /> `;
                    });

                    svg += `</svg > `;

                    // FileSaver-style download for Chrome compatibility
                    const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
                    const filename = `AetherMap - ${Date.now()}.svg`;

                    // Try using msSaveBlob for IE/Edge compatibility
                    if (typeof window.navigator.msSaveBlob !== 'undefined') {
                        window.navigator.msSaveBlob(blob, filename);
                        this.showToast("Map Exported");
                        return;
                    }

                    const url = window.URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;

                    // Dispatch a real click event instead of calling click()
                    const event = new MouseEvent('click', {
                        view: window,
                        bubbles: true,
                        cancelable: true
                    });
                    link.dispatchEvent(event);

                    // Clean up after a delay
                    setTimeout(() => {
                        window.URL.revokeObjectURL(url);
                    }, 1000);

                    this.showToast("Map Exported");
                }

                // Download canvas as PNG image
                downloadPNG() {
                    const filename = `Interstellar - ${Date.now()}.png`;
                    const link = document.createElement('a');
                    link.download = filename;
                    link.href = this.canvas.toDataURL('image/png');

                    // Dispatch a real click event for Chrome compatibility
                    const event = new MouseEvent('click', {
                        view: window,
                        bubbles: true,
                        cancelable: true
                    });
                    link.dispatchEvent(event);

                    this.showToast("Image saved as " + filename);
                }

                // Trigger the hidden file input for loading SVG
                triggerLoadSVG() {
                    document.getElementById('svgFileInput').click();
                }

                // Load and parse an SVG file to restore stars
                loadSVG(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const svgContent = e.target.result;
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(svgContent, 'image/svg+xml');

                            // Find all path elements (stars)
                            const pathElements = doc.querySelectorAll('path[fill][opacity]');

                            if (pathElements.length === 0) {
                                this.showToast("No stars found in SVG");
                                return;
                            }

                            // Clear current stars and history
                            this.stars = [];
                            this.history = [];

                            // Parse each path to extract star data
                            pathElements.forEach((path, index) => {
                                const d = path.getAttribute('d');
                                const fill = path.getAttribute('fill');

                                // Parse path: M{x} {y-r} L...
                                const match = d.match(/M([-\d.]+)\s+([-\d.]+)/);
                                if (match) {
                                    const topX = parseFloat(match[1]);
                                    const topY = parseFloat(match[2]);
                                    const r = this.config.starBaseRad * 1.5;
                                    const y = topY + r;

                                    this.stars.push({
                                        id: Date.now() + index,
                                        x: topX,
                                        y: y,
                                        color: fill,
                                        phase: Math.random() * Math.PI * 2,
                                        clusterId: null
                                    });
                                }
                            });

                            event.target.value = '';
                            this.showToast(`Loaded ${this.stars.length} stars`);
                            this.draw();
                        } catch (err) {
                            console.error('Error parsing SVG:', err);
                            this.showToast("Error loading SVG file");
                        }
                    };
                    reader.readAsText(file);
                }

                // Export canvas animation as video
                exportVideo() {
                    if (this._isRecording) {
                        this.showToast("Already recording...");
                        return;
                    }

                    // Get selected duration
                    const durationSelect = document.getElementById('videoDuration');
                    const duration = durationSelect ? parseInt(durationSelect.value) : 5000;
                    const durationSec = duration / 1000;

                    this._isRecording = true;
                    const btn = document.getElementById('exportVideoBtn');
                    if (btn) btn.classList.add('active');

                    this.showToast(`Recording ${durationSec} seconds...`);

                    const stream = this.canvas.captureStream(30);
                    const chunks = [];

                    const mimeType = MediaRecorder.isTypeSupported('video/webm;codecs=vp9')
                        ? 'video/webm;codecs=vp9'
                        : 'video/webm';

                    const recorder = new MediaRecorder(stream, { mimeType });

                    recorder.ondataavailable = (e) => {
                        if (e.data.size > 0) chunks.push(e.data);
                    };

                    recorder.onstop = () => {
                        this._isRecording = false;
                        if (btn) btn.classList.remove('active');

                        const blob = new Blob(chunks, { type: mimeType });
                        const filename = `Interstellar - ${Date.now()}.webm`;
                        const url = window.URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = filename;

                        // Dispatch a real click event for Chrome compatibility
                        const event = new MouseEvent('click', {
                            view: window,
                            bubbles: true,
                            cancelable: true
                        });
                        link.dispatchEvent(event);

                        // Clean up after a delay
                        setTimeout(() => {
                            window.URL.revokeObjectURL(url);
                        }, 1000);

                        this.showToast("Video exported!");
                    };

                    recorder.onerror = (e) => {
                        this._isRecording = false;
                        if (btn) btn.classList.remove('active');
                        console.error('Recording error:', e);
                        this.showToast("Recording failed");
                    };

                    recorder.start();

                    setTimeout(() => {
                        if (recorder.state === 'recording') {
                            recorder.stop();
                        }
                    }, duration);
                }
            }
        }

        window.app = new AetherEngine();
    </script>
</body>

</html>